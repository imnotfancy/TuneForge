# Project Structure

```
├── backend
│   ├── amazon.go
│   ├── analysis.go
│   ├── config.go
│   ├── deezer.go
│   ├── filename.go
│   ├── folder.go
│   ├── lyrics.go
│   ├── metadata.go
│   ├── progress.go
│   ├── qobuz.go
│   ├── romaji.go
│   ├── songlink.go
│   ├── spectrum.go
│   ├── spotify_metadata.go
│   └── tidal.go
├── cli
│   ├── build.sh
│   ├── COMPARISON.md
│   ├── examples.sh
│   ├── main.go
│   ├── Makefile
│   ├── PYTHON_INTEGRATION.md
│   ├── QUICKSTART.md
│   └── README.md
├── frontend
│   ├── public
│   │   └── icon.svg
│   ├── scripts
│   │   └── generate-icon.js
│   ├── src
│   │   ├── components
│   │   │   ├── ui
│   │   │   │   ├── badge.tsx
│   │   │   │   ├── button.tsx
│   │   │   │   ├── card.tsx
│   │   │   │   ├── checkbox.tsx
│   │   │   │   ├── context-menu.tsx
│   │   │   │   ├── dialog.tsx
│   │   │   │   ├── input-with-context.tsx
│   │   │   │   ├── input.tsx
│   │   │   │   ├── label.tsx
│   │   │   │   ├── pagination.tsx
│   │   │   │   ├── progress.tsx
│   │   │   │   ├── radio-group.tsx
│   │   │   │   ├── select.tsx
│   │   │   │   ├── sonner.tsx
│   │   │   │   ├── spinner.tsx
│   │   │   │   ├── tabs.tsx
│   │   │   │   └── tooltip.tsx
│   │   │   ├── AlbumInfo.tsx
│   │   │   ├── ArtistInfo.tsx
│   │   │   ├── AudioAnalysis.tsx
│   │   │   ├── AudioAnalysisDialog.tsx
│   │   │   ├── DebugLogger.tsx
│   │   │   ├── DownloadProgress.tsx
│   │   │   ├── DownloadProgressToast.tsx
│   │   │   ├── FetchHistory.tsx
│   │   │   ├── Header.tsx
│   │   │   ├── PlatformIcons.tsx
│   │   │   ├── PlaylistInfo.tsx
│   │   │   ├── SearchAndSort.tsx
│   │   │   ├── SearchBar.tsx
│   │   │   ├── Settings.tsx
│   │   │   ├── SpectrumVisualization.tsx
│   │   │   ├── TitleBar.tsx
│   │   │   ├── TrackInfo.tsx
│   │   │   └── TrackList.tsx
│   │   ├── hooks
│   │   │   ├── useAudioAnalysis.ts
│   │   │   ├── useAvailability.ts
│   │   │   ├── useDownload.ts
│   │   │   ├── useDownloadProgress.ts
│   │   │   ├── useLyrics.ts
│   │   │   └── useMetadata.ts
│   │   ├── lib
│   │   │   ├── api.ts
│   │   │   ├── audio.ts
│   │   │   ├── logger.ts
│   │   │   ├── settings.ts
│   │   │   ├── themes.ts
│   │   │   ├── toast-with-sound.ts
│   │   │   └── utils.ts
│   │   ├── types
│   │   │   └── api.ts
│   │   ├── App.tsx
│   │   ├── index.css
│   │   └── main.tsx
│   ├── components.json
│   ├── eslint.config.js
│   ├── index.html
│   ├── package.json
│   ├── package.json.md5
│   ├── pnpm-lock.yaml
│   ├── tsconfig.app.json
│   ├── tsconfig.json
│   ├── tsconfig.node.json
│   └── vite.config.ts
├── app.go
├── CLI_ENHANCEMENTS.md
├── CLI_IMPLEMENTATION.md
├── DEPLOYMENT_README.md
├── DEVCONTAINER_UPDATES.md
├── go.mod
├── go.sum
├── main.go
├── README.md
├── SAMPLEHUNT_API.md
├── SAMPLEHUNT_DEPLOYMENT.md
├── SAMPLEHUNT_INTEGRATION.md
├── SAMPLEHUNT_TESTING.md
├── SAMPLEHUNT_WORKER.md
├── tidal.json
├── version.json
└── wails.json
```

# File Contents

## README.md

```markdown
[![GitHub All Releases](https://img.shields.io/github/downloads/afkarxyz/SpotiFLAC/total?style=for-the-badge)](https://github.com/afkarxyz/SpotiFLAC/releases)

![Image](https://github.com/user-attachments/assets/a6e92fdd-2944-45c1-83e8-e23a26c827af)

<div align="center">

Get Spotify tracks in true FLAC from Tidal, Deezer, Qobuz & Amazon Music — no account required.

![Windows](https://img.shields.io/badge/Windows-10%2B-0078D6?style=for-the-badge&logo=data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI1MTIiIGhlaWdodD0iNTEyIiB2aWV3Qm94PSIwIDAgMjAgMjAiPjxwYXRoIGZpbGw9IiNmZmZmZmYiIGZpbGwtcnVsZT0iZXZlbm9kZCIgZD0iTTIwIDEwLjg3M1YyMEw4LjQ3OSAxOC41MzdsLjAwMS03LjY2NEgyMFptLTEzLjEyIDBsLS4wMDEgNy40NjFMMCAxNy40NjF2LTYuNTg4aDYuODhaTTIwIDkuMjczSDguNDhsLS4wMDEtNy44MUwyMCAwdjkuMjczWk02Ljg3OSAxLjY2NmwuMDAxIDcuNjA3SDBWMi41MzlsNi44NzktLjg3M1oiLz48L3N2Zz4=)
![macOS](https://img.shields.io/badge/macOS-10.13%2B-000000?style=for-the-badge&logo=apple&logoColor=white)
![Linux](https://img.shields.io/badge/Linux-Any-FCC624?style=for-the-badge&logo=linux&logoColor=white)

</div>

### [Download](https://github.com/afkarxyz/SpotiFLAC/releases)

## Screenshot

![Image](https://github.com/user-attachments/assets/7aff07fa-abaa-4f88-96eb-c8b6794d206e)

## Lossless Audio Checker

A simple utility for verifying the authenticity of FLAC files.

#### [Download](https://github.com/afkarxyz/SpotiFLAC/releases/download/v0/FLAC-Checker.zip) - Windows only

#

![image](https://github.com/user-attachments/assets/d63b422d-0ea3-4307-850f-96c99d7eaa9a)

![image](https://github.com/user-attachments/assets/7649e6e1-d5d1-49b3-b83f-965d44651d05)

## Command-Line Interface (CLI)

A standalone, headless CLI tool is available for automation and scripting:

```bash
cd cli
make build
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -service deezer -json -quiet
```

**Features:**
- JSON output for easy parsing
- ISRC direct input support
- Multiple service fallback
- Perfect for Python/Node.js integration
- No GUI dependencies

**Documentation:**
- [CLI README](cli/README.md) - Complete documentation
- [Quick Start Guide](cli/QUICKSTART.md) - Get started quickly
- [Python Integration](cli/PYTHON_INTEGRATION.md) - Integration examples

## Integration Documentation

**⚠️ Important:** The integration guides (SAMPLEHUNT_*.md) are **EXAMPLES ONLY** and are **NOT deployed**.

These documents show how to integrate SpotiFLAC CLI into larger systems:
- [Integration Overview](SAMPLEHUNT_INTEGRATION.md) - Architecture guide
- [Worker Implementation](SAMPLEHUNT_WORKER.md) - Python worker examples
- [API Specification](SAMPLEHUNT_API.md) - API design examples
- [Deployment Guide](SAMPLEHUNT_DEPLOYMENT.md) - Deployment examples
- [Testing Guide](SAMPLEHUNT_TESTING.md) - Testing strategies

**See [DEPLOYMENT_README.md](DEPLOYMENT_README.md) for important warnings about these guides.**

## Other projects

### [SpotiDownloader](https://github.com/afkarxyz/SpotiDownloader) 

Get Spotify tracks in MP3 and FLAC via the spotidownloader.com API

```

## SAMPLEHUNT_API.md

```markdown
# SampleHunt API Specification

## ⚠️ IMPORTANT: Specification Only - Not Implemented

**This is an API SPECIFICATION with code examples. Nothing is deployed.**

- ❌ No API server is running
- ❌ No endpoints are live
- ❌ No database is created
- ✅ This is a design document
- ✅ You must implement the API yourself
- ✅ All code examples require customization

**See [DEPLOYMENT_README.md](DEPLOYMENT_README.md) for important warnings.**

---

## Overview

FastAPI-based backend API specification for the SampleHunt PoC. Handles user requests, authentication, task dispatch, and result retrieval.

**Note:** This is a specification document with implementation examples.

## API Endpoints

### 1. Create Sample Request

**POST** `/api/v1/samples`

Create a new sample processing request.

**Request Body:**
```json
{
  "identification": {
    "isrc": "USUM71900001",
    "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
    "title": "Example Song",
    "artist": "Example Artist",
    "album": "Example Album"
  },
  "options": {
    "include_lyrics": true,
    "preferred_service": "tidal",
    "audio_format": "HI_RES"
  }
}
```

**Response:** `201 Created`
```json
{
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "QUEUED",
  "created_at": "2025-11-28T05:10:00Z",
  "estimated_completion": "2025-11-28T05:15:00Z"
}
```

**Error Responses:**
- `400 Bad Request` - Invalid input
- `401 Unauthorized` - Authentication required
- `429 Too Many Requests` - Rate limit exceeded

### 2. Get Sample Status

**GET** `/api/v1/samples/{request_id}`

Get the current status of a sample request.

**Response:** `200 OK`
```json
{
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "PROCESSING_AUDIO",
  "progress": {
    "phase": "Audio Processing",
    "percentage": 60,
    "message": "Extracting stems..."
  },
  "created_at": "2025-11-28T05:10:00Z",
  "updated_at": "2025-11-28T05:12:30Z"
}
```

**Status Values:**
- `QUEUED` - Waiting in queue
- `ACQUIRING_AUDIO` - Downloading audio
- `PROCESSING_AUDIO` - Extracting stems and MIDI
- `RESEARCHING` - Gathering metadata
- `PACKAGING` - Finalizing package
- `READY` - Complete and ready for download
- `FAILED` - Processing failed
- `FAILED_ACQUISITION` - Audio acquisition failed
- `FAILED_PROCESSING` - Audio processing failed

### 3. Get Sample Package

**GET** `/api/v1/samples/{request_id}/package`

Retrieve the complete sample package (only available when status is `READY`).

**Response:** `200 OK`
```json
{
  "request_id": "550e8400-e29b-41d4-a716-446655440000",
  "status": "READY",
  "metadata": {
    "title": "Example Song",
    "artist": "Example Artist",
    "album": "Example Album",
    "isrc": "USUM71900001",
    "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
    "duration_ms": 240000,
    "release_date": "2019-01-01"
  },
  "analysis": {
    "key": "Am",
    "bpm": 128,
    "time_signature": "4/4",
    "chords": ["Am", "G", "C", "F"],
    "audio_features": {
      "energy": 0.85,
      "danceability": 0.72,
      "valence": 0.65,
      "acousticness": 0.12,
      "instrumentalness": 0.05
    },
    "genre_tags": ["pop", "electronic", "dance"]
  },
  "assets": {
    "source_audio": {
      "url": "https://s3.presigned.url/request_id/source.flac",
      "format": "FLAC",
      "quality": "HI_RES",
      "service": "Tidal",
      "size_bytes": 45678901,
      "expires_at": "2025-11-28T06:10:00Z"
    },
    "stems": {
      "vocals": {
        "url": "https://s3.presigned.url/request_id/stems/vocals.wav",
        "format": "WAV",
        "size_bytes": 12345678,
        "expires_at": "2025-11-28T06:10:00Z"
      },
      "drums": {
        "url": "https://s3.presigned.url/request_id/stems/drums.wav",
        "format": "WAV",
        "size_bytes": 10234567,
        "expires_at": "2025-11-28T06:10:00Z"
      },
      "bass": {
        "url": "https://s3.presigned.url/request_id/stems/bass.wav",
        "format": "WAV",
        "size_bytes": 8901234,
        "expires_at": "2025-11-28T06:10:00Z"
      },
      "other": {
        "url": "https://s3.presigned.url/request_id/stems/other.wav",
        "format": "WAV",
        "size_bytes": 15678901,
        "expires_at": "2025-11-28T06:10:00Z"
      }
    },
    "midi": {
      "combined": {
        "url": "https://s3.presigned.url/request_id/midi/combined.mid",
        "format": "MIDI",
        "size_bytes": 45678,
        "expires_at": "2025-11-28T06:10:00Z"
      },
      "melody": {
        "url": "https://s3.presigned.url/request_id/midi/melody.mid",
        "format": "MIDI",
        "size_bytes": 12345,
        "expires_at": "2025-11-28T06:10:00Z"
      }
    }
  },
  "prompts": [
    {
      "category": "Faithful Recreation",
      "prompt": "Create a track in Am at 128 BPM with high energy (0.85) and danceability (0.72). Use electronic pop production with prominent synths and a driving beat. Maintain the uplifting, positive mood (valence 0.65).",
      "tags": ["recreation", "original-style"]
    },
    {
      "category": "Genre Flip",
      "prompt": "Transform this electronic pop track into a lo-fi hip-hop version. Keep the Am key and 128 BPM but add jazzy chords, vinyl crackle, and laid-back drums. Preserve the melodic elements but with a more relaxed, introspective vibe.",
      "tags": ["genre-flip", "lo-fi", "hip-hop"]
    },
    {
      "category": "Mood Shift",
      "prompt": "Reimagine this upbeat dance track as a melancholic ballad. Slow the tempo to 70 BPM, use sparse piano and strings, and emphasize the emotional depth of the Am key. Transform the energy into introspection.",
      "tags": ["mood-shift", "ballad", "emotional"]
    }
  ],
  "created_at": "2025-11-28T05:10:00Z",
  "completed_at": "2025-11-28T05:14:32Z"
}
```

**Error Responses:**
- `404 Not Found` - Request ID not found
- `425 Too Early` - Processing not complete yet

### 4. List User Samples

**GET** `/api/v1/samples`

List all sample requests for the authenticated user.

**Query Parameters:**
- `status` (optional) - Filter by status
- `limit` (optional, default: 20) - Number of results
- `offset` (optional, default: 0) - Pagination offset

**Response:** `200 OK`
```json
{
  "total": 42,
  "limit": 20,
  "offset": 0,
  "samples": [
    {
      "request_id": "550e8400-e29b-41d4-a716-446655440000",
      "status": "READY",
      "metadata": {
        "title": "Example Song",
        "artist": "Example Artist"
      },
      "created_at": "2025-11-28T05:10:00Z",
      "completed_at": "2025-11-28T05:14:32Z"
    }
  ]
}
```

### 5. Delete Sample

**DELETE** `/api/v1/samples/{request_id}`

Delete a sample request and all associated assets.

**Response:** `204 No Content`

**Error Responses:**
- `404 Not Found` - Request ID not found
- `403 Forbidden` - Not authorized to delete this sample

### 6. Health Check

**GET** `/health`

Check API health status.

**Response:** `200 OK`
```json
{
  "status": "healthy",
  "version": "1.0.0",
  "services": {
    "database": "healthy",
    "redis": "healthy",
    "workers": "healthy",
    "storage": "healthy"
  },
  "timestamp": "2025-11-28T05:10:00Z"
}
```

## FastAPI Implementation

### Project Structure

```
samplehunt-api/
├── main.py
├── requirements.txt
├── Dockerfile
├── api/
│   ├── __init__.py
│   ├── routes/
│   │   ├── __init__.py
│   │   ├── samples.py
│   │   └── health.py
│   ├── models/
│   │   ├── __init__.py
│   │   ├── request.py
│   │   └── response.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── database.py
│   │   ├── tasks.py
│   │   └── auth.py
│   └── dependencies.py
└── tests/
    └── test_api.py
```

### main.py

```python
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from api.routes import samples, health
from api.dependencies import get_settings

settings = get_settings()

app = FastAPI(
    title="SampleHunt API",
    version="1.0.0",
    description="Audio sample processing and analysis API"
)

# CORS
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Routes
app.include_router(samples.router, prefix="/api/v1", tags=["samples"])
app.include_router(health.router, tags=["health"])

@app.on_event("startup")
async def startup_event():
    """Initialize services on startup."""
    pass

@app.on_event("shutdown")
async def shutdown_event():
    """Cleanup on shutdown."""
    pass
```

### api/routes/samples.py

```python
from fastapi import APIRouter, Depends, HTTPException, status
from typing import List, Optional
from uuid import uuid4
from datetime import datetime, timedelta

from api.models.request import SampleRequest, SampleOptions
from api.models.response import (
    SampleResponse,
    SamplePackage,
    SampleListResponse
)
from api.services.database import DatabaseService
from api.services.tasks import TaskService
from api.dependencies import get_db, get_task_service, get_current_user

router = APIRouter()

@router.post("/samples", response_model=SampleResponse, status_code=status.HTTP_201_CREATED)
async def create_sample(
    request: SampleRequest,
    db: DatabaseService = Depends(get_db),
    tasks: TaskService = Depends(get_task_service),
    user_id: str = Depends(get_current_user)
):
    """Create a new sample processing request."""
    
    # Validate input
    if not request.identification.isrc and not request.identification.spotify_id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Either ISRC or Spotify ID is required"
        )
    
    # Generate request ID
    request_id = str(uuid4())
    
    # Save to database
    db.create_sample_request(
        request_id=request_id,
        user_id=user_id,
        identification=request.identification.dict(),
        options=request.options.dict() if request.options else {},
        status="QUEUED"
    )
    
    # Dispatch Celery task
    tasks.dispatch_process_sample(
        request_id=request_id,
        spotify_id=request.identification.spotify_id,
        isrc=request.identification.isrc
    )
    
    return SampleResponse(
        request_id=request_id,
        status="QUEUED",
        created_at=datetime.utcnow(),
        estimated_completion=datetime.utcnow() + timedelta(minutes=5)
    )

@router.get("/samples/{request_id}", response_model=SampleResponse)
async def get_sample_status(
    request_id: str,
    db: DatabaseService = Depends(get_db),
    user_id: str = Depends(get_current_user)
):
    """Get sample request status."""
    
    sample = db.get_sample_request(request_id, user_id)
    if not sample:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Sample request not found"
        )
    
    return SampleResponse(**sample)

@router.get("/samples/{request_id}/package", response_model=SamplePackage)
async def get_sample_package(
    request_id: str,
    db: DatabaseService = Depends(get_db),
    user_id: str = Depends(get_current_user)
):
    """Get complete sample package."""
    
    sample = db.get_sample_request(request_id, user_id)
    if not sample:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Sample request not found"
        )
    
    if sample['status'] != 'READY':
        raise HTTPException(
            status_code=status.HTTP_425_TOO_EARLY,
            detail=f"Sample is not ready yet. Current status: {sample['status']}"
        )
    
    package = db.get_sample_package(request_id)
    return SamplePackage(**package)

@router.get("/samples", response_model=SampleListResponse)
async def list_samples(
    status: Optional[str] = None,
    limit: int = 20,
    offset: int = 0,
    db: DatabaseService = Depends(get_db),
    user_id: str = Depends(get_current_user)
):
    """List user's sample requests."""
    
    samples = db.list_sample_requests(
        user_id=user_id,
        status=status,
        limit=limit,
        offset=offset
    )
    
    total = db.count_sample_requests(user_id=user_id, status=status)
    
    return SampleListResponse(
        total=total,
        limit=limit,
        offset=offset,
        samples=samples
    )

@router.delete("/samples/{request_id}", status_code=status.HTTP_204_NO_CONTENT)
async def delete_sample(
    request_id: str,
    db: DatabaseService = Depends(get_db),
    user_id: str = Depends(get_current_user)
):
    """Delete a sample request and all assets."""
    
    sample = db.get_sample_request(request_id, user_id)
    if not sample:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Sample request not found"
        )
    
    # Delete from storage
    from api.services.storage import StorageService
    storage = StorageService()
    storage.delete_request_assets(request_id)
    
    # Delete from database
    db.delete_sample_request(request_id)
    
    return None
```

### api/models/request.py

```python
from pydantic import BaseModel, Field
from typing import Optional

class Identification(BaseModel):
    isrc: Optional[str] = Field(None, description="ISRC code")
    spotify_id: Optional[str] = Field(None, description="Spotify track ID")
    title: str = Field(..., description="Track title")
    artist: str = Field(..., description="Artist name")
    album: Optional[str] = Field(None, description="Album name")

class SampleOptions(BaseModel):
    include_lyrics: bool = Field(False, description="Include lyrics download")
    preferred_service: Optional[str] = Field(None, description="Preferred streaming service")
    audio_format: str = Field("LOSSLESS", description="Audio format (LOSSLESS, HI_RES)")

class SampleRequest(BaseModel):
    identification: Identification
    options: Optional[SampleOptions] = None
```

### api/services/tasks.py

```python
from celery import Celery
import os

class TaskService:
    """Service for dispatching Celery tasks."""
    
    def __init__(self):
        self.celery_app = Celery(
            'samplehunt',
            broker=os.getenv('CELERY_BROKER_URL'),
            backend=os.getenv('CELERY_RESULT_BACKEND')
        )
    
    def dispatch_process_sample(
        self,
        request_id: str,
        spotify_id: Optional[str],
        isrc: Optional[str]
    ):
        """Dispatch sample processing task."""
        self.celery_app.send_task(
            'worker.tasks.process_sample',
            args=[request_id, spotify_id, isrc],
            queue='acquisition'
        )
```

## Database Schema

```sql
CREATE TABLE sample_requests (
    request_id UUID PRIMARY KEY,
    user_id VARCHAR(255) NOT NULL,
    status VARCHAR(50) NOT NULL,
    identification JSONB NOT NULL,
    options JSONB,
    acquisition_metadata JSONB,
    sample_package JSONB,
    error TEXT,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    completed_at TIMESTAMP,
    INDEX idx_user_id (user_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);

CREATE TABLE users (
    user_id VARCHAR(255) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
```

## Authentication

```python
# api/dependencies.py
from fastapi import Depends, HTTPException, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

security = HTTPBearer()

async def get_current_user(
    credentials: HTTPAuthorizationCredentials = Depends(security)
) -> str:
    """Validate JWT token and return user ID."""
    token = credentials.credentials
    
    # Validate token (implementation depends on auth provider)
    # This is a placeholder
    try:
        user_id = validate_jwt_token(token)
        return user_id
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication credentials"
        )
```

## Rate Limiting

```python
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from slowapi.errors import RateLimitExceeded

limiter = Limiter(key_func=get_remote_address)
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

@router.post("/samples")
@limiter.limit("10/minute")
async def create_sample(request: Request, ...):
    ...
```

## Deployment

### Dockerfile

```dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
```

### docker-compose.yml

```yaml
api:
  build: .
  ports:
    - "8000:8000"
  environment:
    - DATABASE_URL=postgresql://user:pass@postgres/samplehunt
    - CELERY_BROKER_URL=redis://redis:6379/0
    - JWT_SECRET=${JWT_SECRET}
  depends_on:
    - postgres
    - redis
```

## Testing

```python
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)

def test_create_sample():
    response = client.post(
        "/api/v1/samples",
        json={
            "identification": {
                "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
                "title": "Test Song",
                "artist": "Test Artist"
            }
        },
        headers={"Authorization": "Bearer test_token"}
    )
    assert response.status_code == 201
    assert "request_id" in response.json()
```

## References

- [SampleHunt Integration Overview](SAMPLEHUNT_INTEGRATION.md)
- [Worker Implementation](SAMPLEHUNT_WORKER.md)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)

```

## SAMPLEHUNT_DEPLOYMENT.md

```markdown
# SampleHunt Deployment Guide

## ⚠️ IMPORTANT: This is Documentation Only

**This guide contains EXAMPLES ONLY and is NOT automatically deployed.**

- ❌ No resources are created automatically
- ❌ No containers are built automatically  
- ❌ No services are deployed automatically
- ✅ You must manually create and configure everything
- ✅ All examples require customization for your environment
- ✅ Security hardening is YOUR responsibility

**See [DEPLOYMENT_README.md](DEPLOYMENT_README.md) for important warnings and guidelines.**

---

## Overview

Complete deployment guide for the SampleHunt PoC system, including infrastructure setup, configuration, and monitoring.

**Note:** This is a reference guide. You must create your own deployment configuration based on these examples.

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                     Production Environment                   │
├─────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌──────────────┐      ┌──────────────┐                     │
│  │ Load Balancer│─────▶│  API Server  │ (FastAPI)           │
│  │   (Nginx)    │      │  Port: 8000  │                     │
│  └──────────────┘      └──────┬───────┘                     │
│                                │                             │
│                                ▼                             │
│                        ┌──────────────┐                      │
│                        │  PostgreSQL  │                      │
│                        │  Port: 5432  │                      │
│                        └──────────────┘                      │
│                                                               │
│  ┌──────────────┐      ┌──────────────┐                     │
│  │    Redis     │◀─────│   Workers    │ (Celery)            │
│  │  Port: 6379  │      │  (2-4 nodes) │                     │
│  └──────────────┘      └──────┬───────┘                     │
│                                │                             │
│                                ▼                             │
│                        ┌──────────────┐                      │
│                        │  S3/MinIO    │                      │
│                        │  Port: 9000  │                      │
│                        └──────────────┘                      │
│                                                               │
│  ┌──────────────┐                                            │
│  │   Flower     │ (Monitoring)                               │
│  │  Port: 5555  │                                            │
│  └──────────────┘                                            │
│                                                               │
└─────────────────────────────────────────────────────────────┘
```

## Prerequisites

### System Requirements

**API Server:**
- CPU: 2 cores minimum
- RAM: 4GB minimum
- Disk: 20GB SSD

**Worker Nodes:**
- CPU: 4 cores minimum (audio processing is CPU-intensive)
- RAM: 8GB minimum
- Disk: 100GB SSD (for temporary audio files)

**Database:**
- CPU: 2 cores
- RAM: 4GB
- Disk: 50GB SSD

**Storage:**
- S3-compatible storage (AWS S3, MinIO, etc.)
- Minimum 500GB capacity

### Software Requirements

- Docker 24.0+
- Docker Compose 2.20+
- Git
- (Optional) Kubernetes 1.27+ for production

## Quick Start (Docker Compose)

### 1. Clone and Setup

```bash
# Clone repository
git clone https://github.com/your-org/samplehunt.git
cd samplehunt

# Copy environment template
cp .env.example .env

# Edit configuration
nano .env
```

### 2. Environment Configuration

**.env file:**
```bash
# Application
APP_ENV=production
APP_VERSION=1.0.0
SECRET_KEY=your-secret-key-here

# Database
POSTGRES_USER=samplehunt
POSTGRES_PASSWORD=your-secure-password
POSTGRES_DB=samplehunt
DATABASE_URL=postgresql://samplehunt:your-secure-password@postgres:5432/samplehunt

# Redis
REDIS_URL=redis://redis:6379/0

# Celery
CELERY_BROKER_URL=redis://redis:6379/0
CELERY_RESULT_BACKEND=redis://redis:6379/1

# Storage (MinIO)
MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=your-minio-password
S3_ENDPOINT_URL=http://minio:9000
S3_BUCKET=samplehunt-assets
S3_ACCESS_KEY=minioadmin
S3_SECRET_KEY=your-minio-password
S3_REGION=us-east-1

# External APIs
FADR_API_KEY=your-fadr-api-key
GAUDIO_API_KEY=your-gaudio-api-key
SPOTIFY_CLIENT_ID=your-spotify-client-id
SPOTIFY_CLIENT_SECRET=your-spotify-client-secret
ACRCLOUD_ACCESS_KEY=your-acrcloud-key
ACRCLOUD_ACCESS_SECRET=your-acrcloud-secret

# LLM
LLM_API_KEY=your-llm-api-key
LLM_MODEL=grok-4.1-fast

# JWT
JWT_SECRET=your-jwt-secret
JWT_ALGORITHM=HS256
JWT_EXPIRATION=86400

# CORS
CORS_ORIGINS=https://app.samplehunt.com,https://samplehunt.com

# Monitoring
SENTRY_DSN=your-sentry-dsn
```

### 3. Build SpotiFLAC CLI

```bash
# Build CLI binary
cd spotiflac-cli
make build

# Copy to worker directory
cp spotiflac-cli ../samplehunt-worker/bin/

# Verify
./spotiflac-cli -version
```

### 4. Initialize Database

```bash
# Start database
docker-compose up -d postgres

# Wait for database to be ready
sleep 10

# Run migrations
docker-compose run --rm api alembic upgrade head
```

### 5. Start Services

```bash
# Start all services
docker-compose up -d

# Verify services are running
docker-compose ps

# View logs
docker-compose logs -f
```

### 6. Verify Deployment

```bash
# Check API health
curl http://localhost:8000/health

# Check Flower (worker monitoring)
open http://localhost:5555

# Check MinIO console
open http://localhost:9001
```

## Production Deployment

### Docker Compose (Production)

**docker-compose.prod.yml:**
```yaml
version: '3.8'

services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
      - ./ssl:/etc/nginx/ssl:ro
    depends_on:
      - api
    restart: unless-stopped

  api:
    build:
      context: ./samplehunt-api
      dockerfile: Dockerfile.prod
    command: gunicorn main:app --workers 4 --worker-class uvicorn.workers.UvicornWorker --bind 0.0.0.0:8000
    environment:
      - APP_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - CELERY_BROKER_URL=${CELERY_BROKER_URL}
      - JWT_SECRET=${JWT_SECRET}
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    deploy:
      replicas: 2
      resources:
        limits:
          cpus: '2'
          memory: 4G

  worker:
    build:
      context: ./samplehunt-worker
      dockerfile: Dockerfile.prod
    command: celery -A worker.tasks worker --loglevel=info --concurrency=2 --max-tasks-per-child=50
    environment:
      - APP_ENV=production
      - DATABASE_URL=${DATABASE_URL}
      - CELERY_BROKER_URL=${CELERY_BROKER_URL}
      - S3_ENDPOINT_URL=${S3_ENDPOINT_URL}
      - S3_BUCKET=${S3_BUCKET}
      - S3_ACCESS_KEY=${S3_ACCESS_KEY}
      - S3_SECRET_KEY=${S3_SECRET_KEY}
      - FADR_API_KEY=${FADR_API_KEY}
      - GAUDIO_API_KEY=${GAUDIO_API_KEY}
      - SPOTIFY_CLIENT_ID=${SPOTIFY_CLIENT_ID}
      - SPOTIFY_CLIENT_SECRET=${SPOTIFY_CLIENT_SECRET}
    depends_on:
      - redis
      - postgres
      - minio
    restart: unless-stopped
    deploy:
      replicas: 4
      resources:
        limits:
          cpus: '4'
          memory: 8G
    volumes:
      - /tmp:/tmp

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/backups
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 4G

  redis:
    image: redis:7-alpine
    command: redis-server --appendonly yes --maxmemory 2gb --maxmemory-policy allkeys-lru
    volumes:
      - redis_data:/data
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '1'
          memory: 2G

  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    environment:
      - MINIO_ROOT_USER=${MINIO_ROOT_USER}
      - MINIO_ROOT_PASSWORD=${MINIO_ROOT_PASSWORD}
    volumes:
      - minio_data:/data
    restart: unless-stopped
    deploy:
      resources:
        limits:
          cpus: '2'
          memory: 4G

  flower:
    build: ./samplehunt-worker
    command: celery -A worker.tasks flower --port=5555 --basic_auth=admin:${FLOWER_PASSWORD}
    environment:
      - CELERY_BROKER_URL=${CELERY_BROKER_URL}
    ports:
      - "5555:5555"
    depends_on:
      - redis
    restart: unless-stopped

  prometheus:
    image: prom/prometheus:latest
    volumes:
      - ./prometheus.yml:/etc/prometheus/prometheus.yml
      - prometheus_data:/prometheus
    command:
      - '--config.file=/etc/prometheus/prometheus.yml'
      - '--storage.tsdb.path=/prometheus'
    ports:
      - "9090:9090"
    restart: unless-stopped

  grafana:
    image: grafana/grafana:latest
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
    volumes:
      - grafana_data:/var/lib/grafana
      - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
    ports:
      - "3000:3000"
    depends_on:
      - prometheus
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:
  minio_data:
  prometheus_data:
  grafana_data:
```

### Nginx Configuration

**nginx.conf:**
```nginx
events {
    worker_connections 1024;
}

http {
    upstream api {
        least_conn;
        server api:8000;
    }

    # Rate limiting
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=sample_limit:10m rate=1r/s;

    server {
        listen 80;
        server_name api.samplehunt.com;

        # Redirect to HTTPS
        return 301 https://$server_name$request_uri;
    }

    server {
        listen 443 ssl http2;
        server_name api.samplehunt.com;

        ssl_certificate /etc/nginx/ssl/cert.pem;
        ssl_certificate_key /etc/nginx/ssl/key.pem;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Strict-Transport-Security "max-age=31536000" always;

        # API endpoints
        location /api/ {
            limit_req zone=api_limit burst=20 nodelay;
            
            proxy_pass http://api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # Sample creation (stricter rate limit)
        location /api/v1/samples {
            limit_req zone=sample_limit burst=5 nodelay;
            
            proxy_pass http://api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # Health check
        location /health {
            proxy_pass http://api;
            access_log off;
        }
    }
}
```

### SSL Certificate Setup

```bash
# Using Let's Encrypt
certbot certonly --standalone -d api.samplehunt.com

# Copy certificates
cp /etc/letsencrypt/live/api.samplehunt.com/fullchain.pem ./ssl/cert.pem
cp /etc/letsencrypt/live/api.samplehunt.com/privkey.pem ./ssl/key.pem
```

## Kubernetes Deployment

### Namespace

```yaml
# namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: samplehunt
```

### ConfigMap

```yaml
# configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: samplehunt-config
  namespace: samplehunt
data:
  APP_ENV: "production"
  CELERY_BROKER_URL: "redis://redis:6379/0"
  CELERY_RESULT_BACKEND: "redis://redis:6379/1"
  S3_ENDPOINT_URL: "http://minio:9000"
  S3_BUCKET: "samplehunt-assets"
  S3_REGION: "us-east-1"
```

### Secrets

```yaml
# secrets.yaml
apiVersion: v1
kind: Secret
metadata:
  name: samplehunt-secrets
  namespace: samplehunt
type: Opaque
stringData:
  DATABASE_URL: "postgresql://user:pass@postgres:5432/samplehunt"
  JWT_SECRET: "your-jwt-secret"
  S3_ACCESS_KEY: "minioadmin"
  S3_SECRET_KEY: "your-minio-password"
  FADR_API_KEY: "your-fadr-key"
  GAUDIO_API_KEY: "your-gaudio-key"
  SPOTIFY_CLIENT_ID: "your-spotify-id"
  SPOTIFY_CLIENT_SECRET: "your-spotify-secret"
```

### API Deployment

```yaml
# api-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
  namespace: samplehunt
spec:
  replicas: 3
  selector:
    matchLabels:
      app: api
  template:
    metadata:
      labels:
        app: api
    spec:
      containers:
      - name: api
        image: samplehunt/api:latest
        ports:
        - containerPort: 8000
        envFrom:
        - configMapRef:
            name: samplehunt-config
        - secretRef:
            name: samplehunt-secrets
        resources:
          requests:
            cpu: "1"
            memory: "2Gi"
          limits:
            cpu: "2"
            memory: "4Gi"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 10
          periodSeconds: 5
```

### Worker Deployment

```yaml
# worker-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: worker
  namespace: samplehunt
spec:
  replicas: 4
  selector:
    matchLabels:
      app: worker
  template:
    metadata:
      labels:
        app: worker
    spec:
      containers:
      - name: worker
        image: samplehunt/worker:latest
        command: ["celery", "-A", "worker.tasks", "worker", "--loglevel=info", "--concurrency=2"]
        envFrom:
        - configMapRef:
            name: samplehunt-config
        - secretRef:
            name: samplehunt-secrets
        resources:
          requests:
            cpu: "2"
            memory: "4Gi"
          limits:
            cpu: "4"
            memory: "8Gi"
        volumeMounts:
        - name: tmp
          mountPath: /tmp
      volumes:
      - name: tmp
        emptyDir:
          sizeLimit: 50Gi
```

## Monitoring

### Prometheus Configuration

**prometheus.yml:**
```yaml
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'api'
    static_configs:
      - targets: ['api:8000']
  
  - job_name: 'worker'
    static_configs:
      - targets: ['worker:9090']
  
  - job_name: 'postgres'
    static_configs:
      - targets: ['postgres-exporter:9187']
  
  - job_name: 'redis'
    static_configs:
      - targets: ['redis-exporter:9121']
```

### Grafana Dashboards

Import pre-built dashboards:
- Celery Dashboard (ID: 10795)
- PostgreSQL Dashboard (ID: 9628)
- Redis Dashboard (ID: 11835)

## Backup Strategy

### Database Backups

```bash
# Automated daily backups
0 2 * * * docker-compose exec -T postgres pg_dump -U samplehunt samplehunt | gzip > /backups/samplehunt-$(date +\%Y\%m\%d).sql.gz

# Retention: Keep 30 days
find /backups -name "samplehunt-*.sql.gz" -mtime +30 -delete
```

### Storage Backups

```bash
# MinIO backup to S3
mc mirror minio/samplehunt-assets s3/samplehunt-backups/$(date +\%Y\%m\%d)/
```

## Scaling

### Horizontal Scaling

```bash
# Scale workers
docker-compose up -d --scale worker=8

# Or in Kubernetes
kubectl scale deployment worker --replicas=8 -n samplehunt
```

### Vertical Scaling

Update resource limits in docker-compose.yml or Kubernetes manifests.

## Troubleshooting

### Worker Issues

```bash
# Check worker logs
docker-compose logs -f worker

# Inspect active tasks
docker-compose exec worker celery -A worker.tasks inspect active

# Purge queue
docker-compose exec worker celery -A worker.tasks purge
```

### Database Issues

```bash
# Check connections
docker-compose exec postgres psql -U samplehunt -c "SELECT count(*) FROM pg_stat_activity;"

# Vacuum database
docker-compose exec postgres psql -U samplehunt -c "VACUUM ANALYZE;"
```

### Storage Issues

```bash
# Check MinIO health
mc admin info minio

# Check bucket size
mc du minio/samplehunt-assets
```

## Security Checklist

- [ ] Change all default passwords
- [ ] Enable SSL/TLS for all services
- [ ] Configure firewall rules
- [ ] Set up VPN for internal services
- [ ] Enable database encryption at rest
- [ ] Configure S3 bucket policies
- [ ] Set up API rate limiting
- [ ] Enable audit logging
- [ ] Configure CORS properly
- [ ] Use secrets management (Vault, AWS Secrets Manager)
- [ ] Enable 2FA for admin access
- [ ] Regular security updates

## Performance Tuning

### PostgreSQL

```sql
-- Increase shared buffers
ALTER SYSTEM SET shared_buffers = '2GB';

-- Increase work memory
ALTER SYSTEM SET work_mem = '64MB';

-- Enable parallel queries
ALTER SYSTEM SET max_parallel_workers_per_gather = 4;
```

### Redis

```conf
# redis.conf
maxmemory 2gb
maxmemory-policy allkeys-lru
save 900 1
save 300 10
save 60 10000
```

### Worker Concurrency

```python
# Adjust based on CPU cores
# Rule of thumb: (CPU cores * 2) + 1
celery -A worker.tasks worker --concurrency=9
```

## Cost Optimization

### AWS Deployment

- Use Spot Instances for workers (70% cost savings)
- Use S3 Intelligent-Tiering for storage
- Use RDS Reserved Instances for database
- Use ElastiCache for Redis
- Enable CloudWatch cost anomaly detection

### Resource Optimization

- Set appropriate worker concurrency
- Implement task result expiration
- Clean up old S3 objects (lifecycle policies)
- Use database connection pooling
- Implement caching for API responses

## References

- [SampleHunt Integration](SAMPLEHUNT_INTEGRATION.md)
- [Worker Implementation](SAMPLEHUNT_WORKER.md)
- [API Specification](SAMPLEHUNT_API.md)
- [Docker Documentation](https://docs.docker.com/)
- [Kubernetes Documentation](https://kubernetes.io/docs/)

```

## SAMPLEHUNT_INTEGRATION.md

```markdown
# SampleHunt PoC - SpotiFLAC CLI Integration

## ⚠️ IMPORTANT: Integration Guide Only

**This is a DESIGN DOCUMENT showing how to integrate SpotiFLAC CLI. Nothing is deployed.**

- ❌ No integration is active
- ❌ No services are running
- ❌ No infrastructure is provisioned
- ✅ This is an architecture guide
- ✅ You must build the integration yourself
- ✅ All examples require adaptation to your system

**See [DEPLOYMENT_README.md](DEPLOYMENT_README.md) for important warnings.**

---

## Overview

This document details the integration of the modified SpotiFLAC CLI into the SampleHunt Proof of Concept (PoC) system. SampleHunt is a distributed audio processing pipeline that identifies, acquires, processes, and analyzes music samples for AI music production workflows.

**Note:** This is a design and integration guide, not a deployed system.

## System Architecture

```
┌─────────────────┐
│  Mobile Client  │ (Flutter)
│  Audio Capture  │
└────────┬────────┘
         │ SampleRequest
         ▼
┌─────────────────┐
│  Backend API    │ (FastAPI/Python)
│  PostgreSQL     │
└────────┬────────┘
         │ Celery Task
         ▼
┌─────────────────┐
│  Redis Queue    │
└────────┬────────┘
         │
         ▼
┌─────────────────────────────────────────┐
│  Processing Worker (Python/Docker)      │
│  ┌───────────────────────────────────┐  │
│  │ Phase 2: Audio Acquisition        │  │
│  │ ┌───────────────────────────────┐ │  │
│  │ │  spotiflac-cli (Go Binary)    │ │  │
│  │ │  - ISRC/Spotify ID input      │ │  │
│  │ │  - JSON output                │ │  │
│  │ │  - Multi-service fallback     │ │  │
│  │ └───────────────────────────────┘ │  │
│  │                                   │  │
│  │ Phase 3: Audio Processing         │  │
│  │ - Fadr API (Stems, MIDI)          │  │
│  │ - Gaudio Studio API (Fallback)    │  │
│  │                                   │  │
│  │ Phase 4: Research & Prompts       │  │
│  │ - Spotify API                     │  │
│  │ - MusicBrainz                     │  │
│  │ - LLM (Prompt Generation)         │  │
│  └───────────────────────────────────┘  │
└─────────────────┬───────────────────────┘
                  │
                  ▼
         ┌────────────────┐
         │ Object Storage │ (S3/MinIO)
         │ - FLAC files   │
         │ - Stems (WAV)  │
         │ - MIDI files   │
         └────────────────┘
```

## Integration Points

### 1. SpotiFLAC CLI Role

The SpotiFLAC CLI serves as the **Audio Acquisition Utility** in Phase 2:

**Responsibilities:**
- Download high-quality lossless audio (FLAC)
- Support multiple streaming services (Tidal, Qobuz, Deezer)
- Provide structured JSON output for reliable parsing
- Handle ISRC and Spotify ID inputs

**Key Features Used:**
- `-isrc` flag for direct ISRC-based downloads
- `-spotify-id` flag for Spotify ID-based downloads
- `-json` flag for structured output
- `-quiet` flag for clean parsing
- `-service` flag for service selection
- `-format` flag for quality selection (HI_RES, LOSSLESS)

### 2. Data Flow

```
Mobile Client
    │
    ├─► ACRCloud/AcoustID Identification
    │   └─► Returns: ISRC, Spotify ID, Metadata
    │
    ▼
Backend API
    │
    ├─► Save to PostgreSQL (Status: QUEUED)
    ├─► Dispatch Celery Task
    │
    ▼
Processing Worker
    │
    ├─► Phase 2: Audio Acquisition
    │   │
    │   ├─► Execute spotiflac-cli
    │   │   ├─► Attempt 1: Tidal Hi-Res
    │   │   ├─► Attempt 2: Qobuz Hi-Res
    │   │   └─► Attempt 3: Deezer Lossless
    │   │
    │   ├─► Parse JSON output
    │   └─► Upload FLAC to S3
    │
    ├─► Phase 3: Audio Processing
    │   ├─► Fadr API (Stems, MIDI, Analysis)
    │   └─► Gaudio Studio API (Optional)
    │
    ├─► Phase 4: Research & Prompts
    │   ├─► Spotify API (Audio Features)
    │   ├─► MusicBrainz (Genre, Context)
    │   └─► LLM (Prompt Generation)
    │
    └─► Phase 5: Package & Notify
        ├─► Compile SamplePackage
        ├─► Update Status: READY
        └─► Send Push Notification
```

## Phase 2: Audio Acquisition Implementation

### Worker Configuration

The Processing Worker runs in a Docker container with the SpotiFLAC CLI binary included.

**Dockerfile:**
```dockerfile
FROM python:3.11-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    wget \
    ca-certificates \
    && rm -rf /var/lib/apt/lists/*

# Copy SpotiFLAC CLI binary
COPY spotiflac-cli /usr/local/bin/spotiflac-cli
RUN chmod +x /usr/local/bin/spotiflac-cli

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy worker code
COPY worker/ /app/worker/
WORKDIR /app

CMD ["celery", "-A", "worker.tasks", "worker", "--loglevel=info"]
```

### Python Worker Implementation

**File: `worker/audio_acquisition.py`**

```python
import subprocess
import json
import logging
from pathlib import Path
from typing import Optional, Dict, Tuple
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class AcquisitionResult:
    success: bool
    file_path: Optional[str] = None
    service: Optional[str] = None
    format: Optional[str] = None
    error: Optional[str] = None
    metadata: Optional[Dict] = None

class AudioAcquisitionService:
    """
    Handles high-quality audio acquisition using SpotiFLAC CLI.
    Implements fallback strategy: Tidal Hi-Res → Qobuz Hi-Res → Deezer Lossless
    """
    
    CLI_PATH = "/usr/local/bin/spotiflac-cli"
    TIMEOUT = 300  # 5 minutes
    
    # Service priority order
    SERVICES = [
        ("tidal", "HI_RES"),
        ("qobuz", "HI_RES"),
        ("deezer", "LOSSLESS"),
    ]
    
    def __init__(self, work_dir: str = "/tmp/workdir"):
        self.work_dir = Path(work_dir)
        self.work_dir.mkdir(parents=True, exist_ok=True)
    
    def acquire_by_spotify_id(self, spotify_id: str) -> AcquisitionResult:
        """
        Acquire audio using Spotify ID with service fallback.
        
        Args:
            spotify_id: Spotify track ID
            
        Returns:
            AcquisitionResult with file path or error
        """
        logger.info(f"Acquiring audio for Spotify ID: {spotify_id}")
        
        for service, audio_format in self.SERVICES:
            logger.info(f"Attempting {service} ({audio_format})...")
            
            result = self._download_track(
                spotify_id=spotify_id,
                service=service,
                audio_format=audio_format
            )
            
            if result.success:
                logger.info(f"✅ Success: {service} ({audio_format})")
                return result
            
            logger.warning(f"❌ Failed: {service} - {result.error}")
        
        return AcquisitionResult(
            success=False,
            error="All services failed"
        )
    
    def acquire_by_isrc(self, isrc: str) -> AcquisitionResult:
        """
        Acquire audio using ISRC (Qobuz only).
        
        Args:
            isrc: International Standard Recording Code
            
        Returns:
            AcquisitionResult with file path or error
        """
        logger.info(f"Acquiring audio for ISRC: {isrc}")
        
        # ISRC only works with Qobuz currently
        return self._download_track(
            isrc=isrc,
            service="qobuz",
            audio_format="HI_RES"
        )
    
    def _download_track(
        self,
        service: str,
        audio_format: str,
        spotify_id: Optional[str] = None,
        isrc: Optional[str] = None
    ) -> AcquisitionResult:
        """
        Execute spotiflac-cli and parse JSON output.
        
        Args:
            service: Service name (tidal, qobuz, deezer)
            audio_format: Audio format (HI_RES, LOSSLESS)
            spotify_id: Spotify track ID (optional)
            isrc: ISRC code (optional)
            
        Returns:
            AcquisitionResult
        """
        # Build command
        cmd = [
            self.CLI_PATH,
            "-service", service,
            "-format", audio_format,
            "-output", str(self.work_dir),
            "-json",
            "-quiet"
        ]
        
        if spotify_id:
            cmd.extend(["-spotify-id", spotify_id])
        elif isrc:
            cmd.extend(["-isrc", isrc])
        else:
            return AcquisitionResult(
                success=False,
                error="Either spotify_id or isrc required"
            )
        
        try:
            # Execute CLI
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=self.TIMEOUT
            )
            
            # Check exit code
            if result.returncode != 0:
                return AcquisitionResult(
                    success=False,
                    error=f"CLI exited with code {result.returncode}",
                    metadata={"stderr": result.stderr}
                )
            
            # Parse JSON output
            try:
                data = json.loads(result.stdout)
            except json.JSONDecodeError as e:
                logger.error(f"Failed to parse JSON: {e}")
                logger.error(f"stdout: {result.stdout}")
                return AcquisitionResult(
                    success=False,
                    error=f"Invalid JSON response: {e}"
                )
            
            # Check success
            if not data.get("success"):
                return AcquisitionResult(
                    success=False,
                    error=data.get("error", "Unknown error"),
                    metadata=data
                )
            
            # Extract file path
            file_path = data.get("file_path")
            if not file_path:
                return AcquisitionResult(
                    success=False,
                    error="No file_path in response",
                    metadata=data
                )
            
            # Verify file exists
            if not Path(file_path).exists():
                return AcquisitionResult(
                    success=False,
                    error=f"File not found: {file_path}",
                    metadata=data
                )
            
            return AcquisitionResult(
                success=True,
                file_path=file_path,
                service=service,
                format=audio_format,
                metadata=data
            )
            
        except subprocess.TimeoutExpired:
            return AcquisitionResult(
                success=False,
                error=f"Download timeout after {self.TIMEOUT}s"
            )
        except Exception as e:
            logger.exception("Unexpected error during acquisition")
            return AcquisitionResult(
                success=False,
                error=f"Unexpected error: {str(e)}"
            )
    
    def cleanup(self):
        """Clean up temporary files."""
        import shutil
        if self.work_dir.exists():
            shutil.rmtree(self.work_dir)
            logger.info(f"Cleaned up work directory: {self.work_dir}")
```

### Celery Task Implementation

**File: `worker/tasks.py`**

```python
from celery import Celery
from celery.utils.log import get_task_logger
from .audio_acquisition import AudioAcquisitionService
from .storage import S3StorageService
from .database import DatabaseService
from .processing import AudioProcessingService
from .research import ResearchService

logger = get_task_logger(__name__)

app = Celery('samplehunt')
app.config_from_object('worker.celeryconfig')

@app.task(bind=True, max_retries=3)
def process_sample(self, request_id: str, spotify_id: str, isrc: str):
    """
    Main task for processing a sample request.
    
    Args:
        request_id: Unique request identifier
        spotify_id: Spotify track ID
        isrc: ISRC code
    """
    db = DatabaseService()
    storage = S3StorageService()
    
    try:
        # Phase 2: Audio Acquisition
        logger.info(f"[{request_id}] Phase 2: Audio Acquisition")
        db.update_status(request_id, "ACQUIRING_AUDIO")
        
        acquisition = AudioAcquisitionService(work_dir=f"/tmp/{request_id}")
        
        # Try Spotify ID first (supports all services)
        if spotify_id:
            result = acquisition.acquire_by_spotify_id(spotify_id)
        # Fallback to ISRC (Qobuz only)
        elif isrc:
            result = acquisition.acquire_by_isrc(isrc)
        else:
            raise ValueError("Either spotify_id or isrc required")
        
        if not result.success:
            db.update_status(request_id, "FAILED_ACQUISITION", error=result.error)
            return
        
        logger.info(f"[{request_id}] Acquired: {result.file_path}")
        logger.info(f"[{request_id}] Service: {result.service}, Format: {result.format}")
        
        # Upload to S3
        s3_key = f"{request_id}/source.flac"
        storage.upload_file(result.file_path, s3_key)
        logger.info(f"[{request_id}] Uploaded to S3: {s3_key}")
        
        # Save acquisition metadata
        db.save_acquisition_metadata(request_id, {
            "service": result.service,
            "format": result.format,
            "s3_key": s3_key,
            "metadata": result.metadata
        })
        
        # Phase 3: Audio Processing
        logger.info(f"[{request_id}] Phase 3: Audio Processing")
        db.update_status(request_id, "PROCESSING_AUDIO")
        
        processor = AudioProcessingService()
        processing_result = processor.process_audio(
            audio_file=result.file_path,
            request_id=request_id
        )
        
        if not processing_result.success:
            db.update_status(request_id, "FAILED_PROCESSING", error=processing_result.error)
            return
        
        # Upload stems and MIDI to S3
        for stem_name, stem_path in processing_result.stems.items():
            s3_key = f"{request_id}/stems/{stem_name}.wav"
            storage.upload_file(stem_path, s3_key)
        
        for midi_name, midi_path in processing_result.midi_files.items():
            s3_key = f"{request_id}/midi/{midi_name}.mid"
            storage.upload_file(midi_path, s3_key)
        
        # Phase 4: Research & Prompt Generation
        logger.info(f"[{request_id}] Phase 4: Research & Prompts")
        db.update_status(request_id, "RESEARCHING")
        
        research = ResearchService()
        song_profile = research.build_song_profile(
            spotify_id=spotify_id,
            isrc=isrc,
            fadr_analysis=processing_result.analysis
        )
        
        prompts = research.generate_prompts(song_profile)
        
        # Phase 5: Package & Finalize
        logger.info(f"[{request_id}] Phase 5: Packaging")
        db.update_status(request_id, "PACKAGING")
        
        # Generate pre-signed URLs
        asset_urls = storage.generate_presigned_urls(request_id)
        
        # Compile final package
        sample_package = {
            "request_id": request_id,
            "status": "READY",
            "metadata": result.metadata,
            "analysis": processing_result.analysis,
            "assets": asset_urls,
            "prompts": prompts,
            "song_profile": song_profile
        }
        
        db.save_sample_package(request_id, sample_package)
        db.update_status(request_id, "READY")
        
        # Send notification
        from .notifications import send_push_notification
        send_push_notification(request_id, "Your sample is ready!")
        
        logger.info(f"[{request_id}] ✅ Complete!")
        
    except Exception as e:
        logger.exception(f"[{request_id}] Task failed")
        db.update_status(request_id, "FAILED", error=str(e))
        raise self.retry(exc=e, countdown=60)
    
    finally:
        # Cleanup
        acquisition.cleanup()
```

## Configuration

### Environment Variables

```bash
# SpotiFLAC CLI
SPOTIFLAC_CLI_PATH=/usr/local/bin/spotiflac-cli
SPOTIFLAC_TIMEOUT=300

# Storage
S3_BUCKET=samplehunt-assets
S3_REGION=us-east-1
S3_ACCESS_KEY=...
S3_SECRET_KEY=...

# Database
DATABASE_URL=postgresql://user:pass@localhost/samplehunt

# Celery
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/1

# External APIs
FADR_API_KEY=...
GAUDIO_API_KEY=...
SPOTIFY_CLIENT_ID=...
SPOTIFY_CLIENT_SECRET=...
```

### Docker Compose

```yaml
version: '3.8'

services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
  
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: samplehunt
      POSTGRES_USER: user
      POSTGRES_PASSWORD: pass
    ports:
      - "5432:5432"
  
  worker:
    build: .
    command: celery -A worker.tasks worker --loglevel=info --concurrency=2
    environment:
      - CELERY_BROKER_URL=redis://redis:6379/0
      - DATABASE_URL=postgresql://user:pass@postgres/samplehunt
      - S3_BUCKET=samplehunt-assets
    depends_on:
      - redis
      - postgres
    volumes:
      - /tmp:/tmp
```

## Error Handling

### Acquisition Failures

```python
# Fallback strategy is built-in
result = acquisition.acquire_by_spotify_id(spotify_id)

if not result.success:
    # Log detailed error
    logger.error(f"Acquisition failed: {result.error}")
    logger.error(f"Metadata: {result.metadata}")
    
    # Update database
    db.update_status(request_id, "FAILED_ACQUISITION", error=result.error)
    
    # Notify user
    send_notification(request_id, "Unable to acquire audio")
    
    return
```

### Service-Specific Errors

```python
# The CLI handles service-specific errors internally
# Worker receives clean JSON with success/error fields

if data.get("error") == "Track not found on service":
    # Service doesn't have the track - try next service
    continue

if data.get("error") == "Rate limit exceeded":
    # Retry with backoff
    raise self.retry(countdown=300)
```

## Monitoring & Logging

### Structured Logging

```python
import structlog

logger = structlog.get_logger()

logger.info(
    "audio_acquisition_started",
    request_id=request_id,
    spotify_id=spotify_id,
    service="tidal"
)

logger.info(
    "audio_acquisition_completed",
    request_id=request_id,
    service=result.service,
    format=result.format,
    file_size=Path(result.file_path).stat().st_size,
    duration_ms=duration
)
```

### Metrics

```python
from prometheus_client import Counter, Histogram

acquisition_attempts = Counter(
    'acquisition_attempts_total',
    'Total acquisition attempts',
    ['service', 'status']
)

acquisition_duration = Histogram(
    'acquisition_duration_seconds',
    'Acquisition duration',
    ['service']
)

# Usage
with acquisition_duration.labels(service='tidal').time():
    result = acquisition.acquire_by_spotify_id(spotify_id)

acquisition_attempts.labels(
    service='tidal',
    status='success' if result.success else 'failure'
).inc()
```

## Testing

See `SAMPLEHUNT_TESTING.md` for comprehensive testing guide.

## Next Steps

1. Deploy SpotiFLAC CLI binary to worker containers
2. Implement Python worker with acquisition service
3. Set up Celery task queue
4. Configure S3/MinIO storage
5. Integrate Fadr and Gaudio APIs
6. Implement research and prompt generation
7. Set up monitoring and logging
8. Test end-to-end flow

## References

- [SpotiFLAC CLI Documentation](cli/README.md)
- [Python Integration Guide](cli/PYTHON_INTEGRATION.md)
- [CLI Enhancements](CLI_ENHANCEMENTS.md)

```

## SAMPLEHUNT_TESTING.md

```markdown
# SampleHunt Testing & Monitoring Guide

## ⚠️ IMPORTANT: Testing Examples Only

**This guide contains TESTING EXAMPLES that are not automatically set up.**

- ❌ No tests are running
- ❌ No monitoring is configured
- ❌ No metrics are being collected
- ✅ These are example test cases
- ✅ You must set up your own testing infrastructure
- ✅ Monitoring must be configured separately

**See [DEPLOYMENT_README.md](DEPLOYMENT_README.md) for important warnings.**

---

## Overview

Comprehensive testing and monitoring strategy for the SampleHunt PoC system.

**Note:** These are example test cases and monitoring configurations.

## Testing Strategy

### 1. Unit Tests

#### Audio Acquisition Service

**File: `tests/test_acquisition.py`**

```python
import pytest
from pathlib import Path
from worker.audio_acquisition import AudioAcquisitionService, AcquisitionResult

@pytest.fixture
def acquisition_service(tmp_path):
    """Create acquisition service with temporary work directory."""
    return AudioAcquisitionService(work_dir=str(tmp_path))

def test_acquire_by_spotify_id_success(acquisition_service, mocker):
    """Test successful acquisition by Spotify ID."""
    # Mock subprocess.run to return success
    mock_run = mocker.patch('subprocess.run')
    mock_run.return_value = mocker.Mock(
        returncode=0,
        stdout='{"success": true, "file_path": "/tmp/test.flac", "service": "deezer"}'
    )
    
    result = acquisition_service.acquire_by_spotify_id("3n3Ppam7vgaVa1iaRUc9Lp")
    
    assert result.success
    assert result.service == "deezer"
    assert mock_run.called

def test_acquire_by_spotify_id_fallback(acquisition_service, mocker):
    """Test service fallback on failure."""
    mock_run = mocker.patch('subprocess.run')
    
    # First call (Tidal) fails
    mock_run.side_effect = [
        mocker.Mock(returncode=0, stdout='{"success": false, "error": "Not found"}'),
        # Second call (Qobuz) succeeds
        mocker.Mock(returncode=0, stdout='{"success": true, "file_path": "/tmp/test.flac", "service": "qobuz"}')
    ]
    
    result = acquisition_service.acquire_by_spotify_id("3n3Ppam7vgaVa1iaRUc9Lp")
    
    assert result.success
    assert result.service == "qobuz"
    assert mock_run.call_count == 2

def test_acquire_by_isrc_qobuz(acquisition_service, mocker):
    """Test ISRC-based acquisition (Qobuz only)."""
    mock_run = mocker.patch('subprocess.run')
    mock_run.return_value = mocker.Mock(
        returncode=0,
        stdout='{"success": true, "file_path": "/tmp/test.flac", "isrc": "USRC17607839"}'
    )
    
    result = acquisition_service.acquire_by_isrc("USRC17607839")
    
    assert result.success
    assert "-isrc" in str(mock_run.call_args)

def test_acquire_timeout(acquisition_service, mocker):
    """Test timeout handling."""
    import subprocess
    mock_run = mocker.patch('subprocess.run')
    mock_run.side_effect = subprocess.TimeoutExpired(cmd="test", timeout=300)
    
    result = acquisition_service.acquire_by_spotify_id("3n3Ppam7vgaVa1iaRUc9Lp")
    
    assert not result.success
    assert "timeout" in result.error.lower()

def test_acquire_invalid_json(acquisition_service, mocker):
    """Test invalid JSON response handling."""
    mock_run = mocker.patch('subprocess.run')
    mock_run.return_value = mocker.Mock(
        returncode=0,
        stdout='invalid json'
    )
    
    result = acquisition_service.acquire_by_spotify_id("3n3Ppam7vgaVa1iaRUc9Lp")
    
    assert not result.success
    assert "json" in result.error.lower()
```

#### Storage Service

**File: `tests/test_storage.py`**

```python
import pytest
from worker.storage import S3StorageService
from pathlib import Path

@pytest.fixture
def storage_service(mocker):
    """Create storage service with mocked S3 client."""
    mocker.patch.dict('os.environ', {
        'S3_BUCKET': 'test-bucket',
        'S3_ACCESS_KEY': 'test-key',
        'S3_SECRET_KEY': 'test-secret'
    })
    return S3StorageService()

def test_upload_file_success(storage_service, mocker, tmp_path):
    """Test successful file upload."""
    # Create test file
    test_file = tmp_path / "test.flac"
    test_file.write_bytes(b"test data")
    
    # Mock S3 client
    mock_upload = mocker.patch.object(storage_service.s3_client, 'upload_file')
    
    result = storage_service.upload_file(str(test_file), "test/test.flac")
    
    assert result
    assert mock_upload.called

def test_generate_presigned_url(storage_service, mocker):
    """Test pre-signed URL generation."""
    mock_generate = mocker.patch.object(
        storage_service.s3_client,
        'generate_presigned_url',
        return_value='https://s3.example.com/test.flac'
    )
    
    url = storage_service.generate_presigned_url("test/test.flac")
    
    assert url.startswith('https://')
    assert mock_generate.called
```

### 2. Integration Tests

**File: `tests/test_integration.py`**

```python
import pytest
import time
from worker.tasks import process_sample
from worker.database import DatabaseService

@pytest.mark.integration
def test_end_to_end_acquisition(db_service):
    """Test complete acquisition flow."""
    request_id = "test-integration-001"
    spotify_id = "3n3Ppam7vgaVa1iaRUc9Lp"
    isrc = "USRC17607839"
    
    # Create request in database
    db_service.create_sample_request(
        request_id=request_id,
        user_id="test-user",
        identification={"spotify_id": spotify_id, "isrc": isrc},
        options={},
        status="QUEUED"
    )
    
    # Dispatch task
    result = process_sample.delay(request_id, spotify_id, isrc)
    
    # Wait for completion (with timeout)
    try:
        result.get(timeout=600)
    except Exception as e:
        pytest.fail(f"Task failed: {e}")
    
    # Verify result
    request = db_service.get_request(request_id)
    assert request['status'] in ['READY', 'FAILED']
    
    if request['status'] == 'READY':
        assert request['sample_package'] is not None
        assert 'assets' in request['sample_package']

@pytest.mark.integration
def test_service_fallback(db_service):
    """Test service fallback mechanism."""
    request_id = "test-fallback-001"
    spotify_id = "invalid-id-to-trigger-fallback"
    
    result = process_sample.delay(request_id, spotify_id, None)
    
    # Should try multiple services before failing
    result.get(timeout=600)
    
    request = db_service.get_request(request_id)
    # Should have tried multiple services
    assert 'acquisition_metadata' in request
```

### 3. API Tests

**File: `tests/test_api.py`**

```python
from fastapi.testclient import TestClient
from main import app
import pytest

client = TestClient(app)

@pytest.fixture
def auth_headers():
    """Get authentication headers."""
    return {"Authorization": "Bearer test_token"}

def test_create_sample_success(auth_headers):
    """Test successful sample creation."""
    response = client.post(
        "/api/v1/samples",
        json={
            "identification": {
                "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
                "title": "Test Song",
                "artist": "Test Artist"
            }
        },
        headers=auth_headers
    )
    
    assert response.status_code == 201
    data = response.json()
    assert "request_id" in data
    assert data["status"] == "QUEUED"

def test_create_sample_missing_auth():
    """Test sample creation without authentication."""
    response = client.post(
        "/api/v1/samples",
        json={
            "identification": {
                "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
                "title": "Test Song",
                "artist": "Test Artist"
            }
        }
    )
    
    assert response.status_code == 401

def test_get_sample_status(auth_headers):
    """Test getting sample status."""
    # Create sample first
    create_response = client.post(
        "/api/v1/samples",
        json={
            "identification": {
                "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
                "title": "Test Song",
                "artist": "Test Artist"
            }
        },
        headers=auth_headers
    )
    request_id = create_response.json()["request_id"]
    
    # Get status
    response = client.get(
        f"/api/v1/samples/{request_id}",
        headers=auth_headers
    )
    
    assert response.status_code == 200
    data = response.json()
    assert data["request_id"] == request_id

def test_rate_limiting():
    """Test API rate limiting."""
    auth_headers = {"Authorization": "Bearer test_token"}
    
    # Make multiple requests quickly
    responses = []
    for _ in range(15):
        response = client.post(
            "/api/v1/samples",
            json={
                "identification": {
                    "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
                    "title": "Test Song",
                    "artist": "Test Artist"
                }
            },
            headers=auth_headers
        )
        responses.append(response.status_code)
    
    # Should have some 429 (Too Many Requests) responses
    assert 429 in responses
```

### 4. Load Tests

**File: `tests/load_test.py`**

```python
from locust import HttpUser, task, between

class SampleHuntUser(HttpUser):
    wait_time = between(1, 3)
    
    def on_start(self):
        """Login and get token."""
        self.token = "test_token"
        self.headers = {"Authorization": f"Bearer {self.token}"}
    
    @task(3)
    def create_sample(self):
        """Create a sample request."""
        self.client.post(
            "/api/v1/samples",
            json={
                "identification": {
                    "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
                    "title": "Test Song",
                    "artist": "Test Artist"
                }
            },
            headers=self.headers
        )
    
    @task(5)
    def get_sample_status(self):
        """Get sample status."""
        # Use a known request_id
        request_id = "test-request-id"
        self.client.get(
            f"/api/v1/samples/{request_id}",
            headers=self.headers
        )
    
    @task(1)
    def list_samples(self):
        """List user samples."""
        self.client.get(
            "/api/v1/samples",
            headers=self.headers
        )
```

**Run load test:**
```bash
locust -f tests/load_test.py --host=http://localhost:8000 --users=100 --spawn-rate=10
```

## Monitoring

### 1. Application Metrics

**File: `worker/metrics.py`**

```python
from prometheus_client import Counter, Histogram, Gauge, Info
import time
from functools import wraps

# Counters
acquisition_attempts = Counter(
    'samplehunt_acquisition_attempts_total',
    'Total acquisition attempts',
    ['service', 'status']
)

acquisition_errors = Counter(
    'samplehunt_acquisition_errors_total',
    'Total acquisition errors',
    ['service', 'error_type']
)

processing_tasks = Counter(
    'samplehunt_processing_tasks_total',
    'Total processing tasks',
    ['phase', 'status']
)

# Histograms
acquisition_duration = Histogram(
    'samplehunt_acquisition_duration_seconds',
    'Acquisition duration',
    ['service'],
    buckets=[10, 30, 60, 120, 300, 600]
)

processing_duration = Histogram(
    'samplehunt_processing_duration_seconds',
    'Processing duration',
    ['phase'],
    buckets=[30, 60, 120, 300, 600, 1200]
)

task_duration = Histogram(
    'samplehunt_task_duration_seconds',
    'Total task duration',
    buckets=[60, 300, 600, 1200, 1800, 3600]
)

# Gauges
active_tasks = Gauge(
    'samplehunt_active_tasks',
    'Number of active tasks',
    ['task_name']
)

queue_size = Gauge(
    'samplehunt_queue_size',
    'Number of tasks in queue',
    ['queue_name']
)

# Info
app_info = Info('samplehunt_app', 'Application information')
app_info.info({
    'version': '1.0.0',
    'environment': 'production'
})

# Decorators
def track_acquisition(service):
    """Decorator to track acquisition metrics."""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            with acquisition_duration.labels(service=service).time():
                result = func(*args, **kwargs)
                
                status = 'success' if result.success else 'failure'
                acquisition_attempts.labels(service=service, status=status).inc()
                
                if not result.success:
                    error_type = result.error.split(':')[0] if result.error else 'unknown'
                    acquisition_errors.labels(service=service, error_type=error_type).inc()
                
                return result
        return wrapper
    return decorator

def track_task(phase):
    """Decorator to track task metrics."""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            active_tasks.labels(task_name=func.__name__).inc()
            
            try:
                with processing_duration.labels(phase=phase).time():
                    result = func(*args, **kwargs)
                
                processing_tasks.labels(phase=phase, status='success').inc()
                return result
            
            except Exception as e:
                processing_tasks.labels(phase=phase, status='failure').inc()
                raise
            
            finally:
                active_tasks.labels(task_name=func.__name__).dec()
        
        return wrapper
    return decorator
```

### 2. Logging

**File: `worker/logging_config.py`**

```python
import structlog
import logging
import sys

def configure_logging():
    """Configure structured logging."""
    
    # Configure structlog
    structlog.configure(
        processors=[
            structlog.stdlib.filter_by_level,
            structlog.stdlib.add_logger_name,
            structlog.stdlib.add_log_level,
            structlog.stdlib.PositionalArgumentsFormatter(),
            structlog.processors.TimeStamper(fmt="iso"),
            structlog.processors.StackInfoRenderer(),
            structlog.processors.format_exc_info,
            structlog.processors.UnicodeDecoder(),
            structlog.processors.JSONRenderer()
        ],
        context_class=dict,
        logger_factory=structlog.stdlib.LoggerFactory(),
        cache_logger_on_first_use=True,
    )
    
    # Configure standard logging
    logging.basicConfig(
        format="%(message)s",
        stream=sys.stdout,
        level=logging.INFO,
    )

# Usage in worker
logger = structlog.get_logger()

logger.info(
    "acquisition_started",
    request_id=request_id,
    spotify_id=spotify_id,
    service="tidal"
)

logger.info(
    "acquisition_completed",
    request_id=request_id,
    service=result.service,
    format=result.format,
    file_size=file_size,
    duration_seconds=duration
)

logger.error(
    "acquisition_failed",
    request_id=request_id,
    service="tidal",
    error=str(error),
    exc_info=True
)
```

### 3. Health Checks

**File: `api/routes/health.py`**

```python
from fastapi import APIRouter, status
from api.services.database import DatabaseService
from api.services.tasks import TaskService
from api.services.storage import StorageService
import redis
import psycopg2

router = APIRouter()

@router.get("/health")
async def health_check():
    """Comprehensive health check."""
    
    health_status = {
        "status": "healthy",
        "services": {}
    }
    
    # Check database
    try:
        db = DatabaseService()
        with db.get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("SELECT 1")
        health_status["services"]["database"] = "healthy"
    except Exception as e:
        health_status["services"]["database"] = f"unhealthy: {str(e)}"
        health_status["status"] = "degraded"
    
    # Check Redis
    try:
        r = redis.from_url(os.getenv('CELERY_BROKER_URL'))
        r.ping()
        health_status["services"]["redis"] = "healthy"
    except Exception as e:
        health_status["services"]["redis"] = f"unhealthy: {str(e)}"
        health_status["status"] = "degraded"
    
    # Check workers
    try:
        tasks = TaskService()
        inspect = tasks.celery_app.control.inspect()
        stats = inspect.stats()
        if stats:
            health_status["services"]["workers"] = f"healthy ({len(stats)} workers)"
        else:
            health_status["services"]["workers"] = "unhealthy: no workers"
            health_status["status"] = "degraded"
    except Exception as e:
        health_status["services"]["workers"] = f"unhealthy: {str(e)}"
        health_status["status"] = "degraded"
    
    # Check storage
    try:
        storage = StorageService()
        storage.s3_client.head_bucket(Bucket=storage.bucket)
        health_status["services"]["storage"] = "healthy"
    except Exception as e:
        health_status["services"]["storage"] = f"unhealthy: {str(e)}"
        health_status["status"] = "degraded"
    
    status_code = status.HTTP_200_OK if health_status["status"] == "healthy" else status.HTTP_503_SERVICE_UNAVAILABLE
    
    return health_status, status_code
```

### 4. Alerting

**File: `monitoring/alerts.yml`**

```yaml
groups:
  - name: samplehunt_alerts
    interval: 30s
    rules:
      # High error rate
      - alert: HighAcquisitionErrorRate
        expr: rate(samplehunt_acquisition_errors_total[5m]) > 0.1
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High acquisition error rate"
          description: "Acquisition error rate is {{ $value }} errors/sec"
      
      # No workers available
      - alert: NoWorkersAvailable
        expr: samplehunt_active_tasks == 0
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "No workers available"
          description: "No active workers detected for 5 minutes"
      
      # High queue size
      - alert: HighQueueSize
        expr: samplehunt_queue_size > 100
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "High queue size"
          description: "Queue size is {{ $value }} tasks"
      
      # Slow acquisitions
      - alert: SlowAcquisitions
        expr: histogram_quantile(0.95, rate(samplehunt_acquisition_duration_seconds_bucket[5m])) > 300
        for: 10m
        labels:
          severity: warning
        annotations:
          summary: "Slow acquisitions"
          description: "95th percentile acquisition time is {{ $value }}s"
      
      # Database connection issues
      - alert: DatabaseConnectionFailure
        expr: up{job="postgres"} == 0
        for: 1m
        labels:
          severity: critical
        annotations:
          summary: "Database connection failure"
          description: "Cannot connect to PostgreSQL"
```

## Continuous Integration

**File: `.github/workflows/test.yml`**

```yaml
name: Test

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:7
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-mock
      
      - name: Run tests
        run: |
          pytest tests/ --cov=worker --cov-report=xml
        env:
          DATABASE_URL: postgresql://postgres:test@localhost/test
          CELERY_BROKER_URL: redis://localhost:6379/0
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.xml
```

## Performance Benchmarks

```python
# tests/benchmark.py
import pytest
import time

@pytest.mark.benchmark
def test_acquisition_performance(benchmark):
    """Benchmark acquisition performance."""
    
    def acquire():
        service = AudioAcquisitionService()
        return service.acquire_by_spotify_id("3n3Ppam7vgaVa1iaRUc9Lp")
    
    result = benchmark(acquire)
    assert result.success

@pytest.mark.benchmark
def test_json_parsing_performance(benchmark):
    """Benchmark JSON parsing performance."""
    
    json_data = '{"success": true, "file_path": "/tmp/test.flac"}'
    
    def parse():
        return json.loads(json_data)
    
    benchmark(parse)
```

## References

- [SampleHunt Integration](SAMPLEHUNT_INTEGRATION.md)
- [Worker Implementation](SAMPLEHUNT_WORKER.md)
- [API Specification](SAMPLEHUNT_API.md)
- [Deployment Guide](SAMPLEHUNT_DEPLOYMENT.md)

```

## SAMPLEHUNT_WORKER.md

```markdown
# SampleHunt Worker Implementation Guide

## ⚠️ IMPORTANT: Implementation Examples Only

**This guide contains CODE EXAMPLES that are NOT automatically deployed.**

- ❌ No Docker containers are built automatically
- ❌ No services are started automatically
- ❌ No dependencies are installed automatically
- ✅ You must create your own implementation
- ✅ All code requires testing and customization
- ✅ Security review is required before production use

**See [DEPLOYMENT_README.md](DEPLOYMENT_README.md) for important warnings.**

---

## Overview

This guide provides complete implementation details for the SampleHunt Processing Worker, which orchestrates the audio acquisition and processing pipeline.

**Note:** These are reference implementations. Adapt them to your specific requirements.

## Project Structure

```
samplehunt-worker/
├── Dockerfile
├── requirements.txt
├── docker-compose.yml
├── worker/
│   ├── __init__.py
│   ├── celeryconfig.py
│   ├── tasks.py
│   ├── audio_acquisition.py
│   ├── storage.py
│   ├── database.py
│   ├── processing.py
│   ├── research.py
│   └── notifications.py
├── tests/
│   ├── test_acquisition.py
│   ├── test_tasks.py
│   └── fixtures/
└── bin/
    └── spotiflac-cli
```

## Complete Implementation Files

### 1. Dockerfile

```dockerfile
FROM python:3.11-slim

# Install system dependencies
RUN apt-get update && apt-get install -y \
    wget \
    curl \
    ca-certificates \
    ffmpeg \
    && rm -rf /var/lib/apt/lists/*

# Create app directory
WORKDIR /app

# Copy SpotiFLAC CLI binary
COPY bin/spotiflac-cli /usr/local/bin/spotiflac-cli
RUN chmod +x /usr/local/bin/spotiflac-cli

# Verify CLI works
RUN /usr/local/bin/spotiflac-cli -version

# Install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY worker/ /app/worker/

# Create work directory
RUN mkdir -p /tmp/workdir && chmod 777 /tmp/workdir

# Run as non-root user
RUN useradd -m -u 1000 worker && chown -R worker:worker /app /tmp/workdir
USER worker

CMD ["celery", "-A", "worker.tasks", "worker", "--loglevel=info", "--concurrency=2"]
```

### 2. requirements.txt

```txt
# Core
celery[redis]==5.3.4
redis==5.0.1
psycopg2-binary==2.9.9

# Storage
boto3==1.34.10
minio==7.2.0

# HTTP
httpx==0.25.2
requests==2.31.0

# Data
pydantic==2.5.2
python-dotenv==1.0.0

# Logging
structlog==23.2.0

# Monitoring
prometheus-client==0.19.0

# Audio
pydub==0.25.1

# Testing
pytest==7.4.3
pytest-asyncio==0.21.1
pytest-mock==3.12.0
```

### 3. worker/celeryconfig.py

```python
import os
from kombu import Queue

# Broker settings
broker_url = os.getenv('CELERY_BROKER_URL', 'redis://localhost:6379/0')
result_backend = os.getenv('CELERY_RESULT_BACKEND', 'redis://localhost:6379/1')

# Task settings
task_serializer = 'json'
result_serializer = 'json'
accept_content = ['json']
timezone = 'UTC'
enable_utc = True

# Task execution
task_acks_late = True
task_reject_on_worker_lost = True
task_time_limit = 3600  # 1 hour hard limit
task_soft_time_limit = 3300  # 55 minutes soft limit

# Worker settings
worker_prefetch_multiplier = 1
worker_max_tasks_per_child = 50

# Queue configuration
task_queues = (
    Queue('default', routing_key='task.#'),
    Queue('acquisition', routing_key='acquisition.#'),
    Queue('processing', routing_key='processing.#'),
)

task_routes = {
    'worker.tasks.process_sample': {'queue': 'acquisition'},
    'worker.tasks.process_audio': {'queue': 'processing'},
}

# Retry settings
task_autoretry_for = (Exception,)
task_retry_kwargs = {'max_retries': 3}
task_retry_backoff = True
task_retry_backoff_max = 600
task_retry_jitter = True
```

### 4. worker/storage.py

```python
import os
import boto3
from pathlib import Path
from typing import Dict, Optional
from botocore.exceptions import ClientError
import logging

logger = logging.getLogger(__name__)

class S3StorageService:
    """Handles file uploads and pre-signed URL generation for S3/MinIO."""
    
    def __init__(self):
        self.bucket = os.getenv('S3_BUCKET', 'samplehunt-assets')
        self.region = os.getenv('S3_REGION', 'us-east-1')
        
        # Support both S3 and MinIO
        endpoint_url = os.getenv('S3_ENDPOINT_URL')  # For MinIO
        
        self.s3_client = boto3.client(
            's3',
            region_name=self.region,
            aws_access_key_id=os.getenv('S3_ACCESS_KEY'),
            aws_secret_access_key=os.getenv('S3_SECRET_KEY'),
            endpoint_url=endpoint_url
        )
        
        # Ensure bucket exists
        self._ensure_bucket_exists()
    
    def _ensure_bucket_exists(self):
        """Create bucket if it doesn't exist."""
        try:
            self.s3_client.head_bucket(Bucket=self.bucket)
        except ClientError:
            logger.info(f"Creating bucket: {self.bucket}")
            self.s3_client.create_bucket(Bucket=self.bucket)
    
    def upload_file(self, file_path: str, s3_key: str) -> bool:
        """
        Upload a file to S3.
        
        Args:
            file_path: Local file path
            s3_key: S3 object key (e.g., "request_id/source.flac")
            
        Returns:
            True if successful
        """
        try:
            file_size = Path(file_path).stat().st_size
            logger.info(f"Uploading {file_path} ({file_size} bytes) to s3://{self.bucket}/{s3_key}")
            
            self.s3_client.upload_file(
                file_path,
                self.bucket,
                s3_key,
                ExtraArgs={'ContentType': self._get_content_type(file_path)}
            )
            
            logger.info(f"✅ Uploaded: {s3_key}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to upload {file_path}: {e}")
            return False
    
    def generate_presigned_url(self, s3_key: str, expiration: int = 3600) -> Optional[str]:
        """
        Generate a pre-signed URL for downloading.
        
        Args:
            s3_key: S3 object key
            expiration: URL expiration in seconds (default: 1 hour)
            
        Returns:
            Pre-signed URL or None
        """
        try:
            url = self.s3_client.generate_presigned_url(
                'get_object',
                Params={'Bucket': self.bucket, 'Key': s3_key},
                ExpiresIn=expiration
            )
            return url
        except Exception as e:
            logger.error(f"Failed to generate presigned URL for {s3_key}: {e}")
            return None
    
    def generate_presigned_urls(self, request_id: str) -> Dict[str, any]:
        """
        Generate pre-signed URLs for all assets in a request.
        
        Args:
            request_id: Request identifier
            
        Returns:
            Dictionary of asset URLs
        """
        assets = {
            "source_audio": self.generate_presigned_url(f"{request_id}/source.flac"),
            "stems": {},
            "midi": {}
        }
        
        # List all objects for this request
        try:
            response = self.s3_client.list_objects_v2(
                Bucket=self.bucket,
                Prefix=f"{request_id}/"
            )
            
            for obj in response.get('Contents', []):
                key = obj['Key']
                url = self.generate_presigned_url(key)
                
                if '/stems/' in key:
                    stem_name = Path(key).stem
                    assets['stems'][stem_name] = url
                elif '/midi/' in key:
                    midi_name = Path(key).stem
                    assets['midi'][midi_name] = url
                    
        except Exception as e:
            logger.error(f"Failed to list objects for {request_id}: {e}")
        
        return assets
    
    def _get_content_type(self, file_path: str) -> str:
        """Determine content type from file extension."""
        ext = Path(file_path).suffix.lower()
        content_types = {
            '.flac': 'audio/flac',
            '.wav': 'audio/wav',
            '.mp3': 'audio/mpeg',
            '.mid': 'audio/midi',
            '.midi': 'audio/midi',
            '.json': 'application/json'
        }
        return content_types.get(ext, 'application/octet-stream')
```

### 5. worker/database.py

```python
import os
import psycopg2
from psycopg2.extras import RealDictCursor, Json
from contextlib import contextmanager
from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)

class DatabaseService:
    """Handles database operations for sample requests."""
    
    def __init__(self):
        self.database_url = os.getenv('DATABASE_URL')
    
    @contextmanager
    def get_connection(self):
        """Context manager for database connections."""
        conn = psycopg2.connect(self.database_url)
        try:
            yield conn
            conn.commit()
        except Exception:
            conn.rollback()
            raise
        finally:
            conn.close()
    
    def update_status(self, request_id: str, status: str, error: Optional[str] = None):
        """
        Update request status.
        
        Args:
            request_id: Request identifier
            status: New status (QUEUED, ACQUIRING_AUDIO, PROCESSING_AUDIO, etc.)
            error: Error message if failed
        """
        with self.get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("""
                    UPDATE sample_requests
                    SET status = %s,
                        error = %s,
                        updated_at = NOW()
                    WHERE request_id = %s
                """, (status, error, request_id))
                
        logger.info(f"[{request_id}] Status: {status}")
    
    def save_acquisition_metadata(self, request_id: str, metadata: Dict):
        """
        Save audio acquisition metadata.
        
        Args:
            request_id: Request identifier
            metadata: Acquisition metadata (service, format, s3_key, etc.)
        """
        with self.get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("""
                    UPDATE sample_requests
                    SET acquisition_metadata = %s,
                        updated_at = NOW()
                    WHERE request_id = %s
                """, (Json(metadata), request_id))
    
    def save_sample_package(self, request_id: str, package: Dict):
        """
        Save final sample package.
        
        Args:
            request_id: Request identifier
            package: Complete sample package data
        """
        with self.get_connection() as conn:
            with conn.cursor() as cur:
                cur.execute("""
                    UPDATE sample_requests
                    SET sample_package = %s,
                        updated_at = NOW()
                    WHERE request_id = %s
                """, (Json(package), request_id))
    
    def get_request(self, request_id: str) -> Optional[Dict]:
        """
        Get request details.
        
        Args:
            request_id: Request identifier
            
        Returns:
            Request data or None
        """
        with self.get_connection() as conn:
            with conn.cursor(cursor_factory=RealDictCursor) as cur:
                cur.execute("""
                    SELECT * FROM sample_requests
                    WHERE request_id = %s
                """, (request_id,))
                return cur.fetchone()
```

### 6. worker/processing.py

```python
import httpx
import os
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class ProcessingResult:
    success: bool
    stems: Dict[str, str] = None  # {stem_name: file_path}
    midi_files: Dict[str, str] = None  # {midi_name: file_path}
    analysis: Dict = None  # Key, BPM, chords, etc.
    error: Optional[str] = None

class AudioProcessingService:
    """Handles audio processing via Fadr and Gaudio APIs."""
    
    def __init__(self):
        self.fadr_api_key = os.getenv('FADR_API_KEY')
        self.gaudio_api_key = os.getenv('GAUDIO_API_KEY')
        self.client = httpx.Client(timeout=300.0)
    
    def process_audio(self, audio_file: str, request_id: str) -> ProcessingResult:
        """
        Process audio file to extract stems, MIDI, and analysis.
        
        Args:
            audio_file: Path to FLAC file
            request_id: Request identifier
            
        Returns:
            ProcessingResult with stems, MIDI, and analysis
        """
        logger.info(f"[{request_id}] Processing audio with Fadr API")
        
        try:
            # Upload to Fadr
            upload_result = self._upload_to_fadr(audio_file)
            if not upload_result:
                return ProcessingResult(success=False, error="Fadr upload failed")
            
            job_id = upload_result['job_id']
            
            # Wait for processing
            result = self._wait_for_fadr_completion(job_id)
            if not result:
                return ProcessingResult(success=False, error="Fadr processing failed")
            
            # Download stems and MIDI
            work_dir = Path(f"/tmp/{request_id}/processed")
            work_dir.mkdir(parents=True, exist_ok=True)
            
            stems = self._download_fadr_stems(result, work_dir)
            midi_files = self._download_fadr_midi(result, work_dir)
            
            return ProcessingResult(
                success=True,
                stems=stems,
                midi_files=midi_files,
                analysis=result.get('analysis', {})
            )
            
        except Exception as e:
            logger.exception(f"[{request_id}] Processing failed")
            return ProcessingResult(success=False, error=str(e))
    
    def _upload_to_fadr(self, audio_file: str) -> Optional[Dict]:
        """Upload audio file to Fadr API."""
        # Implementation depends on Fadr API specifics
        # This is a placeholder
        pass
    
    def _wait_for_fadr_completion(self, job_id: str) -> Optional[Dict]:
        """Poll Fadr API until processing completes."""
        # Implementation depends on Fadr API specifics
        # This is a placeholder
        pass
    
    def _download_fadr_stems(self, result: Dict, work_dir: Path) -> Dict[str, str]:
        """Download stem files from Fadr."""
        # Implementation depends on Fadr API specifics
        # This is a placeholder
        return {}
    
    def _download_fadr_midi(self, result: Dict, work_dir: Path) -> Dict[str, str]:
        """Download MIDI files from Fadr."""
        # Implementation depends on Fadr API specifics
        # This is a placeholder
        return {}
```

### 7. worker/research.py

```python
import os
import httpx
from typing import Dict, List
import logging

logger = logging.getLogger(__name__)

class ResearchService:
    """Handles metadata research and prompt generation."""
    
    def __init__(self):
        self.spotify_client_id = os.getenv('SPOTIFY_CLIENT_ID')
        self.spotify_client_secret = os.getenv('SPOTIFY_CLIENT_SECRET')
        self.llm_api_key = os.getenv('LLM_API_KEY')
        self.client = httpx.Client(timeout=30.0)
    
    def build_song_profile(
        self,
        spotify_id: str,
        isrc: str,
        fadr_analysis: Dict
    ) -> Dict:
        """
        Build comprehensive song profile from multiple sources.
        
        Args:
            spotify_id: Spotify track ID
            isrc: ISRC code
            fadr_analysis: Analysis from Fadr (key, BPM, chords)
            
        Returns:
            Complete song profile
        """
        profile = {
            "spotify_id": spotify_id,
            "isrc": isrc,
            "fadr_analysis": fadr_analysis
        }
        
        # Get Spotify audio features
        if spotify_id:
            spotify_features = self._get_spotify_features(spotify_id)
            profile["spotify_features"] = spotify_features
        
        # Get MusicBrainz metadata
        if isrc:
            musicbrainz_data = self._get_musicbrainz_data(isrc)
            profile["musicbrainz"] = musicbrainz_data
        
        return profile
    
    def generate_prompts(self, song_profile: Dict) -> List[Dict]:
        """
        Generate AI music prompts using LLM.
        
        Args:
            song_profile: Complete song profile
            
        Returns:
            List of categorized prompts
        """
        # Implementation depends on LLM API
        # This is a placeholder
        return []
    
    def _get_spotify_features(self, spotify_id: str) -> Dict:
        """Get audio features from Spotify API."""
        # Implementation placeholder
        return {}
    
    def _get_musicbrainz_data(self, isrc: str) -> Dict:
        """Get metadata from MusicBrainz."""
        # Implementation placeholder
        return {}
```

### 8. docker-compose.yml

```yaml
version: '3.8'

services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
  
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: samplehunt
      POSTGRES_USER: samplehunt
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init.sql:/docker-entrypoint-initdb.d/init.sql
  
  minio:
    image: minio/minio:latest
    command: server /data --console-address ":9001"
    environment:
      MINIO_ROOT_USER: ${MINIO_ROOT_USER}
      MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
    ports:
      - "9000:9000"
      - "9001:9001"
    volumes:
      - minio_data:/data
  
  worker:
    build: .
    command: celery -A worker.tasks worker --loglevel=info --concurrency=2
    environment:
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/1
      - DATABASE_URL=postgresql://samplehunt:${POSTGRES_PASSWORD}@postgres/samplehunt
      - S3_ENDPOINT_URL=http://minio:9000
      - S3_BUCKET=samplehunt-assets
      - S3_ACCESS_KEY=${MINIO_ROOT_USER}
      - S3_SECRET_KEY=${MINIO_ROOT_PASSWORD}
      - FADR_API_KEY=${FADR_API_KEY}
      - GAUDIO_API_KEY=${GAUDIO_API_KEY}
      - SPOTIFY_CLIENT_ID=${SPOTIFY_CLIENT_ID}
      - SPOTIFY_CLIENT_SECRET=${SPOTIFY_CLIENT_SECRET}
    depends_on:
      - redis
      - postgres
      - minio
    volumes:
      - /tmp:/tmp
  
  flower:
    build: .
    command: celery -A worker.tasks flower --port=5555
    environment:
      - CELERY_BROKER_URL=redis://redis:6379/0
      - CELERY_RESULT_BACKEND=redis://redis:6379/1
    ports:
      - "5555:5555"
    depends_on:
      - redis

volumes:
  redis_data:
  postgres_data:
  minio_data:
```

## Building and Running

### 1. Build SpotiFLAC CLI

```bash
cd cli
make build
cp spotiflac-cli ../samplehunt-worker/bin/
```

### 2. Build Worker Container

```bash
cd samplehunt-worker
docker-compose build
```

### 3. Start Services

```bash
docker-compose up -d
```

### 4. Monitor Workers

```bash
# View logs
docker-compose logs -f worker

# Access Flower UI
open http://localhost:5555
```

## Testing

### Unit Tests

```bash
# Run tests
docker-compose run --rm worker pytest tests/

# With coverage
docker-compose run --rm worker pytest --cov=worker tests/
```

### Integration Test

```python
# tests/test_integration.py
import pytest
from worker.tasks import process_sample

def test_end_to_end_acquisition():
    """Test complete acquisition flow."""
    request_id = "test-request-123"
    spotify_id = "3n3Ppam7vgaVa1iaRUc9Lp"
    isrc = "USRC17607839"
    
    # Dispatch task
    result = process_sample.delay(request_id, spotify_id, isrc)
    
    # Wait for completion (with timeout)
    result.get(timeout=600)
    
    # Verify result
    assert result.successful()
```

## Monitoring

### Prometheus Metrics

```python
# worker/metrics.py
from prometheus_client import Counter, Histogram, Gauge

acquisition_total = Counter(
    'samplehunt_acquisition_total',
    'Total acquisition attempts',
    ['service', 'status']
)

acquisition_duration = Histogram(
    'samplehunt_acquisition_duration_seconds',
    'Acquisition duration',
    ['service']
)

active_tasks = Gauge(
    'samplehunt_active_tasks',
    'Number of active tasks',
    ['task_name']
)
```

### Health Checks

```python
# worker/health.py
from celery import Celery

def check_worker_health():
    """Check if workers are responsive."""
    app = Celery('samplehunt')
    inspect = app.control.inspect()
    
    stats = inspect.stats()
    if not stats:
        return False, "No workers available"
    
    return True, f"{len(stats)} workers active"
```

## Troubleshooting

### CLI Not Found

```bash
# Verify CLI is in container
docker-compose run --rm worker which spotiflac-cli
docker-compose run --rm worker spotiflac-cli -version
```

### Permission Issues

```bash
# Check file permissions
docker-compose run --rm worker ls -la /usr/local/bin/spotiflac-cli

# Fix if needed
docker-compose run --rm worker chmod +x /usr/local/bin/spotiflac-cli
```

### Task Failures

```bash
# View detailed logs
docker-compose logs -f worker | grep ERROR

# Check Celery queue
docker-compose run --rm worker celery -A worker.tasks inspect active
```

## Next Steps

1. Implement Fadr API integration
2. Implement Gaudio API integration
3. Implement Spotify API integration
4. Implement MusicBrainz integration
5. Implement LLM prompt generation
6. Set up monitoring and alerting
7. Deploy to production

## References

- [SampleHunt Integration Overview](SAMPLEHUNT_INTEGRATION.md)
- [SpotiFLAC CLI Documentation](cli/README.md)
- [Python Integration Guide](cli/PYTHON_INTEGRATION.md)

```

## tidal.json

```json
[
  "vogel.qqdl.site",
  "maus.qqdl.site",
  "hund.qqdl.site",
  "eu-maus.qqdl.site",
  "eu-katze.qqdl.site",
  "katze.qqdl.site",
  "wolf.qqdl.site",
  "tidal.kinoplus.online"
]
```

## version.json

```json
{
  "version": "6.2"
}

```

## wails.json

```json
{
  "$schema": "https://wails.io/schemas/config.v2.json",
  "name": "SpotiFLAC",
  "outputfilename": "SpotiFLAC",
  "frontend:install": "pnpm install",
  "frontend:dev:install": "pnpm install",
  "frontend:build": "pnpm run build",
  "frontend:dev:watcher": "pnpm run dev",
  "frontend:dev:serverUrl": "auto",
  "author": {
    "name": "afkarxyz"
  },
  "info": {
    "productName": "SpotiFLAC",
    "productVersion": "6.4"
  },
  "wailsjsdir": "./frontend",
  "assetdir": "./frontend/dist",
  "reloaddirs": "./frontend/src"
}
```

## CLI_IMPLEMENTATION.md

```markdown
# SpotiFLAC CLI Implementation

## Overview

This document describes the standalone CLI implementation of SpotiFLAC, which isolates the core download logic from the GUI application.

## Architecture

### Original Structure
```
SpotiFLAC/
├── main.go           # Wails GUI entry point
├── app.go            # Wails bindings
├── backend/          # Core download logic
│   ├── spotify_metadata.go
│   ├── deezer.go
│   ├── tidal.go
│   ├── qobuz.go
│   ├── amazon.go
│   ├── songlink.go
│   ├── lyrics.go
│   └── ...
└── frontend/         # React GUI
```

### CLI Structure
```
SpotiFLAC/
├── cli/
│   ├── main.go           # Standalone CLI entry point
│   ├── build.sh          # Build script
│   ├── README.md         # Full documentation
│   └── QUICKSTART.md     # Quick start guide
└── backend/              # Shared core logic (unchanged)
```

## Key Changes

### 1. Removed Dependencies
- **Wails v2**: Removed GUI framework dependency
- **Frontend**: No React/JavaScript dependencies
- **Context binding**: Removed Wails runtime context

### 2. CLI Implementation (`cli/main.go`)

The CLI directly uses the backend packages:

```go
import (
    "spotiflac/backend"
    // Standard library only
)
```

#### Core Functions:
- `handleTrack()` - Single track download
- `handleAlbum()` - Album download with folder creation
- `handlePlaylist()` - Playlist download
- `handleArtist()` - Artist discography download
- `downloadTrack()` - Unified download logic
- `downloadLyrics()` - Lyrics download
- `checkAvailability()` - Service availability check

### 3. Backend Reuse

All backend packages are used without modification:
- `backend.GetFilteredSpotifyData()` - Spotify metadata
- `backend.NewDeezerDownloader()` - Deezer downloads
- `backend.NewTidalDownloader()` - Tidal downloads
- `backend.NewQobuzDownloader()` - Qobuz downloads
- `backend.NewAmazonDownloader()` - Amazon downloads
- `backend.NewSongLinkClient()` - Service URL resolution
- `backend.NewLyricsClient()` - Lyrics download
- `backend.CheckISRCExists()` - Duplicate detection
- `backend.BuildExpectedFilename()` - Filename generation

## Features

### Implemented
✅ Single track download
✅ Album download with folder structure
✅ Playlist download
✅ Artist discography download
✅ Multiple service support (Deezer, Tidal, Qobuz, Amazon)
✅ ISRC-based duplicate detection
✅ Configurable filename formats
✅ Track numbering
✅ Lyrics download
✅ Availability checking
✅ Progress reporting
✅ Error handling
✅ Batch download with delays

### Not Implemented (GUI-specific)
❌ Folder selection dialog (uses `-output` flag instead)
❌ File selection dialog
❌ Real-time progress bars (uses text output)
❌ Drag-and-drop
❌ Visual spectrum analysis
❌ Interactive UI

## Usage Comparison

### GUI Version
1. Launch application
2. Paste Spotify URL
3. Select service from dropdown
4. Click download button
5. View progress in UI

### CLI Version
```bash
./spotiflac-cli \
  -url "https://open.spotify.com/track/..." \
  -service deezer \
  -output ./music
```

## Building

### Single Platform
```bash
cd cli
go build -o spotiflac-cli main.go
```

### All Platforms
```bash
cd cli
./build.sh all
```

Produces:
- `spotiflac-cli-windows-amd64.exe`
- `spotiflac-cli-macos-amd64`
- `spotiflac-cli-macos-arm64`
- `spotiflac-cli-linux-amd64`
- `spotiflac-cli-linux-arm64`

## Binary Size Comparison

| Version | Size | Dependencies |
|---------|------|--------------|
| GUI (Wails) | ~50-100 MB | Wails, WebView, Frontend assets |
| CLI | ~15-25 MB | Go standard library only |

## Command-Line Interface

### Flags
```
-url string          Spotify URL (required)
-service string      deezer, tidal, qobuz, amazon (default: deezer)
-output string       Output directory (default: .)
-format string       LOSSLESS, HI_RES (default: LOSSLESS)
-filename string     title-artist, artist-title, title (default: title-artist)
-track-number        Include track number in filename
-tidal-api string    Tidal API URL (auto-detect if empty)
-delay float         Delay between downloads in seconds (default: 1.0)
-timeout float       Metadata fetch timeout in seconds (default: 300.0)
-check               Check availability without downloading
-lyrics              Download lyrics
-version             Show version
```

### Exit Codes
- `0` - Success
- `1` - Error (invalid arguments, download failure, etc.)

## Output Format

### Single Track
```
./output/
└── Track Name - Artist Name.flac
```

### Album
```
./output/Artist Name - Album Name/
├── 01. Track 1 - Artist.flac
├── 02. Track 2 - Artist.flac
└── ...
```

### Playlist
```
./output/Playlist Name/
├── 01. Track 1 - Artist.flac
├── 02. Track 2 - Artist.flac
└── ...
```

### Artist
```
./output/Artist Name/
├── Album 1/
│   ├── 01. Track 1.flac
│   └── ...
└── Album 2/
    ├── 01. Track 1.flac
    └── ...
```

## Error Handling

The CLI provides clear error messages:

```
Error: Invalid service 'invalid'. Must be one of: deezer, tidal, qobuz, amazon
Error: Failed to fetch metadata: invalid Spotify URL
Error: Failed to create output directory: permission denied
```

Download errors are reported per-track:
```
[1/10] Track Name - Artist
  ❌ Download failed: track not found on service
[2/10] Track Name 2 - Artist
  ✅ Downloaded: Track Name 2 - Artist.flac
```

## Integration Examples

### Shell Script
```bash
#!/bin/bash
for url in $(cat spotify_urls.txt); do
    ./spotiflac-cli -url "$url" -output ./music -delay 2.0
done
```

### Python Wrapper
```python
import subprocess

def download_spotify(url, service='deezer', output='./music'):
    result = subprocess.run([
        './spotiflac-cli',
        '-url', url,
        '-service', service,
        '-output', output
    ], capture_output=True, text=True)
    return result.returncode == 0
```

### Cron Job
```bash
# Download playlist daily at 2 AM
0 2 * * * /path/to/spotiflac-cli -url "https://open.spotify.com/playlist/..." -output ~/Music
```

## Testing

### Manual Testing
```bash
# Test single track
./spotiflac-cli -url "https://open.spotify.com/track/3n3Ppam7vgaVa1iaRUc9Lp" -check

# Test album
./spotiflac-cli -url "https://open.spotify.com/album/4aawyAB9vmqN3uQ7FjRGTy" -check

# Test playlist
./spotiflac-cli -url "https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M" -check
```

### Automated Testing
```bash
# Test all services
for service in deezer tidal qobuz amazon; do
    echo "Testing $service..."
    ./spotiflac-cli -url "..." -service $service -check
done
```

## Deployment

### Standalone Binary
The CLI is a single binary with no external dependencies:
```bash
# Copy to server
scp spotiflac-cli user@server:/usr/local/bin/

# Run remotely
ssh user@server 'spotiflac-cli -url "..." -output /data/music'
```

### Docker
```dockerfile
FROM golang:1.25-alpine AS builder
WORKDIR /app
COPY . .
RUN cd cli && go build -o spotiflac-cli main.go

FROM alpine:latest
COPY --from=builder /app/cli/spotiflac-cli /usr/local/bin/
ENTRYPOINT ["spotiflac-cli"]
```

## Advantages of CLI

1. **No GUI dependencies** - Smaller binary, easier deployment
2. **Scriptable** - Easy automation and integration
3. **Headless operation** - Works on servers without display
4. **Cross-platform** - Single codebase for all platforms
5. **Resource efficient** - Lower memory and CPU usage
6. **CI/CD friendly** - Easy to integrate into pipelines

## Limitations

1. **No visual feedback** - Text-only progress
2. **No interactive selection** - All options via flags
3. **No file browser** - Must specify paths manually
4. **No real-time editing** - Cannot change options mid-download

## Future Enhancements

Potential improvements:
- [ ] Configuration file support (`.spotiflac.yaml`)
- [ ] Interactive mode with prompts
- [ ] Progress bar library (e.g., progressbar)
- [ ] Colored output (e.g., fatih/color)
- [ ] JSON output mode for scripting
- [ ] Resume interrupted downloads
- [ ] Parallel downloads
- [ ] Watch mode for playlist updates

## Maintenance

The CLI shares the backend with the GUI version, so:
- Backend bug fixes benefit both versions
- New service support automatically available in CLI
- API changes only need updating in backend
- Testing backend tests both versions

## Conclusion

The CLI implementation successfully isolates the core download logic from the GUI, providing a lightweight, scriptable alternative while maintaining full feature parity for download functionality.

```

## CLI_ENHANCEMENTS.md

```markdown
# CLI Enhancements - JSON Output & ISRC Support

## Summary

Enhanced the SpotiFLAC CLI with two major features for better integration with other applications:

1. **JSON Output Mode** - Structured output for easy parsing
2. **ISRC Direct Input** - Download tracks directly by ISRC code
3. **Spotify ID Input** - Simplified input without full URL

## New Features

### 1. JSON Output Mode (`-json`)

Outputs structured JSON instead of human-readable text, perfect for scripting and automation.

#### Usage
```bash
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -service deezer -json -quiet
```

#### Output Format
```json
{
  "success": true,
  "track_name": "Track Name",
  "artist_name": "Artist Name",
  "album_name": "Album Name",
  "isrc": "USRC17607839",
  "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
  "file_path": "/path/to/Track Name - Artist Name.flac",
  "already_exists": false,
  "lyrics_path": "/path/to/Track Name - Artist Name.lrc"
}
```

#### Error Format
```json
{
  "success": false,
  "error": "Track not found on service"
}
```

### 2. ISRC Direct Input (`-isrc`)

Download tracks directly by ISRC code without needing Spotify metadata.

#### Usage
```bash
./spotiflac-cli -isrc USRC17607839 -service qobuz -output ./music
```

#### Limitations
- **Currently only works with Qobuz** (ISRC-based search)
- Deezer, Tidal, and Amazon require Spotify ID for song.link API

### 3. Spotify ID Input (`-spotify-id`)

Simplified input using just the Spotify track ID instead of full URL.

#### Usage
```bash
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -service deezer
```

Equivalent to:
```bash
./spotiflac-cli -url "https://open.spotify.com/track/3n3Ppam7vgaVa1iaRUc9Lp" -service deezer
```

### 4. Quiet Mode (`-quiet`)

Suppresses non-essential output, useful with `-json` for clean parsing.

#### Usage
```bash
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -json -quiet
```

## Python Integration

### Basic Example
```python
import subprocess
import json

def download_track(spotify_id, service='deezer', output_dir='.'):
    result = subprocess.run([
        './spotiflac-cli',
        '-spotify-id', spotify_id,
        '-service', service,
        '-output', output_dir,
        '-json',
        '-quiet'
    ], capture_output=True, text=True)
    
    if result.returncode == 0:
        data = json.loads(result.stdout)
        if data['success']:
            return data['file_path']
    return None

# Usage
file_path = download_track('3n3Ppam7vgaVa1iaRUc9Lp')
if file_path:
    print(f"Downloaded: {file_path}")
    # Continue with next processing step
```

### Advanced Example with Error Handling
```python
import subprocess
import json
from typing import Optional, Dict

def download_with_metadata(spotify_id: str, service='deezer') -> Optional[Dict]:
    """Download track and return full metadata."""
    try:
        result = subprocess.run([
            './spotiflac-cli',
            '-spotify-id', spotify_id,
            '-service', service,
            '-json',
            '-quiet'
        ], capture_output=True, text=True, timeout=300)
        
        if result.returncode != 0:
            return None
        
        data = json.loads(result.stdout)
        return data if data.get('success') else None
        
    except (subprocess.TimeoutExpired, json.JSONDecodeError):
        return None

# Usage
metadata = download_with_metadata('3n3Ppam7vgaVa1iaRUc9Lp')
if metadata:
    print(f"Track: {metadata['track_name']}")
    print(f"Artist: {metadata['artist_name']}")
    print(f"File: {metadata['file_path']}")
    
    # Process the downloaded file
    process_audio(metadata['file_path'])
```

## Benefits for Integration

### Before Enhancements
```python
# Had to parse human-readable output
result = subprocess.run(['./spotiflac-cli', '-url', url], capture_output=True, text=True)
# Parse: "✅ Downloaded: Track Name - Artist.flac"
# Brittle - breaks if output format changes
```

### After Enhancements
```python
# Clean JSON parsing
result = subprocess.run(['./spotiflac-cli', '-spotify-id', id, '-json', '-quiet'], 
                       capture_output=True, text=True)
data = json.loads(result.stdout)
file_path = data['file_path']  # Reliable
```

## Use Cases

### 1. PoC Integration
Your Python backend can now:
```python
# Construct Spotify URL from ID
spotify_id = "3n3Ppam7vgaVa1iaRUc9Lp"

# Download with JSON output
result = subprocess.run([
    './spotiflac-cli',
    '-spotify-id', spotify_id,
    '-service', 'deezer',
    '-json',
    '-quiet'
], capture_output=True, text=True)

# Parse structured output
data = json.loads(result.stdout)
if data['success']:
    audio_file = data['file_path']
    # Continue with next processing step
    process_audio(audio_file)
```

### 2. Batch Processing
```python
def download_batch(spotify_ids):
    results = []
    for spotify_id in spotify_ids:
        result = subprocess.run([
            './spotiflac-cli',
            '-spotify-id', spotify_id,
            '-json',
            '-quiet'
        ], capture_output=True, text=True)
        
        data = json.loads(result.stdout)
        results.append(data)
    
    return results
```

### 3. API Wrapper
```python
from flask import Flask, request, jsonify
import subprocess
import json

app = Flask(__name__)

@app.route('/download', methods=['POST'])
def download():
    spotify_id = request.json.get('spotify_id')
    service = request.json.get('service', 'deezer')
    
    result = subprocess.run([
        './spotiflac-cli',
        '-spotify-id', spotify_id,
        '-service', service,
        '-json',
        '-quiet'
    ], capture_output=True, text=True)
    
    return jsonify(json.loads(result.stdout))
```

## Command-Line Options

### New Flags
| Flag | Description | Example |
|------|-------------|---------|
| `-isrc` | ISRC code for direct download | `-isrc USRC17607839` |
| `-spotify-id` | Spotify track ID | `-spotify-id 3n3Ppam7vgaVa1iaRUc9Lp` |
| `-json` | Output in JSON format | `-json` |
| `-quiet` | Suppress non-essential output | `-quiet` |

### Input Priority
1. If `-isrc` is provided → Direct ISRC download (Qobuz only)
2. If `-spotify-id` is provided → Convert to URL and download
3. If `-url` is provided → Download from URL

## JSON Output Fields

### Success Response
```json
{
  "success": true,
  "track_name": "string",
  "artist_name": "string",
  "album_name": "string",
  "isrc": "string",
  "spotify_id": "string",
  "file_path": "string",
  "already_exists": boolean,
  "lyrics_path": "string (optional)"
}
```

### Error Response
```json
{
  "success": false,
  "error": "string"
}
```

## Exit Codes

- `0` - Success
- `1` - Error (invalid arguments, download failure, etc.)

Exit codes remain consistent with or without JSON output.

## Backward Compatibility

All existing functionality remains unchanged:
- `-url` still works as before
- Human-readable output is default
- All services still supported
- All existing flags work the same

New flags are additive and optional.

## Documentation Updates

### New Files
- **`cli/PYTHON_INTEGRATION.md`** - Comprehensive Python integration guide
  - Basic examples
  - Advanced patterns
  - Flask/Django integration
  - Async support
  - Error handling
  - Testing

### Updated Files
- **`cli/README.md`** - Added JSON output section and ISRC examples
- **`cli/QUICKSTART.md`** - Added new usage examples
- **`cli/main.go`** - Enhanced with new features

## Code Changes

### New Structures
```go
type TrackResult struct {
    Success       bool   `json:"success"`
    TrackName     string `json:"track_name,omitempty"`
    ArtistName    string `json:"artist_name,omitempty"`
    AlbumName     string `json:"album_name,omitempty"`
    ISRC          string `json:"isrc,omitempty"`
    SpotifyID     string `json:"spotify_id,omitempty"`
    FilePath      string `json:"file_path,omitempty"`
    AlreadyExists bool   `json:"already_exists,omitempty"`
    Error         string `json:"error,omitempty"`
    LyricsPath    string `json:"lyrics_path,omitempty"`
}
```

### New Functions
- `handleISRCDownload()` - Direct ISRC download handler
- `downloadTrackWithResult()` - Returns structured result
- `downloadLyricsWithResult()` - Returns lyrics path
- `outputJSON()` - JSON output helper

## Testing

### Test JSON Output
```bash
# Success case
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -json -quiet | jq .

# Error case
./spotiflac-cli -spotify-id invalid_id -json -quiet | jq .
```

### Test ISRC Download
```bash
# Qobuz (works)
./spotiflac-cli -isrc USRC17607839 -service qobuz -json -quiet

# Deezer (error - requires Spotify ID)
./spotiflac-cli -isrc USRC17607839 -service deezer -json -quiet
```

### Test Python Integration
```python
import subprocess
import json

result = subprocess.run([
    './spotiflac-cli',
    '-spotify-id', '3n3Ppam7vgaVa1iaRUc9Lp',
    '-json',
    '-quiet'
], capture_output=True, text=True)

assert result.returncode == 0
data = json.loads(result.stdout)
assert data['success'] == True
assert 'file_path' in data
print(f"✅ Downloaded: {data['file_path']}")
```

## Migration Guide

### For Existing Scripts

**Before:**
```bash
./spotiflac-cli -url "https://open.spotify.com/track/3n3Ppam7vgaVa1iaRUc9Lp"
# Parse: "✅ Downloaded: filename.flac"
```

**After (recommended):**
```bash
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -json -quiet
# Parse JSON: {"success": true, "file_path": "..."}
```

### For Python Integration

**Before:**
```python
result = subprocess.run(['./spotiflac-cli', '-url', url], capture_output=True)
# Parse stdout text
```

**After:**
```python
result = subprocess.run(['./spotiflac-cli', '-spotify-id', id, '-json', '-quiet'], 
                       capture_output=True, text=True)
data = json.loads(result.stdout)
file_path = data['file_path']
```

## Future Enhancements

Potential improvements:
- [ ] ISRC support for all services (not just Qobuz)
- [ ] Batch JSON output for albums/playlists
- [ ] Progress updates in JSON format
- [ ] Webhook support for completion notifications
- [ ] Database integration for tracking downloads

## Conclusion

These enhancements make SpotiFLAC CLI production-ready for integration with other applications. The structured JSON output eliminates brittle text parsing, and direct ISRC/Spotify ID input simplifies the API.

**Key Benefits:**
- ✅ Reliable output parsing
- ✅ Clean Python integration
- ✅ Simplified input (Spotify ID instead of URL)
- ✅ Direct ISRC support (Qobuz)
- ✅ Backward compatible
- ✅ Production-ready

The CLI is now ideal for:
- Python backend integration
- API wrappers
- Batch processing
- Automation workflows
- CI/CD pipelines

```

## cli/COMPARISON.md

```markdown
# GUI vs CLI Comparison

## Feature Comparison

| Feature | GUI (Wails) | CLI |
|---------|-------------|-----|
| **Download single track** | ✅ | ✅ |
| **Download album** | ✅ | ✅ |
| **Download playlist** | ✅ | ✅ |
| **Download artist** | ✅ | ✅ |
| **Deezer support** | ✅ | ✅ |
| **Tidal support** | ✅ | ✅ |
| **Qobuz support** | ✅ | ✅ |
| **Amazon Music support** | ✅ | ✅ |
| **ISRC duplicate detection** | ✅ | ✅ |
| **Metadata tagging** | ✅ | ✅ |
| **Album artwork** | ✅ | ✅ |
| **Track numbering** | ✅ | ✅ |
| **Lyrics download** | ✅ | ✅ |
| **Availability check** | ✅ | ✅ |
| **Custom filename format** | ✅ | ✅ |
| **Batch download** | ✅ | ✅ |
| **Progress tracking** | Visual | Text |
| **Folder selection** | Dialog | Flag |
| **Drag and drop** | ✅ | ❌ |
| **Visual spectrum** | ✅ | ❌ |
| **Interactive UI** | ✅ | ❌ |
| **Scriptable** | ❌ | ✅ |
| **Headless operation** | ❌ | ✅ |
| **CI/CD integration** | ❌ | ✅ |

## Technical Comparison

| Aspect | GUI | CLI |
|--------|-----|-----|
| **Binary size** | 50-100 MB | 15-25 MB |
| **Dependencies** | Wails, WebView, React | Go stdlib only |
| **Memory usage** | ~100-200 MB | ~20-50 MB |
| **Startup time** | 2-5 seconds | Instant |
| **Platform support** | Windows, macOS, Linux | Windows, macOS, Linux, ARM |
| **Installation** | Download installer | Single binary |
| **Updates** | Download new installer | Replace binary |

## Use Case Comparison

### GUI is Better For:
- **First-time users** - Intuitive interface
- **Visual feedback** - See progress bars and status
- **Casual use** - Point and click simplicity
- **File browsing** - Visual folder selection
- **Spectrum analysis** - Visual audio quality check
- **Desktop users** - Traditional application experience

### CLI is Better For:
- **Automation** - Script downloads
- **Server deployment** - Headless operation
- **Batch processing** - Process multiple URLs
- **CI/CD pipelines** - Integrate into workflows
- **Remote execution** - SSH into servers
- **Resource efficiency** - Lower memory/CPU
- **Power users** - Command-line preference
- **Scheduled tasks** - Cron jobs

## Usage Examples

### Download a Track

**GUI:**
1. Launch SpotiFLAC
2. Paste URL: `https://open.spotify.com/track/...`
3. Select service: Deezer
4. Click "Download"
5. Wait for completion

**CLI:**
```bash
./spotiflac-cli -url "https://open.spotify.com/track/..." -service deezer
```

### Download Album with Track Numbers

**GUI:**
1. Launch SpotiFLAC
2. Paste album URL
3. Enable "Track Number" checkbox
4. Select output folder
5. Click "Download"

**CLI:**
```bash
./spotiflac-cli -url "https://open.spotify.com/album/..." -track-number -output ./music
```

### Batch Download Multiple Playlists

**GUI:**
- Download one at a time manually
- Copy/paste each URL
- Wait for each to complete

**CLI:**
```bash
#!/bin/bash
PLAYLISTS=(
    "https://open.spotify.com/playlist/..."
    "https://open.spotify.com/playlist/..."
    "https://open.spotify.com/playlist/..."
)

for playlist in "${PLAYLISTS[@]}"; do
    ./spotiflac-cli -url "$playlist" -output ./music -delay 2.0
done
```

### Scheduled Downloads

**GUI:**
- Not possible without manual intervention

**CLI:**
```bash
# Crontab entry - download playlist daily at 2 AM
0 2 * * * /path/to/spotiflac-cli -url "https://open.spotify.com/playlist/..." -output ~/Music
```

## Performance Comparison

### Single Track Download
| Metric | GUI | CLI |
|--------|-----|-----|
| Startup | 2-5s | 0s |
| Metadata fetch | 1-2s | 1-2s |
| Download | 5-30s | 5-30s |
| Total | 8-37s | 6-32s |

### Album Download (10 tracks)
| Metric | GUI | CLI |
|--------|-----|-----|
| Startup | 2-5s | 0s |
| Metadata fetch | 2-5s | 2-5s |
| Downloads | 50-300s | 50-300s |
| Total | 54-310s | 52-305s |

### Memory Usage
| Operation | GUI | CLI |
|-----------|-----|-----|
| Idle | 100 MB | N/A |
| Downloading | 150 MB | 30 MB |
| Peak | 200 MB | 50 MB |

## Integration Examples

### GUI Integration
- Limited to manual operation
- Can be launched from other apps
- No programmatic control

### CLI Integration

**Python:**
```python
import subprocess

def download_spotify(url, service='deezer'):
    result = subprocess.run([
        './spotiflac-cli',
        '-url', url,
        '-service', service
    ], capture_output=True)
    return result.returncode == 0
```

**Node.js:**
```javascript
const { exec } = require('child_process');

function downloadSpotify(url, service = 'deezer') {
    return new Promise((resolve, reject) => {
        exec(`./spotiflac-cli -url "${url}" -service ${service}`, 
            (error, stdout, stderr) => {
                if (error) reject(error);
                else resolve(stdout);
            });
    });
}
```

**Shell Script:**
```bash
#!/bin/bash
while IFS= read -r url; do
    ./spotiflac-cli -url "$url" -output ./music
done < urls.txt
```

## Deployment Comparison

### GUI Deployment
```
1. Download installer (50-100 MB)
2. Run installer
3. Grant permissions
4. Launch application
5. Configure settings
```

### CLI Deployment
```
1. Download binary (15-25 MB)
2. chmod +x spotiflac-cli
3. Run: ./spotiflac-cli -url "..."
```

**Or with Docker:**
```dockerfile
FROM alpine:latest
COPY spotiflac-cli /usr/local/bin/
ENTRYPOINT ["spotiflac-cli"]
```

## When to Use Each

### Use GUI When:
- ✅ You prefer visual interfaces
- ✅ You download occasionally
- ✅ You want to see progress visually
- ✅ You need spectrum analysis
- ✅ You're on a desktop with display

### Use CLI When:
- ✅ You need automation
- ✅ You're on a server (headless)
- ✅ You want to script downloads
- ✅ You prefer command-line tools
- ✅ You need CI/CD integration
- ✅ You want minimal resource usage
- ✅ You need scheduled downloads

## Migration Guide

### From GUI to CLI

**GUI Settings:**
- Output folder: `~/Music/FLAC`
- Service: Tidal
- Format: Hi-Res
- Filename: Artist - Title
- Track numbers: Enabled

**CLI Equivalent:**
```bash
./spotiflac-cli \
  -url "..." \
  -output ~/Music/FLAC \
  -service tidal \
  -format HI_RES \
  -filename artist-title \
  -track-number
```

### From CLI to GUI

**CLI Command:**
```bash
./spotiflac-cli -url "..." -service deezer -output ./music -track-number
```

**GUI Steps:**
1. Launch SpotiFLAC
2. Paste URL
3. Select "Deezer" from service dropdown
4. Click folder icon, select `./music`
5. Enable "Track Number" checkbox
6. Click "Download"

## Conclusion

Both versions share the same core download logic and provide identical output quality. Choose based on your use case:

- **GUI**: Best for casual users and visual feedback
- **CLI**: Best for automation and server deployment

You can use both versions interchangeably - they produce the same output and share the same backend code.

```

## cli/Makefile

```
.PHONY: build clean install test help all

# Binary name
BINARY_NAME=spotiflac-cli

# Build directory
BUILD_DIR=build

# Version
VERSION=1.0.0

# Go parameters
GOCMD=go
GOBUILD=$(GOCMD) build
GOCLEAN=$(GOCMD) clean
GOTEST=$(GOCMD) test
GOGET=$(GOCMD) get

# Build flags
LDFLAGS=-ldflags "-s -w -X main.version=$(VERSION)"

help: ## Show this help message
	@echo 'Usage: make [target]'
	@echo ''
	@echo 'Available targets:'
	@awk 'BEGIN {FS = ":.*?## "} /^[a-zA-Z_-]+:.*?## / {printf "  %-15s %s\n", $$1, $$2}' $(MAKEFILE_LIST)

build: ## Build for current platform
	@echo "Building $(BINARY_NAME)..."
	$(GOBUILD) $(LDFLAGS) -o $(BINARY_NAME) main.go
	@echo "✅ Built: $(BINARY_NAME)"

all: clean build-linux build-darwin build-windows ## Build for all platforms
	@echo "✅ All builds complete!"

build-linux: ## Build for Linux (amd64 and arm64)
	@echo "Building for Linux..."
	@mkdir -p $(BUILD_DIR)
	GOOS=linux GOARCH=amd64 $(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-linux-amd64 main.go
	GOOS=linux GOARCH=arm64 $(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-linux-arm64 main.go
	@echo "✅ Linux builds complete"

build-darwin: ## Build for macOS (amd64 and arm64)
	@echo "Building for macOS..."
	@mkdir -p $(BUILD_DIR)
	GOOS=darwin GOARCH=amd64 $(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-macos-amd64 main.go
	GOOS=darwin GOARCH=arm64 $(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-macos-arm64 main.go
	@echo "✅ macOS builds complete"

build-windows: ## Build for Windows (amd64)
	@echo "Building for Windows..."
	@mkdir -p $(BUILD_DIR)
	GOOS=windows GOARCH=amd64 $(GOBUILD) $(LDFLAGS) -o $(BUILD_DIR)/$(BINARY_NAME)-windows-amd64.exe main.go
	@echo "✅ Windows build complete"

install: build ## Install to /usr/local/bin (requires sudo)
	@echo "Installing $(BINARY_NAME) to /usr/local/bin..."
	@sudo cp $(BINARY_NAME) /usr/local/bin/
	@echo "✅ Installed successfully"

uninstall: ## Uninstall from /usr/local/bin (requires sudo)
	@echo "Uninstalling $(BINARY_NAME)..."
	@sudo rm -f /usr/local/bin/$(BINARY_NAME)
	@echo "✅ Uninstalled successfully"

clean: ## Clean build artifacts
	@echo "Cleaning..."
	@$(GOCLEAN)
	@rm -f $(BINARY_NAME)
	@rm -rf $(BUILD_DIR)
	@echo "✅ Cleaned"

test: ## Run tests
	@echo "Running tests..."
	@$(GOTEST) -v ./...

run: build ## Build and run with example
	@echo "Running $(BINARY_NAME)..."
	@./$(BINARY_NAME) -version

deps: ## Download dependencies
	@echo "Downloading dependencies..."
	@$(GOGET) -v ./...

size: build ## Show binary size
	@echo "Binary size:"
	@ls -lh $(BINARY_NAME) | awk '{print $$5 "\t" $$9}'

compress: build ## Compress binary with UPX (if available)
	@if command -v upx >/dev/null 2>&1; then \
		echo "Compressing with UPX..."; \
		upx --best --lzma $(BINARY_NAME); \
		echo "✅ Compressed"; \
	else \
		echo "⚠️  UPX not found. Install with: apt-get install upx"; \
	fi

release: all ## Create release archives
	@echo "Creating release archives..."
	@mkdir -p $(BUILD_DIR)/release
	@cd $(BUILD_DIR) && tar -czf release/$(BINARY_NAME)-linux-amd64.tar.gz $(BINARY_NAME)-linux-amd64
	@cd $(BUILD_DIR) && tar -czf release/$(BINARY_NAME)-linux-arm64.tar.gz $(BINARY_NAME)-linux-arm64
	@cd $(BUILD_DIR) && tar -czf release/$(BINARY_NAME)-macos-amd64.tar.gz $(BINARY_NAME)-macos-amd64
	@cd $(BUILD_DIR) && tar -czf release/$(BINARY_NAME)-macos-arm64.tar.gz $(BINARY_NAME)-macos-arm64
	@cd $(BUILD_DIR) && zip -q release/$(BINARY_NAME)-windows-amd64.zip $(BINARY_NAME)-windows-amd64.exe
	@echo "✅ Release archives created in $(BUILD_DIR)/release/"

.DEFAULT_GOAL := help

```

## cli/PYTHON_INTEGRATION.md

```markdown
# Python Integration Guide

This guide shows how to integrate SpotiFLAC CLI into Python applications.

## Basic Integration

### Simple Download Function

```python
import subprocess
import json
from pathlib import Path

class SpotiFLACClient:
    def __init__(self, cli_path='./spotiflac-cli', service='deezer', output_dir='.'):
        self.cli_path = cli_path
        self.service = service
        self.output_dir = output_dir
    
    def download_by_spotify_id(self, spotify_id):
        """Download a track by Spotify ID and return the file path."""
        result = subprocess.run([
            self.cli_path,
            '-spotify-id', spotify_id,
            '-service', self.service,
            '-output', self.output_dir,
            '-json',
            '-quiet'
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            return None
        
        try:
            data = json.loads(result.stdout)
            if data.get('success'):
                return data.get('file_path')
        except json.JSONDecodeError:
            pass
        
        return None
    
    def download_by_isrc(self, isrc):
        """Download a track by ISRC (Qobuz only) and return the file path."""
        result = subprocess.run([
            self.cli_path,
            '-isrc', isrc,
            '-service', 'qobuz',  # ISRC only works with Qobuz
            '-output', self.output_dir,
            '-json',
            '-quiet'
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            return None
        
        try:
            data = json.loads(result.stdout)
            if data.get('success'):
                return data.get('file_path')
        except json.JSONDecodeError:
            pass
        
        return None
    
    def download_with_metadata(self, spotify_id):
        """Download a track and return full metadata."""
        result = subprocess.run([
            self.cli_path,
            '-spotify-id', spotify_id,
            '-service', self.service,
            '-output', self.output_dir,
            '-json',
            '-quiet'
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            return None
        
        try:
            return json.loads(result.stdout)
        except json.JSONDecodeError:
            return None

# Usage
client = SpotiFLACClient(service='deezer', output_dir='./music')

# Download by Spotify ID
file_path = client.download_by_spotify_id('3n3Ppam7vgaVa1iaRUc9Lp')
if file_path:
    print(f"Downloaded: {file_path}")

# Download by ISRC
file_path = client.download_by_isrc('USRC17607839')
if file_path:
    print(f"Downloaded: {file_path}")

# Get full metadata
metadata = client.download_with_metadata('3n3Ppam7vgaVa1iaRUc9Lp')
if metadata and metadata.get('success'):
    print(f"Track: {metadata['track_name']} - {metadata['artist_name']}")
    print(f"File: {metadata['file_path']}")
```

## Advanced Integration

### Batch Download with Progress

```python
import subprocess
import json
from typing import List, Dict, Optional
from dataclasses import dataclass

@dataclass
class DownloadResult:
    success: bool
    track_name: Optional[str] = None
    artist_name: Optional[str] = None
    file_path: Optional[str] = None
    already_exists: bool = False
    error: Optional[str] = None

class SpotiFLACBatchDownloader:
    def __init__(self, cli_path='./spotiflac-cli', service='deezer', output_dir='.'):
        self.cli_path = cli_path
        self.service = service
        self.output_dir = output_dir
    
    def download_track(self, spotify_id: str) -> DownloadResult:
        """Download a single track and return structured result."""
        result = subprocess.run([
            self.cli_path,
            '-spotify-id', spotify_id,
            '-service', self.service,
            '-output', self.output_dir,
            '-json',
            '-quiet'
        ], capture_output=True, text=True)
        
        if result.returncode != 0:
            return DownloadResult(
                success=False,
                error=f"CLI exited with code {result.returncode}"
            )
        
        try:
            data = json.loads(result.stdout)
            return DownloadResult(
                success=data.get('success', False),
                track_name=data.get('track_name'),
                artist_name=data.get('artist_name'),
                file_path=data.get('file_path'),
                already_exists=data.get('already_exists', False),
                error=data.get('error')
            )
        except json.JSONDecodeError as e:
            return DownloadResult(
                success=False,
                error=f"Failed to parse JSON: {e}"
            )
    
    def download_batch(self, spotify_ids: List[str], 
                      progress_callback=None) -> List[DownloadResult]:
        """Download multiple tracks with optional progress callback."""
        results = []
        
        for i, spotify_id in enumerate(spotify_ids):
            result = self.download_track(spotify_id)
            results.append(result)
            
            if progress_callback:
                progress_callback(i + 1, len(spotify_ids), result)
        
        return results
    
    def get_stats(self, results: List[DownloadResult]) -> Dict:
        """Get statistics from batch download results."""
        return {
            'total': len(results),
            'successful': sum(1 for r in results if r.success),
            'failed': sum(1 for r in results if not r.success),
            'already_existed': sum(1 for r in results if r.already_exists),
            'newly_downloaded': sum(1 for r in results if r.success and not r.already_exists)
        }

# Usage
def progress_callback(current, total, result):
    print(f"[{current}/{total}] ", end='')
    if result.success:
        status = "Already exists" if result.already_exists else "Downloaded"
        print(f"✅ {status}: {result.track_name}")
    else:
        print(f"❌ Failed: {result.error}")

downloader = SpotiFLACBatchDownloader(service='deezer', output_dir='./music')

spotify_ids = [
    '3n3Ppam7vgaVa1iaRUc9Lp',
    '7qiZfU4dY1lWllzX7mPBI',
    '0VjIjW4GlUZAMYd2vXMi3b'
]

results = downloader.download_batch(spotify_ids, progress_callback)
stats = downloader.get_stats(results)

print(f"\nDownload complete:")
print(f"  Total: {stats['total']}")
print(f"  Successful: {stats['successful']}")
print(f"  Failed: {stats['failed']}")
print(f"  Already existed: {stats['already_existed']}")
print(f"  Newly downloaded: {stats['newly_downloaded']}")
```

## Flask API Wrapper

```python
from flask import Flask, request, jsonify
import subprocess
import json
from pathlib import Path

app = Flask(__name__)

CLI_PATH = './spotiflac-cli'
OUTPUT_DIR = './downloads'

@app.route('/download', methods=['POST'])
def download():
    """Download a track by Spotify ID or ISRC."""
    data = request.json
    
    spotify_id = data.get('spotify_id')
    isrc = data.get('isrc')
    service = data.get('service', 'deezer')
    
    if not spotify_id and not isrc:
        return jsonify({'error': 'spotify_id or isrc required'}), 400
    
    cmd = [CLI_PATH, '-service', service, '-output', OUTPUT_DIR, '-json', '-quiet']
    
    if spotify_id:
        cmd.extend(['-spotify-id', spotify_id])
    else:
        cmd.extend(['-isrc', isrc])
    
    result = subprocess.run(cmd, capture_output=True, text=True)
    
    if result.returncode != 0:
        return jsonify({'error': 'Download failed'}), 500
    
    try:
        return jsonify(json.loads(result.stdout))
    except json.JSONDecodeError:
        return jsonify({'error': 'Invalid response from CLI'}), 500

@app.route('/health', methods=['GET'])
def health():
    """Health check endpoint."""
    return jsonify({'status': 'ok'})

if __name__ == '__main__':
    Path(OUTPUT_DIR).mkdir(exist_ok=True)
    app.run(host='0.0.0.0', port=5000)
```

## Django Integration

```python
# views.py
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
import subprocess
import json

CLI_PATH = './spotiflac-cli'
OUTPUT_DIR = './media/downloads'

@csrf_exempt
def download_track(request):
    if request.method != 'POST':
        return JsonResponse({'error': 'POST required'}, status=405)
    
    try:
        data = json.loads(request.body)
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON'}, status=400)
    
    spotify_id = data.get('spotify_id')
    service = data.get('service', 'deezer')
    
    if not spotify_id:
        return JsonResponse({'error': 'spotify_id required'}, status=400)
    
    result = subprocess.run([
        CLI_PATH,
        '-spotify-id', spotify_id,
        '-service', service,
        '-output', OUTPUT_DIR,
        '-json',
        '-quiet'
    ], capture_output=True, text=True)
    
    if result.returncode != 0:
        return JsonResponse({'error': 'Download failed'}, status=500)
    
    try:
        return JsonResponse(json.loads(result.stdout))
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid CLI response'}, status=500)
```

## Async Integration (asyncio)

```python
import asyncio
import subprocess
import json
from typing import List, Dict

async def download_track_async(spotify_id: str, service='deezer', output_dir='.') -> Dict:
    """Async download function."""
    process = await asyncio.create_subprocess_exec(
        './spotiflac-cli',
        '-spotify-id', spotify_id,
        '-service', service,
        '-output', output_dir,
        '-json',
        '-quiet',
        stdout=asyncio.subprocess.PIPE,
        stderr=asyncio.subprocess.PIPE
    )
    
    stdout, stderr = await process.communicate()
    
    if process.returncode != 0:
        return {'success': False, 'error': 'Download failed'}
    
    try:
        return json.loads(stdout.decode())
    except json.JSONDecodeError:
        return {'success': False, 'error': 'Invalid JSON response'}

async def download_batch_async(spotify_ids: List[str], service='deezer', output_dir='.') -> List[Dict]:
    """Download multiple tracks concurrently."""
    tasks = [download_track_async(sid, service, output_dir) for sid in spotify_ids]
    return await asyncio.gather(*tasks)

# Usage
async def main():
    spotify_ids = [
        '3n3Ppam7vgaVa1iaRUc9Lp',
        '7qiZfU4dY1lWllzX7mPBI',
        '0VjIjW4GlUZAMYd2vXMi3b'
    ]
    
    results = await download_batch_async(spotify_ids)
    
    for result in results:
        if result.get('success'):
            print(f"✅ {result['track_name']} - {result['file_path']}")
        else:
            print(f"❌ {result.get('error')}")

asyncio.run(main())
```

## Error Handling Best Practices

```python
import subprocess
import json
import logging
from typing import Optional, Dict

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class SpotiFLACError(Exception):
    """Base exception for SpotiFLAC errors."""
    pass

class DownloadError(SpotiFLACError):
    """Download failed."""
    pass

class CLINotFoundError(SpotiFLACError):
    """CLI binary not found."""
    pass

def download_track_safe(spotify_id: str, service='deezer', output_dir='.') -> Optional[str]:
    """Download with comprehensive error handling."""
    try:
        result = subprocess.run([
            './spotiflac-cli',
            '-spotify-id', spotify_id,
            '-service', service,
            '-output', output_dir,
            '-json',
            '-quiet'
        ], capture_output=True, text=True, timeout=300)
        
    except FileNotFoundError:
        logger.error("SpotiFLAC CLI not found")
        raise CLINotFoundError("CLI binary not found at ./spotiflac-cli")
    
    except subprocess.TimeoutExpired:
        logger.error(f"Download timeout for {spotify_id}")
        raise DownloadError(f"Download timeout after 300 seconds")
    
    if result.returncode != 0:
        logger.error(f"CLI exited with code {result.returncode}")
        logger.error(f"stderr: {result.stderr}")
        raise DownloadError(f"CLI failed with exit code {result.returncode}")
    
    try:
        data = json.loads(result.stdout)
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse JSON: {e}")
        logger.error(f"stdout: {result.stdout}")
        raise DownloadError(f"Invalid JSON response from CLI")
    
    if not data.get('success'):
        error = data.get('error', 'Unknown error')
        logger.error(f"Download failed: {error}")
        raise DownloadError(error)
    
    file_path = data.get('file_path')
    if not file_path:
        raise DownloadError("No file path in response")
    
    logger.info(f"Downloaded: {file_path}")
    return file_path

# Usage
try:
    file_path = download_track_safe('3n3Ppam7vgaVa1iaRUc9Lp')
    print(f"Success: {file_path}")
except SpotiFLACError as e:
    print(f"Error: {e}")
```

## Testing

```python
import unittest
from unittest.mock import patch, MagicMock
import json

class TestSpotiFLACIntegration(unittest.TestCase):
    
    @patch('subprocess.run')
    def test_successful_download(self, mock_run):
        # Mock successful response
        mock_run.return_value = MagicMock(
            returncode=0,
            stdout=json.dumps({
                'success': True,
                'track_name': 'Test Track',
                'file_path': '/path/to/file.flac'
            })
        )
        
        client = SpotiFLACClient()
        result = client.download_by_spotify_id('test_id')
        
        self.assertEqual(result, '/path/to/file.flac')
    
    @patch('subprocess.run')
    def test_failed_download(self, mock_run):
        # Mock failed response
        mock_run.return_value = MagicMock(
            returncode=1,
            stdout=''
        )
        
        client = SpotiFLACClient()
        result = client.download_by_spotify_id('test_id')
        
        self.assertIsNone(result)

if __name__ == '__main__':
    unittest.main()
```

## Best Practices

1. **Always use `-json` and `-quiet` flags** for programmatic access
2. **Check exit codes** - 0 for success, non-zero for failure
3. **Parse JSON safely** - handle JSONDecodeError
4. **Set timeouts** - downloads can take time
5. **Handle file paths** - use Path objects for cross-platform compatibility
6. **Log errors** - capture stderr for debugging
7. **Validate inputs** - check Spotify IDs and ISRCs before calling CLI
8. **Use async** - for batch downloads to improve performance
9. **Cache results** - avoid re-downloading existing files
10. **Test thoroughly** - mock subprocess calls in unit tests

## Troubleshooting

### CLI Not Found
```python
import shutil

cli_path = shutil.which('spotiflac-cli')
if not cli_path:
    print("CLI not found in PATH")
```

### JSON Parse Errors
```python
# Always validate JSON before parsing
if result.stdout.strip():
    try:
        data = json.loads(result.stdout)
    except json.JSONDecodeError:
        print(f"Invalid JSON: {result.stdout}")
```

### Timeout Issues
```python
# Increase timeout for large downloads
result = subprocess.run(
    [...],
    timeout=600  # 10 minutes
)
```

## Conclusion

The SpotiFLAC CLI's JSON output mode makes it easy to integrate into Python applications. The structured output and predictable exit codes enable reliable automation and error handling.

```

## cli/QUICKSTART.md

```markdown
# SpotiFLAC CLI - Quick Start Guide

## Installation

### Prerequisites
- Go 1.25.4 or later

### Build from Source

1. Clone the repository:
```bash
git clone https://github.com/afkarxyz/SpotiFLAC.git
cd SpotiFLAC
```

2. Build the CLI:
```bash
cd cli
go build -o spotiflac-cli main.go
```

3. (Optional) Move to PATH:
```bash
# Linux/macOS
sudo mv spotiflac-cli /usr/local/bin/

# Or add to your PATH
export PATH=$PATH:$(pwd)
```

## Quick Examples

### 1. Download a Single Track (by URL)
```bash
./spotiflac-cli -url "https://open.spotify.com/track/3n3Ppam7vgaVa1iaRUc9Lp"
```

### 2. Download by Spotify ID
```bash
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -service deezer
```

### 3. Download by ISRC (Qobuz only)
```bash
./spotiflac-cli -isrc USRC17607839 -service qobuz -output ./music
```

### 4. JSON Output for Scripting
```bash
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -service deezer -json -quiet
```

### 5. Download an Album
```bash
./spotiflac-cli -url "https://open.spotify.com/album/4aawyAB9vmqN3uQ7FjRGTy" -track-number
```

### 6. Download a Playlist
```bash
./spotiflac-cli -url "https://open.spotify.com/playlist/37i9dQZF1DXcBWIGoYBM5M" -output ./playlists
```

### 7. Download from Tidal (Hi-Res)
```bash
./spotiflac-cli -url "https://open.spotify.com/album/..." -service tidal -format HI_RES
```

### 8. Check Availability
```bash
./spotiflac-cli -url "https://open.spotify.com/track/..." -check
```

### 9. Download with Lyrics
```bash
./spotiflac-cli -url "https://open.spotify.com/album/..." -lyrics -track-number
```

## Common Use Cases

### Download Artist Discography
```bash
./spotiflac-cli -url "https://open.spotify.com/artist/..." -output ./artists -track-number
```

### Batch Download with Custom Delay
```bash
./spotiflac-cli -url "https://open.spotify.com/playlist/..." -delay 2.0
```

### Custom Filename Format
```bash
# Format: "Artist Name - Track Name.flac"
./spotiflac-cli -url "..." -filename artist-title

# Format: "Track Name.flac"
./spotiflac-cli -url "..." -filename title
```

### Download to Specific Directory
```bash
./spotiflac-cli -url "..." -output ~/Music/FLAC
```

## Service Comparison

| Service | Quality | Notes |
|---------|---------|-------|
| **Deezer** | 16-bit/44.1kHz | Default, most reliable |
| **Tidal** | 16-bit/44.1kHz or 24-bit/96kHz+ | Use `-format HI_RES` for best quality |
| **Qobuz** | 16-bit/44.1kHz or 24-bit/192kHz | High-quality, ISRC matching |
| **Amazon** | 16-bit/44.1kHz | Good availability |

## Tips

1. **Use `-check` first** to verify track availability before downloading
2. **Enable `-track-number`** for albums and playlists to maintain order
3. **Increase `-delay`** if you encounter rate limiting
4. **Use `-lyrics`** to download synchronized lyrics alongside tracks
5. **Try different services** if one fails - availability varies
6. **Use `-json -quiet`** for scripting and automation
7. **Use `-spotify-id`** instead of full URL for cleaner scripts
8. **Use `-isrc`** with Qobuz for direct downloads without Spotify metadata

## Troubleshooting

### Rate Limiting
If you encounter rate limiting, increase the delay:
```bash
./spotiflac-cli -url "..." -delay 3.0
```

### Timeout Issues
For large playlists or slow connections:
```bash
./spotiflac-cli -url "..." -timeout 600
```

### Service Unavailable
Try a different service:
```bash
# If Tidal fails, try Deezer
./spotiflac-cli -url "..." -service deezer
```

## Advanced Usage

### Python Integration
```python
import subprocess
import json

def download_track(spotify_id, service='deezer'):
    result = subprocess.run([
        './spotiflac-cli',
        '-spotify-id', spotify_id,
        '-service', service,
        '-json',
        '-quiet'
    ], capture_output=True, text=True)
    
    if result.returncode == 0:
        data = json.loads(result.stdout)
        if data['success']:
            return data['file_path']
    return None

# Usage
file_path = download_track('3n3Ppam7vgaVa1iaRUc9Lp')
if file_path:
    print(f"Downloaded: {file_path}")
```

See [PYTHON_INTEGRATION.md](PYTHON_INTEGRATION.md) for comprehensive Python examples.

### Automation with Shell Script
```bash
#!/bin/bash
# Download multiple playlists

PLAYLISTS=(
    "https://open.spotify.com/playlist/..."
    "https://open.spotify.com/playlist/..."
    "https://open.spotify.com/playlist/..."
)

for playlist in "${PLAYLISTS[@]}"; do
    ./spotiflac-cli -url "$playlist" -output ./music -track-number -delay 2.0
done
```

### Cron Job for Regular Downloads
```bash
# Add to crontab (crontab -e)
# Download playlist daily at 2 AM
0 2 * * * /path/to/spotiflac-cli -url "https://open.spotify.com/playlist/..." -output ~/Music
```

## Getting Help

View all options:
```bash
./spotiflac-cli -h
```

Check version:
```bash
./spotiflac-cli -version
```

## Next Steps

- Read the full [README.md](README.md) for detailed documentation
- Check the [main project](https://github.com/afkarxyz/SpotiFLAC) for GUI version
- Report issues on GitHub

```

## cli/README.md

```markdown
# SpotiFLAC CLI

A standalone command-line interface for downloading Spotify tracks in FLAC format from Tidal, Deezer, Qobuz, and Amazon Music.

## Features

- Download single tracks, albums, playlists, or entire artist discographies
- Support for multiple streaming services (Deezer, Tidal, Qobuz, Amazon Music)
- Automatic metadata tagging
- ISRC-based duplicate detection
- Configurable filename formats
- Track numbering support
- Lyrics download support
- Availability checking without downloading

## Building

### Build for current platform:
```bash
cd cli
go build -o spotiflac-cli main.go
```

### Build for all platforms:
```bash
chmod +x build.sh
./build.sh all
```

This will create binaries for:
- Windows (amd64)
- macOS (amd64, arm64)
- Linux (amd64, arm64)

## Usage

### Basic Examples

Download a single track by URL:
```bash
./spotiflac-cli -url "https://open.spotify.com/track/..." -service deezer
```

Download by ISRC (direct):
```bash
./spotiflac-cli -isrc USRC17607839 -service qobuz -output ./music
```

Download by Spotify ID:
```bash
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -service deezer
```

JSON output for scripting:
```bash
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -service deezer -json -quiet
```

Download an album with track numbers:
```bash
./spotiflac-cli -url "https://open.spotify.com/album/..." -track-number -output ./music
```

Download a playlist from Tidal in Hi-Res:
```bash
./spotiflac-cli -url "https://open.spotify.com/playlist/..." -service tidal -format HI_RES
```

Download artist discography:
```bash
./spotiflac-cli -url "https://open.spotify.com/artist/..." -service deezer -output ./artists
```

Check track availability without downloading:
```bash
./spotiflac-cli -url "https://open.spotify.com/track/..." -check
```

Download with lyrics:
```bash
./spotiflac-cli -url "https://open.spotify.com/album/..." -lyrics -track-number
```

### Command-Line Options

| Option | Description | Default |
|--------|-------------|---------|
| `-url` | Spotify URL (track, album, playlist, or artist) | Required* |
| `-isrc` | ISRC code for direct track download (Qobuz only) | - |
| `-spotify-id` | Spotify track ID for direct download | - |
| `-service` | Download service: deezer, tidal, qobuz, amazon | deezer |
| `-output` | Output directory for downloaded files | . (current directory) |
| `-format` | Audio format (Tidal/Qobuz): LOSSLESS, HI_RES | LOSSLESS |
| `-filename` | Filename format: title-artist, artist-title, title | title-artist |
| `-track-number` | Include track number in filename | false |
| `-tidal-api` | Tidal API URL (optional, auto-detect if empty) | auto |
| `-delay` | Delay between batch downloads (seconds) | 1.0 |
| `-timeout` | Timeout for metadata fetching (seconds) | 300.0 |
| `-check` | Check track availability without downloading | false |
| `-lyrics` | Download lyrics for tracks | false |
| `-json` | Output results in JSON format | false |
| `-quiet` | Suppress non-essential output | false |
| `-version` | Show version information | - |

*One of `-url`, `-isrc`, or `-spotify-id` is required

## JSON Output Mode

The CLI supports structured JSON output for easy integration with other tools and scripts.

### Single Track Download
```bash
./spotiflac-cli -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -service deezer -json -quiet
```

Output:
```json
{
  "success": true,
  "track_name": "Track Name",
  "artist_name": "Artist Name",
  "album_name": "Album Name",
  "isrc": "USRC17607839",
  "spotify_id": "3n3Ppam7vgaVa1iaRUc9Lp",
  "file_path": "/path/to/Track Name - Artist Name.flac",
  "already_exists": false
}
```

### Error Response
```json
{
  "success": false,
  "error": "Track not found on service"
}
```

### Python Integration Example
```python
import subprocess
import json

def download_track(spotify_id, service='deezer', output_dir='.'):
    result = subprocess.run([
        './spotiflac-cli',
        '-spotify-id', spotify_id,
        '-service', service,
        '-output', output_dir,
        '-json',
        '-quiet'
    ], capture_output=True, text=True)
    
    if result.returncode == 0:
        data = json.loads(result.stdout)
        if data['success']:
            return data['file_path']
    return None

# Usage
file_path = download_track('3n3Ppam7vgaVa1iaRUc9Lp')
if file_path:
    print(f"Downloaded: {file_path}")
```

## ISRC Direct Download

For workflows where you already have the ISRC code, you can download directly without Spotify metadata:

```bash
./spotiflac-cli -isrc USRC17607839 -service qobuz -output ./music
```

**Note:** ISRC direct download currently only works with Qobuz. Other services (Deezer, Tidal, Amazon) require Spotify ID or URL for the song.link API.

## Services

### Deezer
- Default service
- No account required
- FLAC quality (16-bit/44.1kHz)
- Requires Spotify ID or URL

### Tidal
- Supports LOSSLESS (16-bit/44.1kHz) and HI_RES (24-bit/96kHz+)
- Auto-detects available API endpoints
- Fallback to multiple APIs for reliability
- Requires Spotify ID or URL

### Qobuz
- Supports LOSSLESS and HI_RES formats
- ISRC-based track matching
- **Supports direct ISRC download**

### Amazon Music
- FLAC quality
- Uses song.link API for track matching
- Requires Spotify ID or URL

## Output Structure

### Single Track
```
output/
└── Track Name - Artist Name.flac
```

### Album
```
output/
└── Artist Name - Album Name/
    ├── 01. Track 1 - Artist.flac
    ├── 02. Track 2 - Artist.flac
    └── ...
```

### Playlist
```
output/
└── Playlist Name/
    ├── 01. Track 1 - Artist.flac
    ├── 02. Track 2 - Artist.flac
    └── ...
```

### Artist
```
output/
└── Artist Name/
    ├── Album 1/
    │   ├── 01. Track 1.flac
    │   └── ...
    ├── Album 2/
    │   ├── 01. Track 1.flac
    │   └── ...
    └── ...
```

## Features

### ISRC-Based Duplicate Detection
The CLI automatically checks if a track with the same ISRC already exists in the output directory, preventing duplicate downloads.

### Automatic Metadata Tagging
All downloaded FLAC files include:
- Track title
- Artist name
- Album name
- Track number
- Release date
- ISRC
- Album artwork

### Filename Formats
- `title-artist`: "Track Name - Artist Name.flac" (default)
- `artist-title`: "Artist Name - Track Name.flac"
- `title`: "Track Name.flac"

### Track Numbering
When enabled with `-track-number`:
- Albums: Uses album track number (e.g., "01. Track Name.flac")
- Playlists: Uses playlist position (e.g., "01. Track Name.flac")

## Requirements

- Go 1.25.4 or later (for building)
- Internet connection
- Sufficient disk space for downloads

## Differences from GUI Version

The CLI version:
- No GUI dependencies (Wails removed)
- Runs entirely in the terminal
- Suitable for automation and scripting
- Smaller binary size
- Cross-platform without GUI frameworks
- Can be used in headless environments

## Troubleshooting

### "Failed to fetch metadata"
- Check your internet connection
- Verify the Spotify URL is valid
- Try increasing the timeout with `-timeout 600`

### "Download failed"
- Try a different service with `-service`
- Check if the track is available on the selected service with `-check`
- Some tracks may not be available on all services

### "Tidal API not available"
- The CLI will automatically try multiple Tidal API endpoints
- If all fail, try using Deezer instead: `-service deezer`

## License

Same as the main SpotiFLAC project.

```

## cli/build.sh

```bash
#!/bin/bash

# Build script for SpotiFLAC CLI

set -e

echo "Building SpotiFLAC CLI..."

# Get the directory of this script
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

# Change to project root
cd "$PROJECT_ROOT"

# Build for current platform
echo "Building for current platform..."
cd cli
go build -o spotiflac-cli main.go
echo "✅ Built: spotiflac-cli"

# Build for multiple platforms (optional)
if [ "$1" == "all" ]; then
    echo ""
    echo "Building for all platforms..."
    
    # Windows
    echo "Building for Windows..."
    GOOS=windows GOARCH=amd64 go build -o spotiflac-cli-windows-amd64.exe main.go
    echo "✅ Built: spotiflac-cli-windows-amd64.exe"
    
    # macOS
    echo "Building for macOS..."
    GOOS=darwin GOARCH=amd64 go build -o spotiflac-cli-macos-amd64 main.go
    GOOS=darwin GOARCH=arm64 go build -o spotiflac-cli-macos-arm64 main.go
    echo "✅ Built: spotiflac-cli-macos-amd64"
    echo "✅ Built: spotiflac-cli-macos-arm64"
    
    # Linux
    echo "Building for Linux..."
    GOOS=linux GOARCH=amd64 go build -o spotiflac-cli-linux-amd64 main.go
    GOOS=linux GOARCH=arm64 go build -o spotiflac-cli-linux-arm64 main.go
    echo "✅ Built: spotiflac-cli-linux-amd64"
    echo "✅ Built: spotiflac-cli-linux-arm64"
fi

echo ""
echo "Build complete!"

```

## cli/examples.sh

```bash
#!/bin/bash

# SpotiFLAC CLI - Usage Examples
# This script demonstrates various use cases

set -e

CLI="./spotiflac-cli"

echo "SpotiFLAC CLI - Usage Examples"
echo "==============================="
echo ""

# Check if CLI exists
if [ ! -f "$CLI" ]; then
    echo "Error: spotiflac-cli not found. Please build it first:"
    echo "  go build -o spotiflac-cli main.go"
    exit 1
fi

# Example 1: Check availability
echo "Example 1: Check track availability"
echo "------------------------------------"
echo "Command: $CLI -url \"https://open.spotify.com/track/...\" -check"
echo ""
read -p "Press Enter to continue..."
echo ""

# Example 2: Download single track
echo "Example 2: Download a single track"
echo "-----------------------------------"
echo "Command: $CLI -url \"https://open.spotify.com/track/...\" -service deezer"
echo ""
read -p "Press Enter to continue..."
echo ""

# Example 3: Download album with track numbers
echo "Example 3: Download album with track numbers"
echo "---------------------------------------------"
echo "Command: $CLI -url \"https://open.spotify.com/album/...\" -track-number -output ./music"
echo ""
read -p "Press Enter to continue..."
echo ""

# Example 4: Download playlist from Tidal
echo "Example 4: Download playlist from Tidal (Hi-Res)"
echo "-------------------------------------------------"
echo "Command: $CLI -url \"https://open.spotify.com/playlist/...\" -service tidal -format HI_RES"
echo ""
read -p "Press Enter to continue..."
echo ""

# Example 5: Download with lyrics
echo "Example 5: Download album with lyrics"
echo "--------------------------------------"
echo "Command: $CLI -url \"https://open.spotify.com/album/...\" -lyrics -track-number"
echo ""
read -p "Press Enter to continue..."
echo ""

# Example 6: Download artist discography
echo "Example 6: Download artist discography"
echo "---------------------------------------"
echo "Command: $CLI -url \"https://open.spotify.com/artist/...\" -output ./artists -track-number"
echo ""
read -p "Press Enter to continue..."
echo ""

# Example 7: Custom filename format
echo "Example 7: Custom filename format"
echo "----------------------------------"
echo "Command: $CLI -url \"https://open.spotify.com/track/...\" -filename artist-title"
echo ""
read -p "Press Enter to continue..."
echo ""

# Example 8: Batch download with delay
echo "Example 8: Batch download with custom delay"
echo "--------------------------------------------"
echo "Command: $CLI -url \"https://open.spotify.com/playlist/...\" -delay 2.0"
echo ""
read -p "Press Enter to continue..."
echo ""

# Example 9: Try multiple services
echo "Example 9: Try multiple services (fallback)"
echo "--------------------------------------------"
cat << 'EOF'
#!/bin/bash
SERVICES=("deezer" "tidal" "amazon" "qobuz")
URL="https://open.spotify.com/track/..."

for service in "${SERVICES[@]}"; do
    echo "Trying $service..."
    if ./spotiflac-cli -url "$URL" -service "$service"; then
        echo "Success with $service"
        break
    fi
done
EOF
echo ""
read -p "Press Enter to continue..."
echo ""

# Example 10: Batch download from file
echo "Example 10: Batch download from URL list"
echo "-----------------------------------------"
cat << 'EOF'
#!/bin/bash
# Create a file with Spotify URLs (one per line)
# urls.txt:
#   https://open.spotify.com/track/...
#   https://open.spotify.com/album/...
#   https://open.spotify.com/playlist/...

while IFS= read -r url; do
    echo "Downloading: $url"
    ./spotiflac-cli -url "$url" -output ./music -delay 2.0
done < urls.txt
EOF
echo ""

echo "==============================="
echo "Examples completed!"
echo ""
echo "For more information, see:"
echo "  - README.md for full documentation"
echo "  - QUICKSTART.md for quick start guide"
echo "  - Run '$CLI -h' for all options"

```

## cli/main.go

```go
package main

import (
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"spotiflac/backend"
	"strings"
	"time"
)

const version = "1.0.0"

// Output structures for JSON mode
type TrackResult struct {
	Success       bool   `json:"success"`
	TrackName     string `json:"track_name,omitempty"`
	ArtistName    string `json:"artist_name,omitempty"`
	AlbumName     string `json:"album_name,omitempty"`
	ISRC          string `json:"isrc,omitempty"`
	SpotifyID     string `json:"spotify_id,omitempty"`
	FilePath      string `json:"file_path,omitempty"`
	AlreadyExists bool   `json:"already_exists,omitempty"`
	Error         string `json:"error,omitempty"`
	LyricsPath    string `json:"lyrics_path,omitempty"`
}

type BatchResult struct {
	Success      bool          `json:"success"`
	Type         string        `json:"type"` // track, album, playlist, artist
	Name         string        `json:"name,omitempty"`
	TotalTracks  int           `json:"total_tracks"`
	Downloaded   int           `json:"downloaded"`
	Skipped      int           `json:"skipped"`
	Failed       int           `json:"failed"`
	Tracks       []TrackResult `json:"tracks,omitempty"`
	Error        string        `json:"error,omitempty"`
	OutputFolder string        `json:"output_folder,omitempty"`
}

var (
	jsonOutput     bool
	batchResults   []TrackResult
	quietMode      bool
)

func main() {
	// Define flags
	var (
		spotifyURL     = flag.String("url", "", "Spotify URL (track, album, playlist, or artist)")
		isrc           = flag.String("isrc", "", "ISRC code for direct track download (alternative to -url)")
		spotifyID      = flag.String("spotify-id", "", "Spotify track ID for direct download (alternative to -url)")
		service        = flag.String("service", "deezer", "Download service: deezer, tidal, qobuz, amazon")
		outputDir      = flag.String("output", ".", "Output directory for downloaded files")
		audioFormat    = flag.String("format", "LOSSLESS", "Audio format (for Tidal/Qobuz): LOSSLESS, HI_RES")
		filenameFormat = flag.String("filename", "title-artist", "Filename format: title-artist, artist-title, title")
		trackNumber    = flag.Bool("track-number", false, "Include track number in filename")
		tidalAPI       = flag.String("tidal-api", "", "Tidal API URL (optional, auto-detect if empty)")
		batchDelay     = flag.Float64("delay", 1.0, "Delay between batch downloads (seconds)")
		timeout        = flag.Float64("timeout", 300.0, "Timeout for metadata fetching (seconds)")
		showVersion    = flag.Bool("version", false, "Show version information")
		checkOnly      = flag.Bool("check", false, "Check track availability without downloading")
		getLyrics      = flag.Bool("lyrics", false, "Download lyrics for tracks")
		jsonFlag       = flag.Bool("json", false, "Output results in JSON format")
		quiet          = flag.Bool("quiet", false, "Suppress non-essential output (useful with -json)")
	)

	flag.Usage = func() {
		fmt.Fprintf(os.Stderr, "SpotiFLAC CLI - Download Spotify tracks in FLAC format\n\n")
		fmt.Fprintf(os.Stderr, "Usage: %s [options]\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "Options:\n")
		flag.PrintDefaults()
		fmt.Fprintf(os.Stderr, "\nExamples:\n")
		fmt.Fprintf(os.Stderr, "  # Download by Spotify URL\n")
		fmt.Fprintf(os.Stderr, "  %s -url https://open.spotify.com/track/... -service deezer\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  # Download by ISRC (direct)\n")
		fmt.Fprintf(os.Stderr, "  %s -isrc USRC17607839 -service deezer -output ./music\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  # Download by Spotify ID\n")
		fmt.Fprintf(os.Stderr, "  %s -spotify-id 3n3Ppam7vgaVa1iaRUc9Lp -service deezer\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  # JSON output for scripting\n")
		fmt.Fprintf(os.Stderr, "  %s -isrc USRC17607839 -service deezer -json -quiet\n\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "  # Download album with track numbers\n")
		fmt.Fprintf(os.Stderr, "  %s -url https://open.spotify.com/album/... -track-number -output ./music\n\n", os.Args[0])
	}

	flag.Parse()

	// Set global flags
	jsonOutput = *jsonFlag
	quietMode = *quiet

	if *showVersion {
		if jsonOutput {
			fmt.Printf("{\"version\":\"%s\"}\n", version)
		} else {
			fmt.Printf("SpotiFLAC CLI v%s\n", version)
		}
		os.Exit(0)
	}

	// Validate input: need either URL, ISRC, or Spotify ID
	if *spotifyURL == "" && *isrc == "" && *spotifyID == "" {
		flag.Usage()
		os.Exit(1)
	}

	// Handle ISRC direct download mode
	if *isrc != "" {
		handleISRCDownload(*isrc, *service, *outputDir, *audioFormat, *filenameFormat, *trackNumber, *tidalAPI, *getLyrics)
		return
	}

	// Handle Spotify ID direct download mode
	if *spotifyID != "" {
		*spotifyURL = fmt.Sprintf("https://open.spotify.com/track/%s", *spotifyID)
	}

	// Validate service
	validServices := map[string]bool{
		"deezer": true,
		"tidal":  true,
		"qobuz":  true,
		"amazon": true,
	}
	if !validServices[*service] {
		fmt.Fprintf(os.Stderr, "Error: Invalid service '%s'. Must be one of: deezer, tidal, qobuz, amazon\n", *service)
		os.Exit(1)
	}

	// Create output directory if it doesn't exist
	if err := os.MkdirAll(*outputDir, 0755); err != nil {
		fmt.Fprintf(os.Stderr, "Error: Failed to create output directory: %v\n", err)
		os.Exit(1)
	}

	// Fetch metadata from Spotify
	if !quietMode {
		fmt.Printf("Fetching metadata from Spotify...\n")
	}
	ctx, cancel := context.WithTimeout(context.Background(), time.Duration(*timeout*float64(time.Second)))
	defer cancel()

	data, err := backend.GetFilteredSpotifyData(ctx, *spotifyURL, true, time.Duration(*batchDelay*float64(time.Second)))
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: Failed to fetch metadata: %v\n", err)
		os.Exit(1)
	}

	// Parse the response
	var metadata map[string]interface{}
	if err := json.Unmarshal([]byte(data), &metadata); err != nil {
		fmt.Fprintf(os.Stderr, "Error: Failed to parse metadata: %v\n", err)
		os.Exit(1)
	}

	// Determine the type of content
	contentType, ok := metadata["type"].(string)
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Unable to determine content type\n")
		os.Exit(1)
	}

	switch contentType {
	case "track":
		handleTrack(metadata, *service, *outputDir, *audioFormat, *filenameFormat, *trackNumber, *tidalAPI, *checkOnly, *getLyrics)
	case "album":
		handleAlbum(metadata, *service, *outputDir, *audioFormat, *filenameFormat, *trackNumber, *tidalAPI, *batchDelay, *checkOnly, *getLyrics)
	case "playlist":
		handlePlaylist(metadata, *service, *outputDir, *audioFormat, *filenameFormat, *trackNumber, *tidalAPI, *batchDelay, *checkOnly, *getLyrics)
	case "artist":
		handleArtist(metadata, *service, *outputDir, *audioFormat, *filenameFormat, *trackNumber, *tidalAPI, *batchDelay, *checkOnly, *getLyrics)
	default:
		fmt.Fprintf(os.Stderr, "Error: Unsupported content type: %s\n", contentType)
		os.Exit(1)
	}
}

func handleTrack(metadata map[string]interface{}, service, outputDir, audioFormat, filenameFormat string, trackNumber bool, tidalAPI string, checkOnly bool, getLyrics bool) {
	track, ok := metadata["track"].(map[string]interface{})
	if !ok {
		if jsonOutput {
			outputJSON(TrackResult{Success: false, Error: "Invalid track metadata"})
		} else {
			fmt.Fprintf(os.Stderr, "Error: Invalid track metadata\n")
		}
		os.Exit(1)
	}

	spotifyID := getString(track, "spotify_id")
	isrc := getString(track, "isrc")
	trackName := getString(track, "name")
	artistName := getString(track, "artists")
	albumName := getString(track, "album_name")
	duration := getInt(track, "duration_ms") / 1000

	if !quietMode && !jsonOutput {
		fmt.Printf("\nTrack: %s - %s\n", trackName, artistName)
		fmt.Printf("Album: %s\n", albumName)
		fmt.Printf("ISRC: %s\n", isrc)
	}

	if checkOnly {
		checkAvailability(spotifyID, isrc)
		return
	}

	// Download track
	result := downloadTrackWithResult(spotifyID, isrc, trackName, artistName, albumName, service, outputDir, audioFormat, filenameFormat, trackNumber, 0, false, tidalAPI, duration)

	// Download lyrics if requested
	if getLyrics {
		lyricsPath := downloadLyricsWithResult(spotifyID, trackName, artistName, outputDir, filenameFormat, trackNumber, 0, false)
		if lyricsPath != "" {
			result.LyricsPath = lyricsPath
		}
	}

	if jsonOutput {
		outputJSON(result)
	}
}

func handleAlbum(metadata map[string]interface{}, service, outputDir, audioFormat, filenameFormat string, trackNumber bool, tidalAPI string, batchDelay float64, checkOnly bool, getLyrics bool) {
	tracks, ok := metadata["tracks"].([]interface{})
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid album metadata\n")
		os.Exit(1)
	}

	albumName := getString(metadata, "album_name")
	artistName := getString(metadata, "artist_name")

	fmt.Printf("\nAlbum: %s - %s\n", albumName, artistName)
	fmt.Printf("Tracks: %d\n\n", len(tracks))

	// Create album folder
	albumFolder := filepath.Join(outputDir, sanitizeFolderName(fmt.Sprintf("%s - %s", artistName, albumName)))
	if !checkOnly {
		if err := os.MkdirAll(albumFolder, 0755); err != nil {
			fmt.Fprintf(os.Stderr, "Error: Failed to create album folder: %v\n", err)
			os.Exit(1)
		}
	}

	for i, trackData := range tracks {
		track, ok := trackData.(map[string]interface{})
		if !ok {
			continue
		}

		spotifyID := getString(track, "spotify_id")
		isrc := getString(track, "isrc")
		trackName := getString(track, "name")
		trackArtist := getString(track, "artists")
		trackAlbum := getString(track, "album_name")
		trackNum := getInt(track, "track_number")
		duration := getInt(track, "duration_ms") / 1000

		fmt.Printf("[%d/%d] %s - %s\n", i+1, len(tracks), trackName, trackArtist)

		if checkOnly {
			checkAvailability(spotifyID, isrc)
			continue
		}

		// Download track
		downloadTrack(spotifyID, isrc, trackName, trackArtist, trackAlbum, service, albumFolder, audioFormat, filenameFormat, trackNumber, trackNum, true, tidalAPI, duration)

		// Download lyrics if requested
		if getLyrics {
			downloadLyrics(spotifyID, trackName, trackArtist, albumFolder, filenameFormat, trackNumber, trackNum, true)
		}

		// Delay between downloads
		if i < len(tracks)-1 {
			time.Sleep(time.Duration(batchDelay * float64(time.Second)))
		}
	}

	fmt.Printf("\n✅ Album download completed: %s\n", albumFolder)
}

func handlePlaylist(metadata map[string]interface{}, service, outputDir, audioFormat, filenameFormat string, trackNumber bool, tidalAPI string, batchDelay float64, checkOnly bool, getLyrics bool) {
	tracks, ok := metadata["tracks"].([]interface{})
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid playlist metadata\n")
		os.Exit(1)
	}

	playlistName := getString(metadata, "name")
	fmt.Printf("\nPlaylist: %s\n", playlistName)
	fmt.Printf("Tracks: %d\n\n", len(tracks))

	// Create playlist folder
	playlistFolder := filepath.Join(outputDir, sanitizeFolderName(playlistName))
	if !checkOnly {
		if err := os.MkdirAll(playlistFolder, 0755); err != nil {
			fmt.Fprintf(os.Stderr, "Error: Failed to create playlist folder: %v\n", err)
			os.Exit(1)
		}
	}

	for i, trackData := range tracks {
		track, ok := trackData.(map[string]interface{})
		if !ok {
			continue
		}

		spotifyID := getString(track, "spotify_id")
		isrc := getString(track, "isrc")
		trackName := getString(track, "name")
		artistName := getString(track, "artists")
		albumName := getString(track, "album_name")
		duration := getInt(track, "duration_ms") / 1000

		fmt.Printf("[%d/%d] %s - %s\n", i+1, len(tracks), trackName, artistName)

		if checkOnly {
			checkAvailability(spotifyID, isrc)
			continue
		}

		// Download track (use position for playlist ordering)
		downloadTrack(spotifyID, isrc, trackName, artistName, albumName, service, playlistFolder, audioFormat, filenameFormat, trackNumber, i+1, false, tidalAPI, duration)

		// Download lyrics if requested
		if getLyrics {
			downloadLyrics(spotifyID, trackName, artistName, playlistFolder, filenameFormat, trackNumber, i+1, false)
		}

		// Delay between downloads
		if i < len(tracks)-1 {
			time.Sleep(time.Duration(batchDelay * float64(time.Second)))
		}
	}

	fmt.Printf("\n✅ Playlist download completed: %s\n", playlistFolder)
}

func handleArtist(metadata map[string]interface{}, service, outputDir, audioFormat, filenameFormat string, trackNumber bool, tidalAPI string, batchDelay float64, checkOnly bool, getLyrics bool) {
	albums, ok := metadata["albums"].([]interface{})
	if !ok {
		fmt.Fprintf(os.Stderr, "Error: Invalid artist metadata\n")
		os.Exit(1)
	}

	artistName := getString(metadata, "artist_name")
	fmt.Printf("\nArtist: %s\n", artistName)
	fmt.Printf("Albums: %d\n\n", len(albums))

	// Create artist folder
	artistFolder := filepath.Join(outputDir, sanitizeFolderName(artistName))
	if !checkOnly {
		if err := os.MkdirAll(artistFolder, 0755); err != nil {
			fmt.Fprintf(os.Stderr, "Error: Failed to create artist folder: %v\n", err)
			os.Exit(1)
		}
	}

	for _, albumData := range albums {
		album, ok := albumData.(map[string]interface{})
		if !ok {
			continue
		}

		albumName := getString(album, "album_name")
		tracks, ok := album["tracks"].([]interface{})
		if !ok {
			continue
		}

		fmt.Printf("\n=== Album: %s (%d tracks) ===\n", albumName, len(tracks))

		// Create album folder
		albumFolder := filepath.Join(artistFolder, sanitizeFolderName(albumName))
		if !checkOnly {
			if err := os.MkdirAll(albumFolder, 0755); err != nil {
				fmt.Fprintf(os.Stderr, "Error: Failed to create album folder: %v\n", err)
				continue
			}
		}

		for i, trackData := range tracks {
			track, ok := trackData.(map[string]interface{})
			if !ok {
				continue
			}

			spotifyID := getString(track, "spotify_id")
			isrc := getString(track, "isrc")
			trackName := getString(track, "name")
			trackArtist := getString(track, "artists")
			trackAlbum := getString(track, "album_name")
			trackNum := getInt(track, "track_number")
			duration := getInt(track, "duration_ms") / 1000

			fmt.Printf("[%d/%d] %s - %s\n", i+1, len(tracks), trackName, trackArtist)

			if checkOnly {
				checkAvailability(spotifyID, isrc)
				continue
			}

			// Download track
			downloadTrack(spotifyID, isrc, trackName, trackArtist, trackAlbum, service, albumFolder, audioFormat, filenameFormat, trackNumber, trackNum, true, tidalAPI, duration)

			// Download lyrics if requested
			if getLyrics {
				downloadLyrics(spotifyID, trackName, trackArtist, albumFolder, filenameFormat, trackNumber, trackNum, true)
			}

			// Delay between downloads
			if i < len(tracks)-1 {
				time.Sleep(time.Duration(batchDelay * float64(time.Second)))
			}
		}
	}

	fmt.Printf("\n✅ Artist download completed: %s\n", artistFolder)
}

func downloadTrackWithResult(spotifyID, isrc, trackName, artistName, albumName, service, outputDir, audioFormat, filenameFormat string, trackNumber bool, position int, useAlbumTrackNumber bool, tidalAPI string, duration int) TrackResult {
	result := TrackResult{
		TrackName:  trackName,
		ArtistName: artistName,
		AlbumName:  albumName,
		ISRC:       isrc,
		SpotifyID:  spotifyID,
	}

	// Check if file already exists by ISRC
	if existingFile, exists := backend.CheckISRCExists(outputDir, isrc); exists {
		result.Success = true
		result.AlreadyExists = true
		result.FilePath = existingFile
		if !quietMode && !jsonOutput {
			fmt.Printf("  ⏭️  Already exists: %s\n", filepath.Base(existingFile))
		}
		return result
	}

	// Check if file already exists by filename
	if trackName != "" && artistName != "" {
		expectedFilename := backend.BuildExpectedFilename(trackName, artistName, filenameFormat, trackNumber, position, useAlbumTrackNumber)
		expectedPath := filepath.Join(outputDir, expectedFilename)
		if fileInfo, err := os.Stat(expectedPath); err == nil && fileInfo.Size() > 0 {
			result.Success = true
			result.AlreadyExists = true
			result.FilePath = expectedPath
			if !quietMode && !jsonOutput {
				fmt.Printf("  ⏭️  Already exists: %s\n", expectedFilename)
			}
			return result
		}
	}

	// Set downloading state
	backend.SetDownloading(true)
	defer backend.SetDownloading(false)

	var filename string
	var err error

	switch service {
	case "amazon":
		downloader := backend.NewAmazonDownloader()
		filename, err = downloader.DownloadBySpotifyID(spotifyID, outputDir, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber)

	case "tidal":
		if tidalAPI == "" || tidalAPI == "auto" {
			downloader := backend.NewTidalDownloader("")
			filename, err = downloader.DownloadWithFallbackAndISRC(spotifyID, isrc, outputDir, audioFormat, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber, duration)
		} else {
			downloader := backend.NewTidalDownloader(tidalAPI)
			filename, err = downloader.DownloadWithISRC(spotifyID, isrc, outputDir, audioFormat, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber, duration)
		}

	case "qobuz":
		downloader := backend.NewQobuzDownloader()
		filename, err = downloader.DownloadByISRC(isrc, outputDir, audioFormat, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber)

	default: // deezer
		downloader := backend.NewDeezerDownloader()
		filename, err = downloader.DownloadBySpotifyID(spotifyID, outputDir, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber)
	}

	if err != nil {
		result.Success = false
		result.Error = err.Error()
		if !quietMode && !jsonOutput {
			fmt.Printf("  ❌ Download failed: %v\n", err)
		}
		return result
	}

	// Check if file already existed
	if strings.HasPrefix(filename, "EXISTS:") {
		filename = strings.TrimPrefix(filename, "EXISTS:")
		result.Success = true
		result.AlreadyExists = true
		result.FilePath = filename
		if !quietMode && !jsonOutput {
			fmt.Printf("  ⏭️  Already exists: %s\n", filepath.Base(filename))
		}
	} else {
		result.Success = true
		result.FilePath = filename
		if !quietMode && !jsonOutput {
			fmt.Printf("  ✅ Downloaded: %s\n", filepath.Base(filename))
		}
	}

	return result
}

func downloadTrack(spotifyID, isrc, trackName, artistName, albumName, service, outputDir, audioFormat, filenameFormat string, trackNumber bool, position int, useAlbumTrackNumber bool, tidalAPI string, duration int) {
	// Check if file already exists by ISRC
	if existingFile, exists := backend.CheckISRCExists(outputDir, isrc); exists {
		fmt.Printf("  ⏭️  Already exists: %s\n", filepath.Base(existingFile))
		return
	}

	// Check if file already exists by filename
	if trackName != "" && artistName != "" {
		expectedFilename := backend.BuildExpectedFilename(trackName, artistName, filenameFormat, trackNumber, position, useAlbumTrackNumber)
		expectedPath := filepath.Join(outputDir, expectedFilename)
		if fileInfo, err := os.Stat(expectedPath); err == nil && fileInfo.Size() > 0 {
			fmt.Printf("  ⏭️  Already exists: %s\n", expectedFilename)
			return
		}
	}

	// Set downloading state
	backend.SetDownloading(true)
	defer backend.SetDownloading(false)

	var filename string
	var err error

	switch service {
	case "amazon":
		downloader := backend.NewAmazonDownloader()
		filename, err = downloader.DownloadBySpotifyID(spotifyID, outputDir, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber)

	case "tidal":
		if tidalAPI == "" || tidalAPI == "auto" {
			downloader := backend.NewTidalDownloader("")
			filename, err = downloader.DownloadWithFallbackAndISRC(spotifyID, isrc, outputDir, audioFormat, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber, duration)
		} else {
			downloader := backend.NewTidalDownloader(tidalAPI)
			filename, err = downloader.DownloadWithISRC(spotifyID, isrc, outputDir, audioFormat, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber, duration)
		}

	case "qobuz":
		downloader := backend.NewQobuzDownloader()
		filename, err = downloader.DownloadByISRC(isrc, outputDir, audioFormat, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber)

	default: // deezer
		downloader := backend.NewDeezerDownloader()
		filename, err = downloader.DownloadBySpotifyID(spotifyID, outputDir, filenameFormat, trackNumber, position, trackName, artistName, albumName, useAlbumTrackNumber)
	}

	if err != nil {
		fmt.Printf("  ❌ Download failed: %v\n", err)
		return
	}

	// Check if file already existed
	if strings.HasPrefix(filename, "EXISTS:") {
		filename = strings.TrimPrefix(filename, "EXISTS:")
		fmt.Printf("  ⏭️  Already exists: %s\n", filepath.Base(filename))
	} else {
		fmt.Printf("  ✅ Downloaded: %s\n", filepath.Base(filename))
	}
}

func downloadLyricsWithResult(spotifyID, trackName, artistName, outputDir, filenameFormat string, trackNumber bool, position int, useAlbumTrackNumber bool) string {
	client := backend.NewLyricsClient()
	req := backend.LyricsDownloadRequest{
		SpotifyID:           spotifyID,
		TrackName:           trackName,
		ArtistName:          artistName,
		OutputDir:           outputDir,
		FilenameFormat:      filenameFormat,
		TrackNumber:         trackNumber,
		Position:            position,
		UseAlbumTrackNumber: useAlbumTrackNumber,
	}

	resp, err := client.DownloadLyrics(req)
	if err != nil {
		if !quietMode && !jsonOutput {
			fmt.Printf("  ⚠️  Lyrics not available\n")
		}
		return ""
	}

	if resp.Success {
		if !quietMode && !jsonOutput {
			if resp.AlreadyExists {
				fmt.Printf("  📝 Lyrics already exist: %s\n", filepath.Base(resp.File))
			} else {
				fmt.Printf("  📝 Lyrics downloaded: %s\n", filepath.Base(resp.File))
			}
		}
		return resp.File
	}
	return ""
}

func downloadLyrics(spotifyID, trackName, artistName, outputDir, filenameFormat string, trackNumber bool, position int, useAlbumTrackNumber bool) {
	client := backend.NewLyricsClient()
	req := backend.LyricsDownloadRequest{
		SpotifyID:           spotifyID,
		TrackName:           trackName,
		ArtistName:          artistName,
		OutputDir:           outputDir,
		FilenameFormat:      filenameFormat,
		TrackNumber:         trackNumber,
		Position:            position,
		UseAlbumTrackNumber: useAlbumTrackNumber,
	}

	resp, err := client.DownloadLyrics(req)
	if err != nil {
		if !quietMode {
			fmt.Printf("  ⚠️  Lyrics not available\n")
		}
		return
	}

	if resp.Success {
		if !quietMode {
			if resp.AlreadyExists {
				fmt.Printf("  📝 Lyrics already exist: %s\n", filepath.Base(resp.File))
			} else {
				fmt.Printf("  📝 Lyrics downloaded: %s\n", filepath.Base(resp.File))
			}
		}
	}
}

func checkAvailability(spotifyID, isrc string) {
	client := backend.NewSongLinkClient()
	availability, err := client.CheckTrackAvailability(spotifyID, isrc)
	if err != nil {
		fmt.Printf("  ❌ Failed to check availability: %v\n", err)
		return
	}

	fmt.Printf("  Availability:\n")
	if availability.Tidal {
		fmt.Printf("    ✅ Tidal: %s\n", availability.TidalURL)
	} else {
		fmt.Printf("    ❌ Tidal\n")
	}
	if availability.Deezer {
		fmt.Printf("    ✅ Deezer: %s\n", availability.DeezerURL)
	} else {
		fmt.Printf("    ❌ Deezer\n")
	}
	if availability.Amazon {
		fmt.Printf("    ✅ Amazon: %s\n", availability.AmazonURL)
	} else {
		fmt.Printf("    ❌ Amazon\n")
	}
	if availability.Qobuz {
		fmt.Printf("    ✅ Qobuz: %s\n", availability.QobuzURL)
	} else {
		fmt.Printf("    ❌ Qobuz\n")
	}
	fmt.Println()
}

func getString(m map[string]interface{}, key string) string {
	if val, ok := m[key]; ok {
		if str, ok := val.(string); ok {
			return str
		}
	}
	return ""
}

func getInt(m map[string]interface{}, key string) int {
	if val, ok := m[key]; ok {
		switch v := val.(type) {
		case int:
			return v
		case float64:
			return int(v)
		}
	}
	return 0
}

func sanitizeFolderName(name string) string {
	// Remove invalid characters for folder names
	invalid := []string{"<", ">", ":", "\"", "/", "\\", "|", "?", "*"}
	result := name
	for _, char := range invalid {
		result = strings.ReplaceAll(result, char, "_")
	}
	return strings.TrimSpace(result)
}

// handleISRCDownload handles direct ISRC-based downloads without Spotify metadata
func handleISRCDownload(isrc, service, outputDir, audioFormat, filenameFormat string, trackNumber bool, tidalAPI string, getLyrics bool) {
	result := TrackResult{
		ISRC: isrc,
	}

	if !quietMode {
		fmt.Printf("Downloading track with ISRC: %s\n", isrc)
		fmt.Printf("Service: %s\n", service)
	}

	// Check if file already exists by ISRC
	if existingFile, exists := backend.CheckISRCExists(outputDir, isrc); exists {
		result.Success = true
		result.AlreadyExists = true
		result.FilePath = existingFile
		
		if jsonOutput {
			outputJSON(result)
		} else if !quietMode {
			fmt.Printf("✅ File with ISRC already exists: %s\n", filepath.Base(existingFile))
		}
		return
	}

	// Set downloading state
	backend.SetDownloading(true)
	defer backend.SetDownloading(false)

	var filename string
	var err error

	switch service {
	case "qobuz":
		downloader := backend.NewQobuzDownloader()
		filename, err = downloader.DownloadByISRC(isrc, outputDir, audioFormat, filenameFormat, trackNumber, 0, "", "", "", false)

	case "tidal":
		// Tidal requires Spotify ID for song.link API, so ISRC-only won't work well
		// We'll try search by ISRC but it's limited
		result.Success = false
		result.Error = "Tidal requires Spotify ID or URL for best results. Use -spotify-id or -url instead."
		if jsonOutput {
			outputJSON(result)
		} else {
			fmt.Fprintf(os.Stderr, "Error: %s\n", result.Error)
		}
		os.Exit(1)
		return

	case "deezer", "amazon":
		// These services require Spotify ID for song.link API
		result.Success = false
		result.Error = fmt.Sprintf("%s requires Spotify ID or URL. Use -spotify-id or -url instead.", service)
		if jsonOutput {
			outputJSON(result)
		} else {
			fmt.Fprintf(os.Stderr, "Error: %s\n", result.Error)
		}
		os.Exit(1)
		return

	default:
		result.Success = false
		result.Error = fmt.Sprintf("Unknown service: %s", service)
		if jsonOutput {
			outputJSON(result)
		} else {
			fmt.Fprintf(os.Stderr, "Error: %s\n", result.Error)
		}
		os.Exit(1)
		return
	}

	if err != nil {
		result.Success = false
		result.Error = err.Error()
		if jsonOutput {
			outputJSON(result)
		} else {
			fmt.Fprintf(os.Stderr, "❌ Download failed: %v\n", err)
		}
		os.Exit(1)
		return
	}

	// Check if file already existed
	if strings.HasPrefix(filename, "EXISTS:") {
		filename = strings.TrimPrefix(filename, "EXISTS:")
		result.Success = true
		result.AlreadyExists = true
		result.FilePath = filename
	} else {
		result.Success = true
		result.FilePath = filename
	}

	if jsonOutput {
		outputJSON(result)
	} else if !quietMode {
		if result.AlreadyExists {
			fmt.Printf("✅ File already exists: %s\n", filepath.Base(filename))
		} else {
			fmt.Printf("✅ Downloaded: %s\n", filepath.Base(filename))
		}
	}
}

// outputJSON outputs a result in JSON format
func outputJSON(result interface{}) {
	data, err := json.MarshalIndent(result, "", "  ")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error encoding JSON: %v\n", err)
		os.Exit(1)
	}
	fmt.Println(string(data))
}

```

## backend/amazon.go

```go
package backend

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type AmazonDownloader struct {
	client           *http.Client
	regions          []string
	lastAPICallTime  time.Time
	apiCallCount     int
	apiCallResetTime time.Time
}

type SongLinkResponse struct {
	LinksByPlatform map[string]struct {
		URL string `json:"url"`
	} `json:"linksByPlatform"`
}

type DoubleDoubleSubmitResponse struct {
	Success bool   `json:"success"`
	ID      string `json:"id"`
}

type DoubleDoubleStatusResponse struct {
	Status         string `json:"status"`
	FriendlyStatus string `json:"friendlyStatus"`
	URL            string `json:"url"`
	Current        struct {
		Name   string `json:"name"`
		Artist string `json:"artist"`
	} `json:"current"`
}

func NewAmazonDownloader() *AmazonDownloader {
	return &AmazonDownloader{
		client: &http.Client{
			Timeout: 120 * time.Second,
		},
		regions:          []string{"us", "eu"},
		apiCallResetTime: time.Now(),
	}
}

func (a *AmazonDownloader) getRandomUserAgent() string {
	return fmt.Sprintf("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_%d_%d) AppleWebKit/%d.%d (KHTML, like Gecko) Chrome/%d.0.%d.%d Safari/%d.%d",
		rand.Intn(4)+11, rand.Intn(5)+4,
		rand.Intn(7)+530, rand.Intn(7)+30,
		rand.Intn(25)+80, rand.Intn(1500)+3000, rand.Intn(65)+60,
		rand.Intn(7)+530, rand.Intn(6)+30)
}

func (a *AmazonDownloader) GetAmazonURLFromSpotify(spotifyTrackID string) (string, error) {
	// Rate limiting: max 10 requests per minute (song.link API limit)
	// Reset counter every minute
	now := time.Now()
	if now.Sub(a.apiCallResetTime) >= time.Minute {
		a.apiCallCount = 0
		a.apiCallResetTime = now
	}

	// If we've hit the limit, wait until the next minute
	if a.apiCallCount >= 9 { // Use 9 to be safe (limit is 10)
		waitTime := time.Minute - now.Sub(a.apiCallResetTime)
		if waitTime > 0 {
			fmt.Printf("Rate limit reached, waiting %v...\n", waitTime.Round(time.Second))
			time.Sleep(waitTime)
			a.apiCallCount = 0
			a.apiCallResetTime = time.Now()
		}
	}

	// Add delay between requests (6 seconds = 10 requests per minute)
	if !a.lastAPICallTime.IsZero() {
		timeSinceLastCall := now.Sub(a.lastAPICallTime)
		minDelay := 7 * time.Second // 7 seconds to be safe
		if timeSinceLastCall < minDelay {
			waitTime := minDelay - timeSinceLastCall
			fmt.Printf("Rate limiting: waiting %v...\n", waitTime.Round(time.Second))
			time.Sleep(waitTime)
		}
	}

	// Decode base64 API URL
	spotifyBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9vcGVuLnNwb3RpZnkuY29tL3RyYWNrLw==")
	spotifyURL := fmt.Sprintf("%s%s", string(spotifyBase), spotifyTrackID)

	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hcGkuc29uZy5saW5rL3YxLWFscGhhLjEvbGlua3M/dXJsPQ==")
	apiURL := fmt.Sprintf("%s%s", string(apiBase), url.QueryEscape(spotifyURL))

	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("User-Agent", a.getRandomUserAgent())

	fmt.Println("Getting Amazon URL...")

	// Retry logic for rate limit errors
	maxRetries := 3
	var resp *http.Response
	for i := 0; i < maxRetries; i++ {
		resp, err = a.client.Do(req)
		if err != nil {
			return "", fmt.Errorf("failed to get Amazon URL: %w", err)
		}

		// Update rate limit tracking
		a.lastAPICallTime = time.Now()
		a.apiCallCount++

		if resp.StatusCode == 429 { // Too Many Requests
			resp.Body.Close()
			if i < maxRetries-1 {
				waitTime := 15 * time.Second
				fmt.Printf("Rate limited by API, waiting %v before retry...\n", waitTime)
				time.Sleep(waitTime)
				continue
			}
			return "", fmt.Errorf("API rate limit exceeded after %d retries", maxRetries)
		}

		if resp.StatusCode != 200 {
			resp.Body.Close()
			return "", fmt.Errorf("API returned status %d", resp.StatusCode)
		}

		break
	}
	defer resp.Body.Close()

	var songLinkResp SongLinkResponse
	if err := json.NewDecoder(resp.Body).Decode(&songLinkResp); err != nil {
		return "", fmt.Errorf("failed to decode response: %w", err)
	}

	amazonLink, ok := songLinkResp.LinksByPlatform["amazonMusic"]
	if !ok || amazonLink.URL == "" {
		return "", fmt.Errorf("amazon Music link not found")
	}

	amazonURL := amazonLink.URL

	// Convert album URL to track URL if needed
	if strings.Contains(amazonURL, "trackAsin=") {
		parts := strings.Split(amazonURL, "trackAsin=")
		if len(parts) > 1 {
			trackAsin := strings.Split(parts[1], "&")[0]
			musicBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9tdXNpYy5hbWF6b24uY29tL3RyYWNrcy8=")
			amazonURL = fmt.Sprintf("%s%s?musicTerritory=US", string(musicBase), trackAsin)
		}
	}

	fmt.Printf("Found Amazon URL: %s\n", amazonURL)
	return amazonURL, nil
}

func (a *AmazonDownloader) DownloadFromService(amazonURL, outputDir string) (string, error) {
	var lastError error

	for _, region := range a.regions {
		fmt.Printf("\nTrying region: %s...\n", region)
		// Decode base64 service URL
		serviceBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly8=")
		serviceDomain, _ := base64.StdEncoding.DecodeString("LmRvdWJsZWRvdWJsZS50b3A=")
		baseURL := fmt.Sprintf("%s%s%s", string(serviceBase), region, string(serviceDomain))

		// Step 1: Submit download request
		encodedURL := url.QueryEscape(amazonURL)
		submitURL := fmt.Sprintf("%s/dl?url=%s", baseURL, encodedURL)

		req, err := http.NewRequest("GET", submitURL, nil)
		if err != nil {
			lastError = fmt.Errorf("failed to create request: %w", err)
			continue
		}

		req.Header.Set("User-Agent", a.getRandomUserAgent())

		fmt.Println("Submitting download request...")
		resp, err := a.client.Do(req)
		if err != nil {
			lastError = fmt.Errorf("failed to submit request: %w", err)
			continue
		}

		if resp.StatusCode != 200 {
			resp.Body.Close()
			lastError = fmt.Errorf("submit failed with status %d", resp.StatusCode)
			continue
		}

		var submitResp DoubleDoubleSubmitResponse
		if err := json.NewDecoder(resp.Body).Decode(&submitResp); err != nil {
			resp.Body.Close()
			lastError = fmt.Errorf("failed to decode submit response: %w", err)
			continue
		}
		resp.Body.Close()

		if !submitResp.Success || submitResp.ID == "" {
			lastError = fmt.Errorf("submit request failed")
			continue
		}

		downloadID := submitResp.ID
		fmt.Printf("Download ID: %s\n", downloadID)

		// Step 2: Poll for completion
		statusURL := fmt.Sprintf("%s/dl/%s", baseURL, downloadID)
		fmt.Println("Waiting for download to complete...")

		maxWait := 300 * time.Second
		elapsed := time.Duration(0)
		pollInterval := 3 * time.Second

		for elapsed < maxWait {
			time.Sleep(pollInterval)
			elapsed += pollInterval

			statusReq, err := http.NewRequest("GET", statusURL, nil)
			if err != nil {
				continue
			}

			statusReq.Header.Set("User-Agent", a.getRandomUserAgent())

			statusResp, err := a.client.Do(statusReq)
			if err != nil {
				fmt.Printf("\rStatus check failed, retrying...")
				continue
			}

			if statusResp.StatusCode != 200 {
				statusResp.Body.Close()
				fmt.Printf("\rStatus check failed (status %d), retrying...", statusResp.StatusCode)
				continue
			}

			var status DoubleDoubleStatusResponse
			if err := json.NewDecoder(statusResp.Body).Decode(&status); err != nil {
				statusResp.Body.Close()
				fmt.Printf("\rInvalid JSON response, retrying...")
				continue
			}
			statusResp.Body.Close()

			if status.Status == "done" {
				fmt.Println("\nDownload ready!")

				// Build download URL
				fileURL := status.URL
				if strings.HasPrefix(fileURL, "./") {
					fileURL = fmt.Sprintf("%s/%s", baseURL, fileURL[2:])
				} else if strings.HasPrefix(fileURL, "/") {
					fileURL = fmt.Sprintf("%s%s", baseURL, fileURL)
				}

				trackName := status.Current.Name
				artist := status.Current.Artist

				fmt.Printf("Downloading: %s - %s\n", artist, trackName)

				// Download file
				downloadReq, err := http.NewRequest("GET", fileURL, nil)
				if err != nil {
					lastError = fmt.Errorf("failed to create download request: %w", err)
					break
				}

				downloadReq.Header.Set("User-Agent", a.getRandomUserAgent())

				fileResp, err := a.client.Do(downloadReq)
				if err != nil {
					lastError = fmt.Errorf("failed to download file: %w", err)
					break
				}
				defer fileResp.Body.Close()

				if fileResp.StatusCode != 200 {
					lastError = fmt.Errorf("download failed with status %d", fileResp.StatusCode)
					break
				}

				// Generate filename
				fileName := fmt.Sprintf("%s - %s.flac", artist, trackName)
				for _, char := range `<>:"/\|?*` {
					fileName = strings.ReplaceAll(fileName, string(char), "")
				}
				fileName = strings.TrimSpace(fileName)

				filePath := filepath.Join(outputDir, fileName)

				// Save file
				out, err := os.Create(filePath)
				if err != nil {
					lastError = fmt.Errorf("failed to create file: %w", err)
					break
				}
				defer out.Close()

				fmt.Println("Downloading...")
				// Use progress writer to track download
				pw := NewProgressWriter(out)
				_, err = io.Copy(pw, fileResp.Body)
				if err != nil {
					out.Close()
					return "", fmt.Errorf("failed to write file: %w", err)
				}

				// Print final size
				fmt.Printf("\rDownloaded: %.2f MB (Complete)\n", float64(pw.GetTotal())/(1024*1024))
				fmt.Println("Download complete!")
				return filePath, nil

			} else if status.Status == "error" {
				errorMsg := status.FriendlyStatus
				if errorMsg == "" {
					errorMsg = "Unknown error"
				}
				lastError = fmt.Errorf("processing failed: %s", errorMsg)
				break
			} else {
				// Still processing
				friendlyStatus := status.FriendlyStatus
				if friendlyStatus == "" {
					friendlyStatus = status.Status
				}
				fmt.Printf("\r%s...", friendlyStatus)
			}
		}

		if elapsed >= maxWait {
			lastError = fmt.Errorf("download timeout")
			fmt.Printf("\nError with %s region: %v\n", region, lastError)
			continue
		}

		if lastError != nil {
			fmt.Printf("\nError with %s region: %v\n", region, lastError)
		}
	}

	return "", fmt.Errorf("all regions failed. Last error: %v", lastError)
}

func (a *AmazonDownloader) DownloadByURL(amazonURL, outputDir, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool) (string, error) {
	// Create output directory if needed
	if outputDir != "." {
		if err := os.MkdirAll(outputDir, 0755); err != nil {
			return "", fmt.Errorf("failed to create output directory: %w", err)
		}
	}

	// Check if file with expected name already exists (Amazon doesn't provide ISRC before download)
	if spotifyTrackName != "" && spotifyArtistName != "" {
		expectedFilename := BuildExpectedFilename(spotifyTrackName, spotifyArtistName, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
		expectedPath := filepath.Join(outputDir, expectedFilename)

		if fileInfo, err := os.Stat(expectedPath); err == nil && fileInfo.Size() > 0 {
			fmt.Printf("File already exists: %s (%.2f MB)\n", expectedPath, float64(fileInfo.Size())/(1024*1024))
			return "EXISTS:" + expectedPath, nil
		}
	}

	fmt.Printf("Using Amazon URL: %s\n", amazonURL)

	// Download from service
	filePath, err := a.DownloadFromService(amazonURL, outputDir)
	if err != nil {
		return "", err
	}

	// File already has embedded metadata, just rename if needed
	if spotifyTrackName != "" && spotifyArtistName != "" {
		safeArtist := sanitizeFilename(spotifyArtistName)
		safeTitle := sanitizeFilename(spotifyTrackName)

		// Build filename based on format settings
		var newFilename string
		switch filenameFormat {
		case "artist-title":
			newFilename = fmt.Sprintf("%s - %s", safeArtist, safeTitle)
		case "title":
			newFilename = safeTitle
		default: // "title-artist"
			newFilename = fmt.Sprintf("%s - %s", safeTitle, safeArtist)
		}

		// Add track number prefix if enabled
		if includeTrackNumber && position > 0 {
			newFilename = fmt.Sprintf("%02d. %s", position, newFilename)
		}

		newFilename = newFilename + ".flac"
		newFilePath := filepath.Join(outputDir, newFilename)

		// Rename file
		if err := os.Rename(filePath, newFilePath); err != nil {
			fmt.Printf("Warning: Failed to rename file: %v\n", err)
		} else {
			filePath = newFilePath
			fmt.Printf("Renamed to: %s\n", newFilename)
		}
	}

	fmt.Println("Done")
	fmt.Println("✓ Downloaded successfully from Amazon Music")
	return filePath, nil
}

func (a *AmazonDownloader) DownloadBySpotifyID(spotifyTrackID, outputDir, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool) (string, error) {
	// Get Amazon URL from Spotify track ID
	amazonURL, err := a.GetAmazonURLFromSpotify(spotifyTrackID)
	if err != nil {
		return "", err
	}

	return a.DownloadByURL(amazonURL, outputDir, filenameFormat, includeTrackNumber, position, spotifyTrackName, spotifyArtistName, spotifyAlbumName, useAlbumTrackNumber)
}

```

## backend/analysis.go

```go
package backend

import (
	"fmt"
	"math"
	"os"

	"github.com/go-flac/go-flac"
	mewflac "github.com/mewkiz/flac"
)

// AnalysisResult contains the audio analysis data
type AnalysisResult struct {
	FilePath      string        `json:"file_path"`
	SampleRate    uint32        `json:"sample_rate"`
	Channels      uint8         `json:"channels"`
	BitsPerSample uint8         `json:"bits_per_sample"`
	TotalSamples  uint64        `json:"total_samples"`
	Duration      float64       `json:"duration"`
	BitDepth      string        `json:"bit_depth"`
	DynamicRange  float64       `json:"dynamic_range"`
	PeakAmplitude float64       `json:"peak_amplitude"`
	RMSLevel      float64       `json:"rms_level"`
	Spectrum      *SpectrumData `json:"spectrum,omitempty"`
}

// AnalyzeTrack performs audio analysis on a FLAC file
func AnalyzeTrack(filepath string) (*AnalysisResult, error) {
	if !fileExists(filepath) {
		return nil, fmt.Errorf("file does not exist: %s", filepath)
	}

	// Parse FLAC file
	f, err := flac.ParseFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse FLAC file: %w", err)
	}

	result := &AnalysisResult{
		FilePath: filepath,
	}

	// Extract basic audio properties from STREAMINFO block
	if len(f.Meta) > 0 {
		streamInfo := f.Meta[0]
		if streamInfo.Type == flac.StreamInfo {
			// Read STREAMINFO data
			data := streamInfo.Data
			if len(data) >= 18 {
				// Sample rate (bits 10-29 of bytes 10-13)
				result.SampleRate = uint32(data[10])<<12 | uint32(data[11])<<4 | uint32(data[12])>>4

				// Channels (bits 30-32 of byte 12)
				result.Channels = ((data[12] >> 1) & 0x07) + 1

				// Bits per sample (bits 33-37 of bytes 12-13)
				result.BitsPerSample = ((data[12]&0x01)<<4 | data[13]>>4) + 1

				// Total samples (bits 38-73 of bytes 13-17)
				result.TotalSamples = uint64(data[13]&0x0F)<<32 |
					uint64(data[14])<<24 |
					uint64(data[15])<<16 |
					uint64(data[16])<<8 |
					uint64(data[17])

				// Calculate duration
				if result.SampleRate > 0 {
					result.Duration = float64(result.TotalSamples) / float64(result.SampleRate)
				}

				// Read min/max frame size and block size for additional analysis
				// Min block size (bytes 0-1)
				// Max block size (bytes 2-3)
				// These can give us hints about encoding quality
			}
		}
	}

	// Analyze spectrum and calculate real audio metrics
	spectrum, err := AnalyzeSpectrum(filepath)
	if err != nil {
		// Log error but continue
		fmt.Printf("Warning: failed to analyze spectrum: %v\n", err)
	} else {
		result.Spectrum = spectrum
		// Calculate dynamic range, peak, and RMS from decoded samples
		calculateRealAudioMetrics(result, filepath)
	}

	// Set bit depth
	result.BitDepth = fmt.Sprintf("%d-bit", result.BitsPerSample)

	return result, nil
}

// calculateRealAudioMetrics calculates actual dynamic range, peak, and RMS from decoded audio
func calculateRealAudioMetrics(result *AnalysisResult, filepath string) {
	// Decode FLAC to get actual samples
	samples, err := decodeFLACForMetrics(filepath)
	if err != nil {
		return
	}

	// Calculate peak amplitude
	var peak float64
	var sumSquares float64

	for _, sample := range samples {
		absVal := sample
		if absVal < 0 {
			absVal = -absVal
		}
		if absVal > peak {
			peak = absVal
		}
		sumSquares += sample * sample
	}

	// Convert peak to dB (reference: 1.0 = 0 dBFS)
	peakDB := 20.0 * math.Log10(peak)
	result.PeakAmplitude = peakDB

	// Calculate RMS (Root Mean Square)
	rms := math.Sqrt(sumSquares / float64(len(samples)))
	rmsDB := 20.0 * math.Log10(rms)
	result.RMSLevel = rmsDB

	// Dynamic range is the difference between peak and RMS
	result.DynamicRange = peakDB - rmsDB
}

// decodeFLACForMetrics decodes FLAC file and returns normalized samples for metric calculation
func decodeFLACForMetrics(filepath string) ([]float64, error) {
	stream, err := mewflac.ParseFile(filepath)
	if err != nil {
		return nil, err
	}
	defer stream.Close()

	// Limit samples to prevent memory issues (10 million samples = ~3.8 minutes at 44.1kHz)
	maxSamples := 10000000
	samples := make([]float64, 0, maxSamples)

	// Read all audio frames
	for {
		frame, err := stream.ParseNext()
		if err != nil {
			break
		}

		// Get samples from first channel (mono or left channel)
		var channelSamples []int32
		if len(frame.Subframes) > 0 {
			channelSamples = frame.Subframes[0].Samples
		}

		// Normalize samples to -1.0 to 1.0 range
		maxVal := float64(int64(1) << (stream.Info.BitsPerSample - 1))
		for _, sample := range channelSamples {
			if len(samples) >= maxSamples {
				return samples, nil
			}
			normalized := float64(sample) / maxVal
			samples = append(samples, normalized)
		}

		if len(samples) >= maxSamples {
			break
		}
	}

	return samples, nil
}

func GetFileSize(filepath string) (int64, error) {
	info, err := os.Stat(filepath)
	if err != nil {
		return 0, err
	}
	return info.Size(), nil
}

```

## backend/config.go

```go
package backend

import (
	"os"
	"path/filepath"
)

func GetDefaultMusicPath() string {
	// Get user's home directory
	homeDir, err := os.UserHomeDir()
	if err != nil {
		// Fallback to Public Music if can't get home dir
		return "C:\\Users\\Public\\Music"
	}

	// Return path to user's Music folder
	return filepath.Join(homeDir, "Music")
}

```

## backend/deezer.go

```go
package backend

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type DeezerDownloader struct {
	client *http.Client
}

type DeezerTrack struct {
	ID          int64  `json:"id"`
	Title       string `json:"title"`
	TitleShort  string `json:"title_short"`
	Duration    int    `json:"duration"`
	TrackPos    int    `json:"track_position"`
	DiskNumber  int    `json:"disk_number"`
	ISRC        string `json:"isrc"`
	ReleaseDate string `json:"release_date"`
	Artist      struct {
		Name string `json:"name"`
		ID   int64  `json:"id"`
	} `json:"artist"`
	Album struct {
		Title    string `json:"title"`
		ID       int64  `json:"id"`
		CoverXL  string `json:"cover_xl"`
		CoverBig string `json:"cover_big"`
	} `json:"album"`
	Contributors []struct {
		Name string `json:"name"`
		Role string `json:"role"`
	} `json:"contributors"`
}

type DeezMateResponse struct {
	Success bool `json:"success"`
	Links   struct {
		FLAC string `json:"flac"`
	} `json:"links"`
}

func NewDeezerDownloader() *DeezerDownloader {
	return &DeezerDownloader{
		client: &http.Client{
			Timeout: 60 * time.Second,
		},
	}
}

func (d *DeezerDownloader) GetDeezerURLFromSpotify(spotifyTrackID string) (string, error) {
	// Decode base64 API URL
	spotifyBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9vcGVuLnNwb3RpZnkuY29tL3RyYWNrLw==")
	spotifyURL := fmt.Sprintf("%s%s", string(spotifyBase), spotifyTrackID)

	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hcGkuc29uZy5saW5rL3YxLWFscGhhLjEvbGlua3M/dXJsPQ==")
	apiURL := fmt.Sprintf("%s%s", string(apiBase), spotifyURL)

	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	fmt.Println("Getting Deezer URL...")

	resp, err := d.client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to get Deezer URL: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	var songLinkResp struct {
		LinksByPlatform map[string]struct {
			URL string `json:"url"`
		} `json:"linksByPlatform"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&songLinkResp); err != nil {
		return "", fmt.Errorf("failed to decode response: %w", err)
	}

	deezerLink, ok := songLinkResp.LinksByPlatform["deezer"]
	if !ok || deezerLink.URL == "" {
		return "", fmt.Errorf("deezer link not found")
	}

	deezerURL := deezerLink.URL
	fmt.Printf("Found Deezer URL: %s\n", deezerURL)
	return deezerURL, nil
}

func (d *DeezerDownloader) GetTrackIDFromURL(deezerURL string) (int64, error) {
	// Extract track ID from Deezer URL
	// Format: https://www.deezer.com/track/3412534581
	parts := strings.Split(deezerURL, "/track/")
	if len(parts) < 2 {
		return 0, fmt.Errorf("invalid Deezer URL format")
	}

	// Get the track ID part and remove any query parameters
	trackIDStr := strings.Split(parts[1], "?")[0]
	trackIDStr = strings.TrimSpace(trackIDStr)

	var trackID int64
	_, err := fmt.Sscanf(trackIDStr, "%d", &trackID)
	if err != nil {
		return 0, fmt.Errorf("failed to parse track ID: %w", err)
	}

	return trackID, nil
}

func (d *DeezerDownloader) GetTrackByID(trackID int64) (*DeezerTrack, error) {
	// Decode base64 API URL
	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hcGkuZGVlemVyLmNvbS8yLjAvdHJhY2sv")
	url := fmt.Sprintf("%s%d", string(apiBase), trackID)

	resp, err := d.client.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch track: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	var track DeezerTrack
	if err := json.NewDecoder(resp.Body).Decode(&track); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	if track.ID == 0 {
		return nil, fmt.Errorf("track not found")
	}

	return &track, nil
}

func (d *DeezerDownloader) GetDownloadURL(trackID int64) (string, error) {
	// Decode base64 API URL
	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hcGkuZGVlem1hdGUuY29tL2RsLw==")
	url := fmt.Sprintf("%s%d", string(apiBase), trackID)

	resp, err := d.client.Get(url)
	if err != nil {
		return "", fmt.Errorf("failed to get download URL: %w", err)
	}
	defer resp.Body.Close()

	var apiResp DeezMateResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResp); err != nil {
		return "", fmt.Errorf("failed to decode API response: %w", err)
	}

	if !apiResp.Success || apiResp.Links.FLAC == "" {
		return "", fmt.Errorf("no FLAC download link available")
	}

	return apiResp.Links.FLAC, nil
}

func (d *DeezerDownloader) DownloadFile(url, filepath string) error {
	resp, err := d.client.Get(url)
	if err != nil {
		return fmt.Errorf("failed to download file: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("download failed with status %d", resp.StatusCode)
	}

	out, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer out.Close()

	fmt.Println("Downloading...")
	// Use progress writer to track download
	pw := NewProgressWriter(out)
	_, err = io.Copy(pw, resp.Body)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	// Print final size
	fmt.Printf("\rDownloaded: %.2f MB (Complete)\n", float64(pw.GetTotal())/(1024*1024))
	return nil
}

func (d *DeezerDownloader) DownloadCoverArt(coverURL, filepath string) error {
	if coverURL == "" {
		return fmt.Errorf("no cover URL provided")
	}

	resp, err := d.client.Get(coverURL)
	if err != nil {
		return fmt.Errorf("failed to download cover: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("cover download failed with status %d", resp.StatusCode)
	}

	out, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("failed to create cover file: %w", err)
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	return err
}

func buildFilename(title, artist string, trackNumber int, format string, includeTrackNumber bool, position int, useAlbumTrackNumber bool) string {
	var filename string

	// Build base filename based on format
	switch format {
	case "artist-title":
		filename = fmt.Sprintf("%s - %s", artist, title)
	case "title":
		filename = title
	default: // "title-artist"
		filename = fmt.Sprintf("%s - %s", title, artist)
	}

	// Add track number prefix if enabled
	if includeTrackNumber && position > 0 {
		// Use album track number if in album folder structure, otherwise use playlist position
		numberToUse := position
		if useAlbumTrackNumber && trackNumber > 0 {
			numberToUse = trackNumber
		}
		filename = fmt.Sprintf("%02d. %s", numberToUse, filename)
	}

	return filename + ".flac"
}

func (d *DeezerDownloader) DownloadByURL(deezerURL, outputDir, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool) (string, error) {
	fmt.Printf("Using Deezer URL: %s\n", deezerURL)

	// Extract track ID from URL
	trackID, err := d.GetTrackIDFromURL(deezerURL)
	if err != nil {
		return "", err
	}

	// Get track info by ID
	track, err := d.GetTrackByID(trackID)
	if err != nil {
		return "", err
	}

	// Use Spotify metadata if provided, otherwise fallback to Deezer metadata
	artists := spotifyArtistName
	trackTitle := spotifyTrackName
	albumTitle := spotifyAlbumName

	if artists == "" {
		artists = track.Artist.Name
		if len(track.Contributors) > 0 {
			var mainArtists []string
			for _, contrib := range track.Contributors {
				if contrib.Role == "Main" {
					mainArtists = append(mainArtists, contrib.Name)
				}
			}
			if len(mainArtists) > 0 {
				artists = strings.Join(mainArtists, ", ")
			}
		}
	}

	if trackTitle == "" {
		trackTitle = track.Title
	}

	if albumTitle == "" {
		albumTitle = track.Album.Title
	}

	fmt.Printf("Found track: %s - %s\n", artists, trackTitle)
	fmt.Printf("Album: %s\n", albumTitle)

	downloadURL, err := d.GetDownloadURL(track.ID)
	if err != nil {
		return "", err
	}

	safeArtist := sanitizeFilename(artists)
	safeTitle := sanitizeFilename(trackTitle)

	// Check if file with same ISRC already exists
	if existingFile, exists := CheckISRCExists(outputDir, track.ISRC); exists {
		fmt.Printf("File with ISRC %s already exists: %s\n", track.ISRC, existingFile)
		return "EXISTS:" + existingFile, nil
	}

	// Build filename based on format settings
	filename := buildFilename(safeTitle, safeArtist, track.TrackPos, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	filepath := filepath.Join(outputDir, filename)

	if fileInfo, err := os.Stat(filepath); err == nil && fileInfo.Size() > 0 {
		fmt.Printf("File already exists: %s (%.2f MB)\n", filepath, float64(fileInfo.Size())/(1024*1024))
		return "EXISTS:" + filepath, nil
	}

	fmt.Println("Downloading FLAC file...")
	if err := d.DownloadFile(downloadURL, filepath); err != nil {
		return "", err
	}

	fmt.Printf("Downloaded: %s\n", filepath)

	coverPath := ""
	if track.Album.CoverXL != "" {
		coverPath = filepath + ".cover.jpg"
		fmt.Println("Downloading cover art...")
		if err := d.DownloadCoverArt(track.Album.CoverXL, coverPath); err != nil {
			fmt.Printf("Warning: Failed to download cover art: %v\n", err)
		} else {
			defer os.Remove(coverPath)
		}
	}

	fmt.Println("Embedding metadata and cover art...")
	// Use album track number if in album folder structure, otherwise use playlist position
	trackNumberToEmbed := 0
	if position > 0 {
		if useAlbumTrackNumber && track.TrackPos > 0 {
			trackNumberToEmbed = track.TrackPos
		} else {
			trackNumberToEmbed = position
		}
	}

	metadata := Metadata{
		Title:       trackTitle,
		Artist:      artists,
		Album:       albumTitle,
		Date:        track.ReleaseDate,
		TrackNumber: trackNumberToEmbed,
		DiscNumber:  track.DiskNumber,
		ISRC:        track.ISRC,
	}

	if err := EmbedMetadata(filepath, metadata, coverPath); err != nil {
		return "", fmt.Errorf("failed to embed metadata: %w", err)
	}

	fmt.Println("Metadata embedded successfully!")
	fmt.Println("✓ Downloaded successfully from Deezer")
	return filepath, nil
}

func (d *DeezerDownloader) DownloadBySpotifyID(spotifyTrackID, outputDir, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool) (string, error) {
	// Get Deezer URL from Spotify track ID
	deezerURL, err := d.GetDeezerURLFromSpotify(spotifyTrackID)
	if err != nil {
		return "", err
	}

	return d.DownloadByURL(deezerURL, outputDir, filenameFormat, includeTrackNumber, position, spotifyTrackName, spotifyArtistName, spotifyAlbumName, useAlbumTrackNumber)
}

```

## backend/filename.go

```go
package backend

import (
	"fmt"
	"regexp"
	"strings"
)

// BuildExpectedFilename builds the expected filename based on track metadata and settings
func BuildExpectedFilename(trackName, artistName, filenameFormat string, includeTrackNumber bool, position int, useAlbumTrackNumber bool) string {
	// Sanitize track name and artist name
	safeTitle := sanitizeFilename(trackName)
	safeArtist := sanitizeFilename(artistName)

	var filename string

	// Build base filename based on format
	switch filenameFormat {
	case "artist-title":
		filename = fmt.Sprintf("%s - %s", safeArtist, safeTitle)
	case "title":
		filename = safeTitle
	default: // "title-artist"
		filename = fmt.Sprintf("%s - %s", safeTitle, safeArtist)
	}

	// Add track number prefix if enabled
	// Note: We can't determine the exact track number without fetching from API
	// So we only add it if position > 0 (bulk download)
	if includeTrackNumber && position > 0 {
		filename = fmt.Sprintf("%02d. %s", position, filename)
	}

	return filename + ".flac"
}

// sanitizeFilename removes invalid characters from filename
func sanitizeFilename(name string) string {
	re := regexp.MustCompile(`[<>:"/\\|?*]`)
	sanitized := re.ReplaceAllString(name, "_")
	sanitized = strings.TrimSpace(sanitized)
	if sanitized == "" {
		return "Unknown"
	}
	return sanitized
}

```

## backend/folder.go

```go
package backend

import (
	"context"
	"os/exec"
	"runtime"

	wailsRuntime "github.com/wailsapp/wails/v2/pkg/runtime"
)

func OpenFolderInExplorer(path string) error {
	var cmd *exec.Cmd

	switch runtime.GOOS {
	case "windows":
		cmd = exec.Command("explorer", path)
	case "darwin": // macOS
		cmd = exec.Command("open", path)
	case "linux":
		cmd = exec.Command("xdg-open", path)
	default:
		cmd = exec.Command("xdg-open", path)
	}

	return cmd.Start()
}

func SelectFolderDialog(ctx context.Context, defaultPath string) (string, error) {
	// If defaultPath is empty, use default music path
	if defaultPath == "" {
		defaultPath = GetDefaultMusicPath()
	}

	options := wailsRuntime.OpenDialogOptions{
		Title:            "Select Download Folder",
		DefaultDirectory: defaultPath,
	}

	selectedPath, err := wailsRuntime.OpenDirectoryDialog(ctx, options)
	if err != nil {
		return "", err
	}

	// If user cancelled, selectedPath will be empty
	if selectedPath == "" {
		return "", nil
	}

	return selectedPath, nil
}

func SelectFileDialog(ctx context.Context) (string, error) {
	options := wailsRuntime.OpenDialogOptions{
		Title: "Select FLAC File for Analysis",
		Filters: []wailsRuntime.FileFilter{
			{
				DisplayName: "FLAC Audio Files (*.flac)",
				Pattern:     "*.flac",
			},
			{
				DisplayName: "All Files (*.*)",
				Pattern:     "*.*",
			},
		},
	}

	selectedFile, err := wailsRuntime.OpenFileDialog(ctx, options)
	if err != nil {
		return "", err
	}

	// If user cancelled, selectedFile will be empty
	if selectedFile == "" {
		return "", nil
	}

	return selectedFile, nil
}

```

## backend/lyrics.go

```go
package backend

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// LyricsLine represents a single line of lyrics
type LyricsLine struct {
	StartTimeMs string `json:"startTimeMs"`
	Words       string `json:"words"`
	EndTimeMs   string `json:"endTimeMs"`
}

// LyricsResponse represents the API response
type LyricsResponse struct {
	Error    bool         `json:"error"`
	SyncType string       `json:"syncType"`
	Lines    []LyricsLine `json:"lines"`
}

// LyricsDownloadRequest represents a request to download lyrics
type LyricsDownloadRequest struct {
	SpotifyID           string `json:"spotify_id"`
	TrackName           string `json:"track_name"`
	ArtistName          string `json:"artist_name"`
	OutputDir           string `json:"output_dir"`
	FilenameFormat      string `json:"filename_format"`
	TrackNumber         bool   `json:"track_number"`
	Position            int    `json:"position"`
	UseAlbumTrackNumber bool   `json:"use_album_track_number"`
}

// LyricsDownloadResponse represents the response from lyrics download
type LyricsDownloadResponse struct {
	Success       bool   `json:"success"`
	Message       string `json:"message"`
	File          string `json:"file,omitempty"`
	Error         string `json:"error,omitempty"`
	AlreadyExists bool   `json:"already_exists,omitempty"`
}

// LyricsClient handles lyrics fetching
type LyricsClient struct {
	httpClient *http.Client
}

// NewLyricsClient creates a new lyrics client
func NewLyricsClient() *LyricsClient {
	return &LyricsClient{
		httpClient: &http.Client{Timeout: 15 * time.Second},
	}
}

// FetchLyrics fetches lyrics from the Spotify Lyrics API
func (c *LyricsClient) FetchLyrics(spotifyID string) (*LyricsResponse, error) {
	// Decode base64 API URL
	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9zcG90aWZ5LWx5cmljcy1hcGktcGkudmVyY2VsLmFwcC8/dHJhY2tpZD0=")
	url := fmt.Sprintf("%s%s", string(apiBase), spotifyID)

	resp, err := c.httpClient.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch lyrics: %v", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response: %v", err)
	}

	var lyricsResp LyricsResponse
	if err := json.Unmarshal(body, &lyricsResp); err != nil {
		return nil, fmt.Errorf("failed to parse lyrics response: %v", err)
	}

	if lyricsResp.Error {
		return nil, fmt.Errorf("lyrics not found for this track")
	}

	return &lyricsResp, nil
}

// ConvertToLRC converts lyrics response to LRC format
func (c *LyricsClient) ConvertToLRC(lyrics *LyricsResponse, trackName, artistName string) string {
	var sb strings.Builder

	// Add metadata
	sb.WriteString(fmt.Sprintf("[ti:%s]\n", trackName))
	sb.WriteString(fmt.Sprintf("[ar:%s]\n", artistName))
	sb.WriteString("[by:SpotiFlac]\n")
	sb.WriteString("\n")

	// Add lyrics lines
	for _, line := range lyrics.Lines {
		if line.Words == "" {
			continue
		}

		// Convert milliseconds to LRC timestamp format [mm:ss.xx]
		timestamp := msToLRCTimestamp(line.StartTimeMs)
		sb.WriteString(fmt.Sprintf("%s%s\n", timestamp, line.Words))
	}

	return sb.String()
}

// msToLRCTimestamp converts milliseconds string to LRC timestamp format [mm:ss.xx]
func msToLRCTimestamp(msStr string) string {
	var ms int64
	fmt.Sscanf(msStr, "%d", &ms)

	totalSeconds := ms / 1000
	minutes := totalSeconds / 60
	seconds := totalSeconds % 60
	centiseconds := (ms % 1000) / 10

	return fmt.Sprintf("[%02d:%02d.%02d]", minutes, seconds, centiseconds)
}

// buildLyricsFilename builds the lyrics filename based on settings (same as track filename)
func buildLyricsFilename(trackName, artistName, filenameFormat string, includeTrackNumber bool, position int) string {
	safeTitle := sanitizeFilename(trackName)
	safeArtist := sanitizeFilename(artistName)

	var filename string

	// Build base filename based on format
	switch filenameFormat {
	case "artist-title":
		filename = fmt.Sprintf("%s - %s", safeArtist, safeTitle)
	case "title":
		filename = safeTitle
	default: // "title-artist"
		filename = fmt.Sprintf("%s - %s", safeTitle, safeArtist)
	}

	// Add track number prefix if enabled
	if includeTrackNumber && position > 0 {
		filename = fmt.Sprintf("%02d. %s", position, filename)
	}

	return filename + ".lrc"
}

// DownloadLyrics downloads lyrics for a single track
func (c *LyricsClient) DownloadLyrics(req LyricsDownloadRequest) (*LyricsDownloadResponse, error) {
	if req.SpotifyID == "" {
		return &LyricsDownloadResponse{
			Success: false,
			Error:   "Spotify ID is required",
		}, fmt.Errorf("spotify ID is required")
	}

	// Create output directory if it doesn't exist
	outputDir := req.OutputDir
	if outputDir == "" {
		outputDir = GetDefaultMusicPath()
	}

	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return &LyricsDownloadResponse{
			Success: false,
			Error:   fmt.Sprintf("failed to create output directory: %v", err),
		}, err
	}

	// Generate filename using same format as track
	filenameFormat := req.FilenameFormat
	if filenameFormat == "" {
		filenameFormat = "title-artist" // default
	}
	filename := buildLyricsFilename(req.TrackName, req.ArtistName, filenameFormat, req.TrackNumber, req.Position)
	filePath := filepath.Join(outputDir, filename)

	// Check if file already exists
	if fileInfo, err := os.Stat(filePath); err == nil && fileInfo.Size() > 0 {
		return &LyricsDownloadResponse{
			Success:       true,
			Message:       "Lyrics file already exists",
			File:          filePath,
			AlreadyExists: true,
		}, nil
	}

	// Fetch lyrics
	lyrics, err := c.FetchLyrics(req.SpotifyID)
	if err != nil {
		return &LyricsDownloadResponse{
			Success: false,
			Error:   err.Error(),
		}, err
	}

	// Convert to LRC format
	lrcContent := c.ConvertToLRC(lyrics, req.TrackName, req.ArtistName)

	// Write LRC file
	if err := os.WriteFile(filePath, []byte(lrcContent), 0644); err != nil {
		return &LyricsDownloadResponse{
			Success: false,
			Error:   fmt.Sprintf("failed to write LRC file: %v", err),
		}, err
	}

	return &LyricsDownloadResponse{
		Success: true,
		Message: "Lyrics downloaded successfully",
		File:    filePath,
	}, nil
}

```

## backend/metadata.go

```go
package backend

import (
	"fmt"
	"os"
	"strconv"
	"strings"

	"github.com/go-flac/flacpicture"
	"github.com/go-flac/flacvorbis"
	"github.com/go-flac/go-flac"
)

type Metadata struct {
	Title       string
	Artist      string
	Album       string
	Date        string
	TrackNumber int
	DiscNumber  int
	ISRC        string
}

func EmbedMetadata(filepath string, metadata Metadata, coverPath string) error {
	f, err := flac.ParseFile(filepath)
	if err != nil {
		return fmt.Errorf("failed to parse FLAC file: %w", err)
	}

	var cmtIdx = -1
	for idx, block := range f.Meta {
		if block.Type == flac.VorbisComment {
			cmtIdx = idx
			break
		}
	}

	cmt := flacvorbis.New()

	if metadata.Title != "" {
		_ = cmt.Add(flacvorbis.FIELD_TITLE, metadata.Title)
	}
	if metadata.Artist != "" {
		_ = cmt.Add(flacvorbis.FIELD_ARTIST, metadata.Artist)
	}
	if metadata.Album != "" {
		_ = cmt.Add(flacvorbis.FIELD_ALBUM, metadata.Album)
	}
	if metadata.Date != "" {
		_ = cmt.Add(flacvorbis.FIELD_DATE, metadata.Date)
	}
	if metadata.TrackNumber > 0 {
		_ = cmt.Add(flacvorbis.FIELD_TRACKNUMBER, strconv.Itoa(metadata.TrackNumber))
	}
	if metadata.DiscNumber > 0 {
		_ = cmt.Add("DISCNUMBER", strconv.Itoa(metadata.DiscNumber))
	}
	if metadata.ISRC != "" {
		_ = cmt.Add(flacvorbis.FIELD_ISRC, metadata.ISRC)
	}

	cmtBlock := cmt.Marshal()
	if cmtIdx < 0 {
		f.Meta = append(f.Meta, &cmtBlock)
	} else {
		f.Meta[cmtIdx] = &cmtBlock
	}

	if coverPath != "" && fileExists(coverPath) {
		if err := embedCoverArt(f, coverPath); err != nil {
			fmt.Printf("Warning: Failed to embed cover art: %v\n", err)
		}
	}

	if err := f.Save(filepath); err != nil {
		return fmt.Errorf("failed to save FLAC file: %w", err)
	}

	return nil
}

func embedCoverArt(f *flac.File, coverPath string) error {
	imgData, err := os.ReadFile(coverPath)
	if err != nil {
		return fmt.Errorf("failed to read cover image: %w", err)
	}

	picture, err := flacpicture.NewFromImageData(
		flacpicture.PictureTypeFrontCover,
		"Cover",
		imgData,
		"image/jpeg",
	)
	if err != nil {
		return fmt.Errorf("failed to create picture block: %w", err)
	}

	pictureBlock := picture.Marshal()

	for i := len(f.Meta) - 1; i >= 0; i-- {
		if f.Meta[i].Type == flac.Picture {
			f.Meta = append(f.Meta[:i], f.Meta[i+1:]...)
		}
	}

	f.Meta = append(f.Meta, &pictureBlock)

	return nil
}

func fileExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// ReadISRCFromFile reads ISRC metadata from a FLAC file
func ReadISRCFromFile(filepath string) (string, error) {
	if !fileExists(filepath) {
		return "", fmt.Errorf("file does not exist")
	}

	f, err := flac.ParseFile(filepath)
	if err != nil {
		return "", fmt.Errorf("failed to parse FLAC file: %w", err)
	}

	// Find VorbisComment block
	for _, block := range f.Meta {
		if block.Type == flac.VorbisComment {
			cmt, err := flacvorbis.ParseFromMetaDataBlock(*block)
			if err != nil {
				continue
			}

			// Get ISRC field
			isrcValues, err := cmt.Get(flacvorbis.FIELD_ISRC)
			if err == nil && len(isrcValues) > 0 {
				return isrcValues[0], nil
			}
		}
	}

	return "", nil // No ISRC found
}

// CheckISRCExists checks if a file with the given ISRC already exists in the directory
func CheckISRCExists(outputDir string, targetISRC string) (string, bool) {
	if targetISRC == "" {
		return "", false
	}

	// Read all .flac files in directory
	entries, err := os.ReadDir(outputDir)
	if err != nil {
		return "", false
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		// Check only .flac files
		filename := entry.Name()
		if len(filename) < 5 || filename[len(filename)-5:] != ".flac" {
			continue
		}

		filepath := fmt.Sprintf("%s/%s", outputDir, filename)

		// Read ISRC from file
		isrc, err := ReadISRCFromFile(filepath)
		if err != nil {
			continue
		}

		// Compare ISRC (case-insensitive)
		if isrc != "" && strings.EqualFold(isrc, targetISRC) {
			return filepath, true
		}
	}

	return "", false
}

```

## backend/progress.go

```go
package backend

import (
	"fmt"
	"io"
	"sync"
	"time"
)

// Global progress tracker
var (
	currentProgress     float64
	currentProgressLock sync.RWMutex
	isDownloading       bool
	downloadingLock     sync.RWMutex
	currentSpeed        float64
	speedLock           sync.RWMutex
)

// ProgressInfo represents download progress information
type ProgressInfo struct {
	IsDownloading bool    `json:"is_downloading"`
	MBDownloaded  float64 `json:"mb_downloaded"`
	SpeedMBps     float64 `json:"speed_mbps"`
}

// GetDownloadProgress returns current download progress
func GetDownloadProgress() ProgressInfo {
	downloadingLock.RLock()
	downloading := isDownloading
	downloadingLock.RUnlock()

	currentProgressLock.RLock()
	progress := currentProgress
	currentProgressLock.RUnlock()

	speedLock.RLock()
	speed := currentSpeed
	speedLock.RUnlock()

	return ProgressInfo{
		IsDownloading: downloading,
		MBDownloaded:  progress,
		SpeedMBps:     speed,
	}
}

// SetDownloadSpeed updates the current download speed
func SetDownloadSpeed(mbps float64) {
	speedLock.Lock()
	currentSpeed = mbps
	speedLock.Unlock()
}

// SetDownloadProgress updates the current download progress
func SetDownloadProgress(mbDownloaded float64) {
	currentProgressLock.Lock()
	currentProgress = mbDownloaded
	currentProgressLock.Unlock()
}

// SetDownloading sets the downloading state
func SetDownloading(downloading bool) {
	downloadingLock.Lock()
	isDownloading = downloading
	downloadingLock.Unlock()

	if !downloading {
		// Reset progress when download completes
		SetDownloadProgress(0)
		SetDownloadSpeed(0)
	}
}

// ProgressWriter wraps an io.Writer and reports download progress
type ProgressWriter struct {
	writer      io.Writer
	total       int64
	lastPrinted int64
	startTime   int64
	lastTime    int64
	lastBytes   int64
}

func NewProgressWriter(writer io.Writer) *ProgressWriter {
	now := getCurrentTimeMillis()
	return &ProgressWriter{
		writer:      writer,
		total:       0,
		lastPrinted: 0,
		startTime:   now,
		lastTime:    now,
		lastBytes:   0,
	}
}

func getCurrentTimeMillis() int64 {
	return time.Now().UnixMilli()
}

func (pw *ProgressWriter) Write(p []byte) (int, error) {
	n, err := pw.writer.Write(p)
	pw.total += int64(n)

	// Report progress every 256KB for smoother updates
	if pw.total-pw.lastPrinted >= 256*1024 {
		mbDownloaded := float64(pw.total) / (1024 * 1024)

		// Calculate speed (MB/s)
		now := getCurrentTimeMillis()
		timeDiff := float64(now-pw.lastTime) / 1000.0 // seconds
		bytesDiff := float64(pw.total - pw.lastBytes)

		if timeDiff > 0 {
			speedMBps := (bytesDiff / (1024 * 1024)) / timeDiff
			SetDownloadSpeed(speedMBps)
			fmt.Printf("\rDownloaded: %.2f MB (%.2f MB/s)", mbDownloaded, speedMBps)
		} else {
			fmt.Printf("\rDownloaded: %.2f MB", mbDownloaded)
		}

		// Update global progress
		SetDownloadProgress(mbDownloaded)

		pw.lastPrinted = pw.total
		pw.lastTime = now
		pw.lastBytes = pw.total
	}

	return n, err
}

func (pw *ProgressWriter) GetTotal() int64 {
	return pw.total
}

```

## backend/qobuz.go

```go
package backend

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"
)

type QobuzDownloader struct {
	client *http.Client
	appID  string
}

type QobuzSearchResponse struct {
	Query  string `json:"query"`
	Tracks struct {
		Limit  int          `json:"limit"`
		Offset int          `json:"offset"`
		Total  int          `json:"total"`
		Items  []QobuzTrack `json:"items"`
	} `json:"tracks"`
}

type QobuzTrack struct {
	ID                  int64   `json:"id"`
	Title               string  `json:"title"`
	Version             string  `json:"version"`
	Duration            int     `json:"duration"`
	TrackNumber         int     `json:"track_number"`
	MediaNumber         int     `json:"media_number"`
	ISRC                string  `json:"isrc"`
	Copyright           string  `json:"copyright"`
	MaximumBitDepth     int     `json:"maximum_bit_depth"`
	MaximumSamplingRate float64 `json:"maximum_sampling_rate"`
	Hires               bool    `json:"hires"`
	HiresStreamable     bool    `json:"hires_streamable"`
	ReleaseDateOriginal string  `json:"release_date_original"`
	Performer           struct {
		Name string `json:"name"`
		ID   int64  `json:"id"`
	} `json:"performer"`
	Album struct {
		Title string `json:"title"`
		ID    string `json:"id"`
		Image struct {
			Small     string `json:"small"`
			Thumbnail string `json:"thumbnail"`
			Large     string `json:"large"`
		} `json:"image"`
		Artist struct {
			Name string `json:"name"`
			ID   int64  `json:"id"`
		} `json:"artist"`
		Label struct {
			Name string `json:"name"`
		} `json:"label"`
	} `json:"album"`
}

type QobuzStreamResponse struct {
	URL string `json:"url"`
}

func NewQobuzDownloader() *QobuzDownloader {
	return &QobuzDownloader{
		client: &http.Client{
			Timeout: 60 * time.Second,
		},
		appID: "798273057",
	}
}

func (q *QobuzDownloader) SearchByISRC(isrc string) (*QobuzTrack, error) {
	// Decode base64 API URL
	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly93d3cucW9idXouY29tL2FwaS5qc29uLzAuMi90cmFjay9zZWFyY2g/cXVlcnk9")
	url := fmt.Sprintf("%s%s&limit=1&app_id=%s", string(apiBase), isrc, q.appID)

	resp, err := q.client.Get(url)
	if err != nil {
		return nil, fmt.Errorf("failed to search track: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	var searchResp QobuzSearchResponse
	if err := json.NewDecoder(resp.Body).Decode(&searchResp); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	if len(searchResp.Tracks.Items) == 0 {
		return nil, fmt.Errorf("track not found for ISRC: %s", isrc)
	}

	return &searchResp.Tracks.Items[0], nil
}

func (q *QobuzDownloader) GetDownloadURL(trackID int64, quality string) (string, error) {
	// Map quality to Qobuz quality code
	// Qobuz uses: 5 (MP3 320), 6 (FLAC 16-bit), 7 (FLAC 24-bit), 27 (Hi-Res)
	qualityCode := "27" // Default to Hi-Res

	fmt.Printf("Getting download URL for track ID: %d\n", trackID)

	// Decode base64 API URLs
	primaryBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9kYWIueWVldC5zdS9hcGkvc3RyZWFtP3RyYWNrSWQ9")

	// Try primary API first
	primaryURL := fmt.Sprintf("%s%d&quality=%s", string(primaryBase), trackID, qualityCode)

	resp, err := q.client.Get(primaryURL)
	if err == nil && resp.StatusCode == 200 {
		defer resp.Body.Close()

		body, _ := io.ReadAll(resp.Body)
		fmt.Printf("Primary API response: %s\n", string(body))

		var streamResp QobuzStreamResponse
		if err := json.Unmarshal(body, &streamResp); err == nil && streamResp.URL != "" {
			fmt.Printf("Got download URL from primary API\n")
			return streamResp.URL, nil
		}
	}
	if resp != nil {
		resp.Body.Close()
	}

	// Fallback to secondary API
	fmt.Println("Primary API failed, trying fallback...")
	fallbackBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9kYWJtdXNpYy54eXovYXBpL3N0cmVhbT90cmFja0lkPQ==")
	fallbackURL := fmt.Sprintf("%s%d&quality=%s", string(fallbackBase), trackID, qualityCode)

	resp, err = q.client.Get(fallbackURL)
	if err != nil {
		return "", fmt.Errorf("failed to get download URL: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		fmt.Printf("Fallback API error response: %s\n", string(body))
		return "", fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	body, _ := io.ReadAll(resp.Body)
	fmt.Printf("Fallback API response: %s\n", string(body))

	var streamResp QobuzStreamResponse
	if err := json.Unmarshal(body, &streamResp); err != nil {
		return "", fmt.Errorf("failed to decode response: %w", err)
	}

	if streamResp.URL == "" {
		return "", fmt.Errorf("no download URL available")
	}

	fmt.Printf("Got download URL from fallback API\n")
	return streamResp.URL, nil
}

func (q *QobuzDownloader) DownloadFile(url, filepath string) error {
	fmt.Println("Starting file download...")
	resp, err := q.client.Get(url)
	if err != nil {
		return fmt.Errorf("failed to download file: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("download failed with status %d", resp.StatusCode)
	}

	fmt.Printf("Creating file: %s\n", filepath)
	out, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer out.Close()

	fmt.Println("Downloading...")
	// Use progress writer to track download
	pw := NewProgressWriter(out)
	_, err = io.Copy(pw, resp.Body)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	// Print final size
	fmt.Printf("\rDownloaded: %.2f MB (Complete)\n", float64(pw.GetTotal())/(1024*1024))
	return nil
}

func (q *QobuzDownloader) DownloadCoverArt(coverURL, filepath string) error {
	if coverURL == "" {
		return fmt.Errorf("no cover URL provided")
	}

	resp, err := q.client.Get(coverURL)
	if err != nil {
		return fmt.Errorf("failed to download cover: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("cover download failed with status %d", resp.StatusCode)
	}

	out, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("failed to create cover file: %w", err)
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	return err
}

func buildQobuzFilename(title, artist string, trackNumber int, format string, includeTrackNumber bool, position int, useAlbumTrackNumber bool) string {
	var filename string

	// Build base filename based on format
	switch format {
	case "artist-title":
		filename = fmt.Sprintf("%s - %s", artist, title)
	case "title":
		filename = title
	default: // "title-artist"
		filename = fmt.Sprintf("%s - %s", title, artist)
	}

	// Add track number prefix if enabled
	if includeTrackNumber && position > 0 {
		// Use album track number if in album folder structure, otherwise use playlist position
		numberToUse := position
		if useAlbumTrackNumber && trackNumber > 0 {
			numberToUse = trackNumber
		}
		filename = fmt.Sprintf("%02d. %s", numberToUse, filename)
	}

	return filename + ".flac"
}

func (q *QobuzDownloader) DownloadByISRC(isrc, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool) (string, error) {
	fmt.Printf("Fetching track info for ISRC: %s\n", isrc)

	// Create output directory if it doesn't exist
	if outputDir != "." {
		if err := os.MkdirAll(outputDir, 0755); err != nil {
			return "", fmt.Errorf("failed to create output directory: %w", err)
		}
	}

	track, err := q.SearchByISRC(isrc)
	if err != nil {
		return "", err
	}

	// Use Spotify metadata if provided, otherwise fallback to Qobuz metadata
	artists := spotifyArtistName
	trackTitle := spotifyTrackName
	albumTitle := spotifyAlbumName

	if artists == "" {
		artists = track.Performer.Name
		if track.Album.Artist.Name != "" {
			artists = track.Album.Artist.Name
		}
	}

	if trackTitle == "" {
		trackTitle = track.Title
		if track.Version != "" && track.Version != "null" {
			trackTitle = fmt.Sprintf("%s (%s)", track.Title, track.Version)
		}
	}

	if albumTitle == "" {
		albumTitle = track.Album.Title
	}

	fmt.Printf("Found track: %s - %s\n", artists, trackTitle)
	fmt.Printf("Album: %s\n", albumTitle)

	qualityInfo := "Standard"
	if track.Hires {
		qualityInfo = fmt.Sprintf("Hi-Res (%d-bit / %.1f kHz)", track.MaximumBitDepth, track.MaximumSamplingRate)
	}
	fmt.Printf("Quality: %s\n", qualityInfo)

	fmt.Println("Getting download URL...")
	downloadURL, err := q.GetDownloadURL(track.ID, quality)
	if err != nil {
		return "", fmt.Errorf("failed to get download URL: %w", err)
	}

	if downloadURL == "" {
		return "", fmt.Errorf("received empty download URL")
	}

	// Show partial URL for security
	urlPreview := downloadURL
	if len(downloadURL) > 60 {
		urlPreview = downloadURL[:60] + "..."
	}
	fmt.Printf("Download URL obtained: %s\n", urlPreview)

	safeArtist := sanitizeFilename(artists)
	safeTitle := sanitizeFilename(trackTitle)

	// Check if file with same ISRC already exists
	if existingFile, exists := CheckISRCExists(outputDir, track.ISRC); exists {
		fmt.Printf("File with ISRC %s already exists: %s\n", track.ISRC, existingFile)
		return "EXISTS:" + existingFile, nil
	}

	// Build filename based on format settings
	filename := buildQobuzFilename(safeTitle, safeArtist, track.TrackNumber, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	filepath := filepath.Join(outputDir, filename)

	if fileInfo, err := os.Stat(filepath); err == nil && fileInfo.Size() > 0 {
		fmt.Printf("File already exists: %s (%.2f MB)\n", filepath, float64(fileInfo.Size())/(1024*1024))
		return "EXISTS:" + filepath, nil
	}

	fmt.Printf("Downloading FLAC file to: %s\n", filepath)
	if err := q.DownloadFile(downloadURL, filepath); err != nil {
		return "", fmt.Errorf("failed to download file: %w", err)
	}

	fmt.Printf("Downloaded: %s\n", filepath)

	coverPath := ""
	if track.Album.Image.Large != "" {
		coverPath = filepath + ".cover.jpg"
		fmt.Println("Downloading cover art...")
		if err := q.DownloadCoverArt(track.Album.Image.Large, coverPath); err != nil {
			fmt.Printf("Warning: Failed to download cover art: %v\n", err)
		} else {
			defer os.Remove(coverPath)
		}
	}

	fmt.Println("Embedding metadata and cover art...")

	releaseYear := ""
	if len(track.ReleaseDateOriginal) >= 4 {
		releaseYear = track.ReleaseDateOriginal[:4]
	}

	// Use album track number if in album folder structure, otherwise use playlist position
	trackNumberToEmbed := 0
	if position > 0 {
		if useAlbumTrackNumber && track.TrackNumber > 0 {
			trackNumberToEmbed = track.TrackNumber
		} else {
			trackNumberToEmbed = position
		}
	}

	metadata := Metadata{
		Title:       trackTitle,
		Artist:      artists,
		Album:       albumTitle,
		Date:        releaseYear,
		TrackNumber: trackNumberToEmbed,
		DiscNumber:  track.MediaNumber,
		ISRC:        track.ISRC,
	}

	if err := EmbedMetadata(filepath, metadata, coverPath); err != nil {
		return "", fmt.Errorf("failed to embed metadata: %w", err)
	}

	fmt.Println("Metadata embedded successfully!")
	return filepath, nil
}

```

## backend/romaji.go

```go
package backend

import (
	"strings"
	"unicode"
)

// Hiragana to Romaji mapping
var hiraganaToRomaji = map[rune]string{
	'あ': "a", 'い': "i", 'う': "u", 'え': "e", 'お': "o",
	'か': "ka", 'き': "ki", 'く': "ku", 'け': "ke", 'こ': "ko",
	'さ': "sa", 'し': "shi", 'す': "su", 'せ': "se", 'そ': "so",
	'た': "ta", 'ち': "chi", 'つ': "tsu", 'て': "te", 'と': "to",
	'な': "na", 'に': "ni", 'ぬ': "nu", 'ね': "ne", 'の': "no",
	'は': "ha", 'ひ': "hi", 'ふ': "fu", 'へ': "he", 'ほ': "ho",
	'ま': "ma", 'み': "mi", 'む': "mu", 'め': "me", 'も': "mo",
	'や': "ya", 'ゆ': "yu", 'よ': "yo",
	'ら': "ra", 'り': "ri", 'る': "ru", 'れ': "re", 'ろ': "ro",
	'わ': "wa", 'を': "wo", 'ん': "n",
	// Dakuten (voiced)
	'が': "ga", 'ぎ': "gi", 'ぐ': "gu", 'げ': "ge", 'ご': "go",
	'ざ': "za", 'じ': "ji", 'ず': "zu", 'ぜ': "ze", 'ぞ': "zo",
	'だ': "da", 'ぢ': "ji", 'づ': "zu", 'で': "de", 'ど': "do",
	'ば': "ba", 'び': "bi", 'ぶ': "bu", 'べ': "be", 'ぼ': "bo",
	// Handakuten (semi-voiced)
	'ぱ': "pa", 'ぴ': "pi", 'ぷ': "pu", 'ぺ': "pe", 'ぽ': "po",
	// Small characters
	'ゃ': "ya", 'ゅ': "yu", 'ょ': "yo",
	'っ': "", // Double consonant marker
	'ぁ': "a", 'ぃ': "i", 'ぅ': "u", 'ぇ': "e", 'ぉ': "o",
}

// Katakana to Romaji mapping
var katakanaToRomaji = map[rune]string{
	'ア': "a", 'イ': "i", 'ウ': "u", 'エ': "e", 'オ': "o",
	'カ': "ka", 'キ': "ki", 'ク': "ku", 'ケ': "ke", 'コ': "ko",
	'サ': "sa", 'シ': "shi", 'ス': "su", 'セ': "se", 'ソ': "so",
	'タ': "ta", 'チ': "chi", 'ツ': "tsu", 'テ': "te", 'ト': "to",
	'ナ': "na", 'ニ': "ni", 'ヌ': "nu", 'ネ': "ne", 'ノ': "no",
	'ハ': "ha", 'ヒ': "hi", 'フ': "fu", 'ヘ': "he", 'ホ': "ho",
	'マ': "ma", 'ミ': "mi", 'ム': "mu", 'メ': "me", 'モ': "mo",
	'ヤ': "ya", 'ユ': "yu", 'ヨ': "yo",
	'ラ': "ra", 'リ': "ri", 'ル': "ru", 'レ': "re", 'ロ': "ro",
	'ワ': "wa", 'ヲ': "wo", 'ン': "n",
	// Dakuten (voiced)
	'ガ': "ga", 'ギ': "gi", 'グ': "gu", 'ゲ': "ge", 'ゴ': "go",
	'ザ': "za", 'ジ': "ji", 'ズ': "zu", 'ゼ': "ze", 'ゾ': "zo",
	'ダ': "da", 'ヂ': "ji", 'ヅ': "zu", 'デ': "de", 'ド': "do",
	'バ': "ba", 'ビ': "bi", 'ブ': "bu", 'ベ': "be", 'ボ': "bo",
	// Handakuten (semi-voiced)
	'パ': "pa", 'ピ': "pi", 'プ': "pu", 'ペ': "pe", 'ポ': "po",
	// Small characters
	'ャ': "ya", 'ュ': "yu", 'ョ': "yo",
	'ッ': "", // Double consonant marker
	'ァ': "a", 'ィ': "i", 'ゥ': "u", 'ェ': "e", 'ォ': "o",
	// Extended katakana
	'ー': "", // Long vowel mark
	'ヴ': "vu",
}

// Combination mappings for きゃ, しゃ, etc.
var combinationHiragana = map[string]string{
	"きゃ": "kya", "きゅ": "kyu", "きょ": "kyo",
	"しゃ": "sha", "しゅ": "shu", "しょ": "sho",
	"ちゃ": "cha", "ちゅ": "chu", "ちょ": "cho",
	"にゃ": "nya", "にゅ": "nyu", "にょ": "nyo",
	"ひゃ": "hya", "ひゅ": "hyu", "ひょ": "hyo",
	"みゃ": "mya", "みゅ": "myu", "みょ": "myo",
	"りゃ": "rya", "りゅ": "ryu", "りょ": "ryo",
	"ぎゃ": "gya", "ぎゅ": "gyu", "ぎょ": "gyo",
	"じゃ": "ja", "じゅ": "ju", "じょ": "jo",
	"びゃ": "bya", "びゅ": "byu", "びょ": "byo",
	"ぴゃ": "pya", "ぴゅ": "pyu", "ぴょ": "pyo",
}

var combinationKatakana = map[string]string{
	"キャ": "kya", "キュ": "kyu", "キョ": "kyo",
	"シャ": "sha", "シュ": "shu", "ショ": "sho",
	"チャ": "cha", "チュ": "chu", "チョ": "cho",
	"ニャ": "nya", "ニュ": "nyu", "ニョ": "nyo",
	"ヒャ": "hya", "ヒュ": "hyu", "ヒョ": "hyo",
	"ミャ": "mya", "ミュ": "myu", "ミョ": "myo",
	"リャ": "rya", "リュ": "ryu", "リョ": "ryo",
	"ギャ": "gya", "ギュ": "gyu", "ギョ": "gyo",
	"ジャ": "ja", "ジュ": "ju", "ジョ": "jo",
	"ビャ": "bya", "ビュ": "byu", "ビョ": "byo",
	"ピャ": "pya", "ピュ": "pyu", "ピョ": "pyo",
	// Extended combinations
	"ティ": "ti", "ディ": "di", "トゥ": "tu", "ドゥ": "du",
	"ファ": "fa", "フィ": "fi", "フェ": "fe", "フォ": "fo",
	"ウィ": "wi", "ウェ": "we", "ウォ": "wo",
}

// ContainsJapanese checks if a string contains Japanese characters
func ContainsJapanese(s string) bool {
	for _, r := range s {
		if isHiragana(r) || isKatakana(r) || isKanji(r) {
			return true
		}
	}
	return false
}

func isHiragana(r rune) bool {
	return r >= 0x3040 && r <= 0x309F
}

func isKatakana(r rune) bool {
	return r >= 0x30A0 && r <= 0x30FF
}

func isKanji(r rune) bool {
	return (r >= 0x4E00 && r <= 0x9FFF) || // CJK Unified Ideographs
		(r >= 0x3400 && r <= 0x4DBF) // CJK Unified Ideographs Extension A
}

// JapaneseToRomaji converts Japanese text (hiragana/katakana) to romaji
// Note: Kanji cannot be converted without a dictionary, so they are kept as-is
func JapaneseToRomaji(text string) string {
	if !ContainsJapanese(text) {
		return text
	}

	var result strings.Builder
	runes := []rune(text)
	i := 0

	for i < len(runes) {
		// Check for っ/ッ (double consonant)
		if i < len(runes)-1 && (runes[i] == 'っ' || runes[i] == 'ッ') {
			nextRomaji := ""
			if romaji, ok := hiraganaToRomaji[runes[i+1]]; ok {
				nextRomaji = romaji
			} else if romaji, ok := katakanaToRomaji[runes[i+1]]; ok {
				nextRomaji = romaji
			}
			if len(nextRomaji) > 0 {
				result.WriteByte(nextRomaji[0]) // Double the first consonant
			}
			i++
			continue
		}

		// Check for two-character combinations
		if i < len(runes)-1 {
			combo := string(runes[i : i+2])
			if romaji, ok := combinationHiragana[combo]; ok {
				result.WriteString(romaji)
				i += 2
				continue
			}
			if romaji, ok := combinationKatakana[combo]; ok {
				result.WriteString(romaji)
				i += 2
				continue
			}
		}

		// Single character conversion
		r := runes[i]
		if romaji, ok := hiraganaToRomaji[r]; ok {
			result.WriteString(romaji)
		} else if romaji, ok := katakanaToRomaji[r]; ok {
			result.WriteString(romaji)
		} else if isKanji(r) {
			// Keep kanji as-is (would need dictionary for proper conversion)
			result.WriteRune(r)
		} else {
			// Keep other characters (punctuation, spaces, etc.)
			result.WriteRune(r)
		}
		i++
	}

	return result.String()
}

// BuildSearchQuery creates a search query from track name and artist
// Converts Japanese to romaji if present
func BuildSearchQuery(trackName, artistName string) string {
	// Convert Japanese to romaji
	trackRomaji := JapaneseToRomaji(trackName)
	artistRomaji := JapaneseToRomaji(artistName)

	// Clean up the query - remove special characters that might interfere with search
	trackClean := cleanSearchQuery(trackRomaji)
	artistClean := cleanSearchQuery(artistRomaji)

	return strings.TrimSpace(artistClean + " " + trackClean)
}

// cleanSearchQuery removes special characters that might interfere with search
func cleanSearchQuery(s string) string {
	var result strings.Builder
	for _, r := range s {
		if unicode.IsLetter(r) || unicode.IsNumber(r) || unicode.IsSpace(r) {
			result.WriteRune(r)
		} else if r == '-' || r == '\'' {
			result.WriteRune(r)
		}
	}
	return strings.TrimSpace(result.String())
}

// cleanToASCII removes all non-ASCII characters and keeps only letters, numbers, spaces
// This is useful for creating search queries that work better with Tidal's search
func cleanToASCII(s string) string {
	var result strings.Builder
	for _, r := range s {
		// Keep only ASCII letters, numbers, spaces, and basic punctuation
		if (r >= 'a' && r <= 'z') || (r >= 'A' && r <= 'Z') ||
			(r >= '0' && r <= '9') || r == ' ' || r == '-' || r == '\'' {
			result.WriteRune(r)
		} else if r == ',' || r == '.' {
			// Convert punctuation to space
			result.WriteRune(' ')
		}
	}
	// Clean up multiple spaces
	cleaned := strings.Join(strings.Fields(result.String()), " ")
	return strings.TrimSpace(cleaned)
}

```

## backend/songlink.go

```go
package backend

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"time"
)

type SongLinkClient struct {
	client           *http.Client
	lastAPICallTime  time.Time
	apiCallCount     int
	apiCallResetTime time.Time
}

type SongLinkURLs struct {
	TidalURL  string `json:"tidal_url"`
	DeezerURL string `json:"deezer_url"`
	AmazonURL string `json:"amazon_url"`
}

// TrackAvailability represents the availability of a track on different platforms
type TrackAvailability struct {
	SpotifyID string `json:"spotify_id"`
	Tidal     bool   `json:"tidal"`
	Deezer    bool   `json:"deezer"`
	Amazon    bool   `json:"amazon"`
	Qobuz     bool   `json:"qobuz"`
	TidalURL  string `json:"tidal_url,omitempty"`
	DeezerURL string `json:"deezer_url,omitempty"`
	AmazonURL string `json:"amazon_url,omitempty"`
	QobuzURL  string `json:"qobuz_url,omitempty"`
}

func NewSongLinkClient() *SongLinkClient {
	return &SongLinkClient{
		client: &http.Client{
			Timeout: 30 * time.Second,
		},
		apiCallResetTime: time.Now(),
	}
}

func (s *SongLinkClient) GetAllURLsFromSpotify(spotifyTrackID string) (*SongLinkURLs, error) {
	// Rate limiting: max 10 requests per minute (song.link API limit)
	now := time.Now()
	if now.Sub(s.apiCallResetTime) >= time.Minute {
		s.apiCallCount = 0
		s.apiCallResetTime = now
	}

	// If we've hit the limit, wait until the next minute
	if s.apiCallCount >= 9 {
		waitTime := time.Minute - now.Sub(s.apiCallResetTime)
		if waitTime > 0 {
			fmt.Printf("Rate limit reached, waiting %v...\n", waitTime.Round(time.Second))
			time.Sleep(waitTime)
			s.apiCallCount = 0
			s.apiCallResetTime = time.Now()
		}
	}

	// Add delay between requests (7 seconds to be safe)
	if !s.lastAPICallTime.IsZero() {
		timeSinceLastCall := now.Sub(s.lastAPICallTime)
		minDelay := 7 * time.Second
		if timeSinceLastCall < minDelay {
			waitTime := minDelay - timeSinceLastCall
			fmt.Printf("Rate limiting: waiting %v...\n", waitTime.Round(time.Second))
			time.Sleep(waitTime)
		}
	}

	// Decode base64 API URL
	spotifyBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9vcGVuLnNwb3RpZnkuY29tL3RyYWNrLw==")
	spotifyURL := fmt.Sprintf("%s%s", string(spotifyBase), spotifyTrackID)

	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hcGkuc29uZy5saW5rL3YxLWFscGhhLjEvbGlua3M/dXJsPQ==")
	apiURL := fmt.Sprintf("%s%s", string(apiBase), url.QueryEscape(spotifyURL))

	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	fmt.Println("Getting streaming URLs from song.link...")

	// Retry logic for rate limit errors
	maxRetries := 3
	var resp *http.Response
	for i := 0; i < maxRetries; i++ {
		resp, err = s.client.Do(req)
		if err != nil {
			return nil, fmt.Errorf("failed to get URLs: %w", err)
		}

		// Update rate limit tracking
		s.lastAPICallTime = time.Now()
		s.apiCallCount++

		if resp.StatusCode == 429 {
			resp.Body.Close()
			if i < maxRetries-1 {
				waitTime := 15 * time.Second
				fmt.Printf("Rate limited by API, waiting %v before retry...\n", waitTime)
				time.Sleep(waitTime)
				continue
			}
			return nil, fmt.Errorf("API rate limit exceeded after %d retries", maxRetries)
		}

		if resp.StatusCode != 200 {
			resp.Body.Close()
			return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
		}

		break
	}
	defer resp.Body.Close()

	var songLinkResp struct {
		LinksByPlatform map[string]struct {
			URL string `json:"url"`
		} `json:"linksByPlatform"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&songLinkResp); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	urls := &SongLinkURLs{}

	// Extract Tidal URL
	if tidalLink, ok := songLinkResp.LinksByPlatform["tidal"]; ok && tidalLink.URL != "" {
		urls.TidalURL = tidalLink.URL
		fmt.Printf("✓ Tidal URL found\n")
	}

	// Extract Deezer URL
	if deezerLink, ok := songLinkResp.LinksByPlatform["deezer"]; ok && deezerLink.URL != "" {
		urls.DeezerURL = deezerLink.URL
		fmt.Printf("✓ Deezer URL found\n")
	}

	// Extract Amazon URL
	if amazonLink, ok := songLinkResp.LinksByPlatform["amazonMusic"]; ok && amazonLink.URL != "" {
		amazonURL := amazonLink.URL
		// Convert album URL to track URL if needed
		if len(amazonURL) > 0 {
			urls.AmazonURL = amazonURL
			fmt.Printf("✓ Amazon URL found\n")
		}
	}

	// Check if at least one URL was found
	if urls.TidalURL == "" && urls.DeezerURL == "" && urls.AmazonURL == "" {
		return nil, fmt.Errorf("no streaming URLs found")
	}

	return urls, nil
}

// CheckTrackAvailability checks the availability of a track on different platforms
func (s *SongLinkClient) CheckTrackAvailability(spotifyTrackID string, isrc string) (*TrackAvailability, error) {
	// Rate limiting: max 10 requests per minute (song.link API limit)
	now := time.Now()
	if now.Sub(s.apiCallResetTime) >= time.Minute {
		s.apiCallCount = 0
		s.apiCallResetTime = now
	}

	// If we've hit the limit, wait until the next minute
	if s.apiCallCount >= 9 {
		waitTime := time.Minute - now.Sub(s.apiCallResetTime)
		if waitTime > 0 {
			fmt.Printf("Rate limit reached, waiting %v...\n", waitTime.Round(time.Second))
			time.Sleep(waitTime)
			s.apiCallCount = 0
			s.apiCallResetTime = time.Now()
		}
	}

	// Add delay between requests (7 seconds to be safe)
	if !s.lastAPICallTime.IsZero() {
		timeSinceLastCall := now.Sub(s.lastAPICallTime)
		minDelay := 7 * time.Second
		if timeSinceLastCall < minDelay {
			waitTime := minDelay - timeSinceLastCall
			fmt.Printf("Rate limiting: waiting %v...\n", waitTime.Round(time.Second))
			time.Sleep(waitTime)
		}
	}

	// Decode base64 API URL
	spotifyBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9vcGVuLnNwb3RpZnkuY29tL3RyYWNrLw==")
	spotifyURL := fmt.Sprintf("%s%s", string(spotifyBase), spotifyTrackID)

	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hcGkuc29uZy5saW5rL3YxLWFscGhhLjEvbGlua3M/dXJsPQ==")
	apiURL := fmt.Sprintf("%s%s", string(apiBase), url.QueryEscape(spotifyURL))

	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	fmt.Printf("Checking availability for track: %s\n", spotifyTrackID)

	// Retry logic for rate limit errors
	maxRetries := 3
	var resp *http.Response
	for i := 0; i < maxRetries; i++ {
		resp, err = s.client.Do(req)
		if err != nil {
			return nil, fmt.Errorf("failed to check availability: %w", err)
		}

		// Update rate limit tracking
		s.lastAPICallTime = time.Now()
		s.apiCallCount++

		if resp.StatusCode == 429 {
			resp.Body.Close()
			if i < maxRetries-1 {
				waitTime := 15 * time.Second
				fmt.Printf("Rate limited by API, waiting %v before retry...\n", waitTime)
				time.Sleep(waitTime)
				continue
			}
			return nil, fmt.Errorf("API rate limit exceeded after %d retries", maxRetries)
		}

		if resp.StatusCode != 200 {
			resp.Body.Close()
			return nil, fmt.Errorf("API returned status %d", resp.StatusCode)
		}

		break
	}
	defer resp.Body.Close()

	var songLinkResp struct {
		LinksByPlatform map[string]struct {
			URL string `json:"url"`
		} `json:"linksByPlatform"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&songLinkResp); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	availability := &TrackAvailability{
		SpotifyID: spotifyTrackID,
	}

	// Check Tidal
	if tidalLink, ok := songLinkResp.LinksByPlatform["tidal"]; ok && tidalLink.URL != "" {
		availability.Tidal = true
		availability.TidalURL = tidalLink.URL
	}

	// Check Deezer
	if deezerLink, ok := songLinkResp.LinksByPlatform["deezer"]; ok && deezerLink.URL != "" {
		availability.Deezer = true
		availability.DeezerURL = deezerLink.URL
	}

	// Check Amazon
	if amazonLink, ok := songLinkResp.LinksByPlatform["amazonMusic"]; ok && amazonLink.URL != "" {
		availability.Amazon = true
		availability.AmazonURL = amazonLink.URL
	}

	// Check Qobuz using ISRC (song.link doesn't support Qobuz)
	if isrc != "" {
		qobuzAvailable := checkQobuzAvailability(isrc)
		availability.Qobuz = qobuzAvailable
	}

	return availability, nil
}

// checkQobuzAvailability checks if a track is available on Qobuz using ISRC
func checkQobuzAvailability(isrc string) bool {
	client := &http.Client{Timeout: 10 * time.Second}
	appID := "798273057"

	// Decode base64 API URL
	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly93d3cucW9idXouY29tL2FwaS5qc29uLzAuMi90cmFjay9zZWFyY2g/cXVlcnk9")
	searchURL := fmt.Sprintf("%s%s&limit=1&app_id=%s", string(apiBase), isrc, appID)

	resp, err := client.Get(searchURL)
	if err != nil {
		return false
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return false
	}

	var searchResp struct {
		Tracks struct {
			Total int `json:"total"`
		} `json:"tracks"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&searchResp); err != nil {
		return false
	}

	return searchResp.Tracks.Total > 0
}

```

## backend/spectrum.go

```go
package backend

import (
	"fmt"
	"math"
	"math/cmplx"

	"github.com/mewkiz/flac"
)

// SpectrumData contains frequency spectrum information
type SpectrumData struct {
	TimeSlices []TimeSlice `json:"time_slices"`
	SampleRate int         `json:"sample_rate"`
	FreqBins   int         `json:"freq_bins"`
	Duration   float64     `json:"duration"`
	MaxFreq    float64     `json:"max_freq"`
}

// TimeSlice represents spectrum data at a point in time
type TimeSlice struct {
	Time       float64   `json:"time"`
	Magnitudes []float64 `json:"magnitudes"`
}

// AnalyzeSpectrum decodes FLAC file and performs FFT analysis
func AnalyzeSpectrum(filepath string) (*SpectrumData, error) {
	// Open FLAC file
	stream, err := flac.ParseFile(filepath)
	if err != nil {
		return nil, fmt.Errorf("failed to parse FLAC: %w", err)
	}
	defer stream.Close()

	info := stream.Info
	sampleRate := int(info.SampleRate)
	channels := int(info.NChannels)

	// Read audio samples
	samples, err := readSamples(stream, channels)
	if err != nil {
		return nil, fmt.Errorf("failed to read samples: %w", err)
	}

	if len(samples) == 0 {
		return nil, fmt.Errorf("no audio samples found")
	}

	// Calculate spectrum
	return calculateSpectrum(samples, sampleRate), nil
}

// readSamples reads and decodes audio samples from FLAC stream
func readSamples(stream *flac.Stream, channels int) ([]float64, error) {
	var allSamples []float64
	maxSamples := 10 * 1024 * 1024 // Limit to ~10 million samples to avoid memory issues

	// Decode frames
	for {
		frame, err := stream.ParseNext()
		if err != nil {
			// End of stream
			break
		}

		// Convert samples to float64 and mix channels to mono
		for i := 0; i < frame.Subframes[0].NSamples; i++ {
			var sample float64

			// Mix all channels to mono by averaging
			for ch := 0; ch < channels; ch++ {
				sample += float64(frame.Subframes[ch].Samples[i])
			}
			sample /= float64(channels)

			allSamples = append(allSamples, sample)

			// Limit sample count
			if len(allSamples) >= maxSamples {
				return allSamples, nil
			}
		}
	}

	return allSamples, nil
}

// calculateSpectrum performs FFT analysis on audio samples
func calculateSpectrum(samples []float64, sampleRate int) *SpectrumData {
	fftSize := 8192
	numTimeSlices := 300

	duration := float64(len(samples)) / float64(sampleRate)

	samplesPerSlice := len(samples) / numTimeSlices
	if samplesPerSlice < fftSize {
		samplesPerSlice = fftSize
		numTimeSlices = len(samples) / fftSize
	}

	timeSlices := make([]TimeSlice, 0, numTimeSlices)
	freqBins := fftSize / 2
	maxFreq := float64(sampleRate) / 2.0

	for i := 0; i < numTimeSlices; i++ {
		startIdx := i * samplesPerSlice
		if startIdx+fftSize > len(samples) {
			break
		}

		window := samples[startIdx : startIdx+fftSize]

		windowedSamples := applyHannWindow(window)

		spectrum := fft(windowedSamples)

		magnitudes := make([]float64, freqBins)
		for j := 0; j < freqBins; j++ {
			magnitude := cmplx.Abs(spectrum[j])

			if magnitude < 1e-10 {
				magnitude = 1e-10
			}
			magnitudes[j] = 20 * math.Log10(magnitude)
		}

		timeSlice := TimeSlice{
			Time:       float64(startIdx) / float64(sampleRate),
			Magnitudes: magnitudes,
		}
		timeSlices = append(timeSlices, timeSlice)
	}

	return &SpectrumData{
		TimeSlices: timeSlices,
		SampleRate: sampleRate,
		FreqBins:   freqBins,
		Duration:   duration,
		MaxFreq:    maxFreq,
	}
}

// applyHannWindow applies Hann window to reduce spectral leakage
func applyHannWindow(samples []float64) []float64 {
	n := len(samples)
	windowed := make([]float64, n)

	for i := 0; i < n; i++ {
		window := 0.5 * (1.0 - math.Cos(2.0*math.Pi*float64(i)/float64(n-1)))
		windowed[i] = samples[i] * window
	}

	return windowed
}

// fft performs Fast Fourier Transform using Cooley-Tukey algorithm
func fft(samples []float64) []complex128 {
	n := len(samples)

	x := make([]complex128, n)
	for i := 0; i < n; i++ {
		x[i] = complex(samples[i], 0)
	}

	return fftRecursive(x)
}

// fftRecursive performs recursive FFT
func fftRecursive(x []complex128) []complex128 {
	n := len(x)

	if n <= 1 {
		return x
	}

	even := make([]complex128, n/2)
	odd := make([]complex128, n/2)

	for i := 0; i < n/2; i++ {
		even[i] = x[2*i]
		odd[i] = x[2*i+1]
	}

	evenFFT := fftRecursive(even)
	oddFFT := fftRecursive(odd)

	result := make([]complex128, n)
	for k := 0; k < n/2; k++ {
		t := cmplx.Exp(complex(0, -2*math.Pi*float64(k)/float64(n))) * oddFFT[k]
		result[k] = evenFFT[k] + t
		result[k+n/2] = evenFFT[k] - t
	}

	return result
}

```

## backend/spotify_metadata.go

```go
package backend

import (
	"context"
	"crypto/hmac"
	"crypto/sha1"
	"encoding/base32"
	"encoding/binary"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"time"
)

const (
	spotifyTokenURL       = "https://open.spotify.com/api/token"
	playlistBaseURL       = "https://api.spotify.com/v1/playlists/%s"
	albumBaseURL          = "https://api.spotify.com/v1/albums/%s"
	trackBaseURL          = "https://api.spotify.com/v1/tracks/%s"
	artistBaseURL         = "https://api.spotify.com/v1/artists/%s"
	artistAlbumsBaseURL   = "https://api.spotify.com/v1/artists/%s/albums"
	secretBytesRemotePath = "https://cdn.jsdelivr.net/gh/afkarxyz/secretBytes@refs/heads/main/secrets/secretBytes.json"
)

var (
	errInvalidSpotifyURL = errors.New("invalid or unsupported Spotify URL")
)

// SpotifyMetadataClient mirrors the behaviour of Doc/getMetadata.py and interacts with Spotify's web API.
type SpotifyMetadataClient struct {
	httpClient *http.Client
	rng        *rand.Rand
	rngMu      sync.Mutex
	userAgent  string
}

// NewSpotifyMetadataClient creates a ready-to-use client with sane defaults.
func NewSpotifyMetadataClient() *SpotifyMetadataClient {
	src := rand.NewSource(time.Now().UnixNano())
	c := &SpotifyMetadataClient{
		httpClient: &http.Client{Timeout: 15 * time.Second},
		rng:        rand.New(src),
	}
	c.userAgent = c.randomUserAgent()
	return c
}

// TrackMetadata mirrors the filtered track payload returned by the Python script.
type TrackMetadata struct {
	Artists     string `json:"artists"`
	Name        string `json:"name"`
	AlbumName   string `json:"album_name"`
	DurationMS  int    `json:"duration_ms"`
	Images      string `json:"images"`
	ReleaseDate string `json:"release_date"`
	TrackNumber int    `json:"track_number"`
	ExternalURL string `json:"external_urls"`
	ISRC        string `json:"isrc"`
	SpotifyID   string `json:"spotify_id,omitempty"`
}

// ArtistSimple holds basic artist info for clickable artists
type ArtistSimple struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	ExternalURL string `json:"external_urls"`
}

// AlbumTrackMetadata holds per-track info for album / playlist formatting.
type AlbumTrackMetadata struct {
	Artists     string         `json:"artists"`
	Name        string         `json:"name"`
	AlbumName   string         `json:"album_name"`
	DurationMS  int            `json:"duration_ms"`
	Images      string         `json:"images"`
	ReleaseDate string         `json:"release_date"`
	TrackNumber int            `json:"track_number"`
	ExternalURL string         `json:"external_urls"`
	ISRC        string         `json:"isrc"`
	AlbumType   string         `json:"album_type,omitempty"`
	SpotifyID   string         `json:"spotify_id,omitempty"`
	AlbumID     string         `json:"album_id,omitempty"`
	AlbumURL    string         `json:"album_url,omitempty"`
	ArtistID    string         `json:"artist_id,omitempty"`
	ArtistURL   string         `json:"artist_url,omitempty"`
	ArtistsData []ArtistSimple `json:"artists_data,omitempty"`
}

type TrackResponse struct {
	Track TrackMetadata `json:"track"`
}

type AlbumInfoMetadata struct {
	TotalTracks int    `json:"total_tracks"`
	Name        string `json:"name"`
	ReleaseDate string `json:"release_date"`
	Artists     string `json:"artists"`
	Images      string `json:"images"`
	Batch       string `json:"batch,omitempty"`
	ArtistID    string `json:"artist_id,omitempty"`
	ArtistURL   string `json:"artist_url,omitempty"`
}

type AlbumResponsePayload struct {
	AlbumInfo AlbumInfoMetadata    `json:"album_info"`
	TrackList []AlbumTrackMetadata `json:"track_list"`
}

type PlaylistInfoMetadata struct {
	Tracks struct {
		Total int `json:"total"`
	} `json:"tracks"`
	Followers struct {
		Total int `json:"total"`
	} `json:"followers"`
	Owner struct {
		DisplayName string `json:"display_name"`
		Name        string `json:"name"`
		Images      string `json:"images"`
	} `json:"owner"`
	Batch string `json:"batch,omitempty"`
}

type PlaylistResponsePayload struct {
	PlaylistInfo PlaylistInfoMetadata `json:"playlist_info"`
	TrackList    []AlbumTrackMetadata `json:"track_list"`
}

type ArtistInfoMetadata struct {
	Name            string   `json:"name"`
	Followers       int      `json:"followers"`
	Genres          []string `json:"genres"`
	Images          string   `json:"images"`
	ExternalURL     string   `json:"external_urls"`
	DiscographyType string   `json:"discography_type"`
	TotalAlbums     int      `json:"total_albums"`
	Batch           string   `json:"batch,omitempty"`
}

type DiscographyAlbumMetadata struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	AlbumType   string `json:"album_type"`
	ReleaseDate string `json:"release_date"`
	TotalTracks int    `json:"total_tracks"`
	Artists     string `json:"artists"`
	Images      string `json:"images"`
	ExternalURL string `json:"external_urls"`
}

type ArtistDiscographyPayload struct {
	ArtistInfo ArtistInfoMetadata         `json:"artist_info"`
	AlbumList  []DiscographyAlbumMetadata `json:"album_list"`
	TrackList  []AlbumTrackMetadata       `json:"track_list"`
}

type ArtistResponsePayload struct {
	Artist struct {
		Name        string   `json:"name"`
		Followers   int      `json:"followers"`
		Genres      []string `json:"genres"`
		Images      string   `json:"images"`
		ExternalURL string   `json:"external_urls"`
		Popularity  int      `json:"popularity"`
	} `json:"artist"`
}

type spotifyURI struct {
	Type             string
	ID               string
	DiscographyGroup string
}

type secretEntry struct {
	Version int   `json:"version"`
	Secret  []int `json:"secret"`
}

type serverTimeResponse struct {
	ServerTime int64 `json:"serverTime"`
}

type accessTokenResponse struct {
	AccessToken string `json:"accessToken"`
}

type image struct {
	URL string `json:"url"`
}

type externalURL struct {
	Spotify string `json:"spotify"`
}

type externalID struct {
	ISRC string `json:"isrc"`
}

type artist struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type albumSimplified struct {
	ID          string      `json:"id"`
	Name        string      `json:"name"`
	AlbumType   string      `json:"album_type"`
	ReleaseDate string      `json:"release_date"`
	TotalTracks int         `json:"total_tracks"`
	Images      []image     `json:"images"`
	ExternalURL externalURL `json:"external_urls"`
	Artists     []artist    `json:"artists"`
}

type trackSimplified struct {
	ID          string      `json:"id"`
	Name        string      `json:"name"`
	DurationMS  int         `json:"duration_ms"`
	TrackNumber int         `json:"track_number"`
	ExternalURL externalURL `json:"external_urls"`
	Artists     []artist    `json:"artists"`
}

type trackFull struct {
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	DurationMS  int             `json:"duration_ms"`
	TrackNumber int             `json:"track_number"`
	ExternalURL externalURL     `json:"external_urls"`
	ExternalID  externalID      `json:"external_ids"`
	Album       albumSimplified `json:"album"`
	Artists     []artist        `json:"artists"`
}

type playlistTrackItem struct {
	Track *trackFull `json:"track"`
}

type playlistResponse struct {
	Name   string  `json:"name"`
	Images []image `json:"images"`
	Owner  struct {
		DisplayName string `json:"display_name"`
	} `json:"owner"`
	Followers struct {
		Total int `json:"total"`
	} `json:"followers"`
	Tracks struct {
		Items []playlistTrackItem `json:"items"`
		Next  string              `json:"next"`
		Total int                 `json:"total"`
	} `json:"tracks"`
}

type albumResponse struct {
	Name        string   `json:"name"`
	ReleaseDate string   `json:"release_date"`
	TotalTracks int      `json:"total_tracks"`
	Images      []image  `json:"images"`
	Artists     []artist `json:"artists"`
	Tracks      struct {
		Items []trackSimplified `json:"items"`
		Next  string            `json:"next"`
	} `json:"tracks"`
}

type artistResponse struct {
	Name      string `json:"name"`
	Followers struct {
		Total int `json:"total"`
	} `json:"followers"`
	Genres      []string    `json:"genres"`
	Images      []image     `json:"images"`
	ExternalURL externalURL `json:"external_urls"`
	Popularity  int         `json:"popularity"`
}

type playlistRaw struct {
	Data         playlistResponse
	BatchEnabled bool
	BatchCount   int
}

type albumRaw struct {
	Data         albumResponse
	Token        string
	BatchEnabled bool
	BatchCount   int
}

type discographyRaw struct {
	Artist       artistResponse
	Albums       []albumSimplified
	Token        string
	Discography  string
	BatchEnabled bool
	BatchCount   int
}

// GetFilteredSpotifyData is a convenience wrapper that mirrors the Python module's entry point.
func GetFilteredSpotifyData(ctx context.Context, spotifyURL string, batch bool, delay time.Duration) (interface{}, error) {
	client := NewSpotifyMetadataClient()
	return client.GetFilteredData(ctx, spotifyURL, batch, delay)
}

// GetFilteredData fetches, normalises, and formats Spotify payloads for the given URL.
func (c *SpotifyMetadataClient) GetFilteredData(ctx context.Context, spotifyURL string, batch bool, delay time.Duration) (interface{}, error) {
	parsed, err := parseSpotifyURI(spotifyURL)
	if err != nil {
		return nil, err
	}

	token, err := c.getAccessToken(ctx)
	if err != nil {
		return nil, err
	}

	raw, err := c.getRawSpotifyData(ctx, parsed, token, batch, delay)
	if err != nil {
		return nil, err
	}

	return c.processSpotifyData(ctx, raw)
}

func (c *SpotifyMetadataClient) getRawSpotifyData(ctx context.Context, parsed spotifyURI, token string, batch bool, delay time.Duration) (interface{}, error) {
	switch parsed.Type {
	case "playlist":
		return c.fetchPlaylist(ctx, parsed.ID, token, batch, delay)
	case "album":
		return c.fetchAlbum(ctx, parsed.ID, token, batch, delay)
	case "track":
		return c.fetchTrack(ctx, parsed.ID, token)
	case "artist_discography":
		return c.fetchArtistDiscography(ctx, parsed, token, batch, delay)
	case "artist":
		return c.fetchArtist(ctx, parsed.ID, token)
	default:
		return nil, fmt.Errorf("unsupported Spotify type: %s", parsed.Type)
	}
}

func (c *SpotifyMetadataClient) processSpotifyData(ctx context.Context, raw interface{}) (interface{}, error) {
	switch payload := raw.(type) {
	case *playlistRaw:
		return c.formatPlaylistData(payload), nil
	case *albumRaw:
		return c.formatAlbumData(ctx, payload)
	case *trackFull:
		trackPayload := formatTrackData(payload)
		return trackPayload, nil
	case *discographyRaw:
		return c.formatArtistDiscographyData(ctx, payload)
	case *artistResponse:
		formatted := formatArtistData(payload)
		return formatted, nil
	default:
		return nil, errors.New("unknown raw payload type")
	}
}

func (c *SpotifyMetadataClient) fetchPlaylist(ctx context.Context, playlistID, token string, batch bool, delay time.Duration) (*playlistRaw, error) {
	var data playlistResponse
	if err := c.getJSON(ctx, fmt.Sprintf(playlistBaseURL, playlistID), token, &data); err != nil {
		return nil, err
	}

	tracksURL := fmt.Sprintf("https://api.spotify.com/v1/playlists/%s/tracks?limit=100", playlistID)
	var items []playlistTrackItem
	batchDelay := time.Duration(0)
	if batch {
		batchDelay = delay
	}
	batches, err := fetchPaging(ctx, c, tracksURL, token, batchDelay, &items)
	if err != nil {
		return nil, err
	}
	if len(items) > 0 {
		data.Tracks.Items = items
	}

	return &playlistRaw{
		Data:         data,
		BatchEnabled: batch,
		BatchCount:   batches,
	}, nil
}

func (c *SpotifyMetadataClient) fetchAlbum(ctx context.Context, albumID, token string, batch bool, delay time.Duration) (*albumRaw, error) {
	var data albumResponse
	if err := c.getJSON(ctx, fmt.Sprintf(albumBaseURL, albumID), token, &data); err != nil {
		return nil, err
	}

	tracksURL := fmt.Sprintf("%s/tracks?limit=50", fmt.Sprintf(albumBaseURL, albumID))
	var items []trackSimplified
	batchDelay := time.Duration(0)
	if batch {
		batchDelay = delay
	}
	batches, err := fetchPaging(ctx, c, tracksURL, token, batchDelay, &items)
	if err != nil {
		return nil, err
	}
	if len(items) > 0 {
		data.Tracks.Items = items
	}

	return &albumRaw{
		Data:         data,
		Token:        token,
		BatchEnabled: batch,
		BatchCount:   batches,
	}, nil
}

func (c *SpotifyMetadataClient) fetchTrack(ctx context.Context, trackID, token string) (*trackFull, error) {
	var data trackFull
	if err := c.getJSON(ctx, fmt.Sprintf(trackBaseURL, trackID), token, &data); err != nil {
		return nil, err
	}
	return &data, nil
}

func (c *SpotifyMetadataClient) fetchArtistDiscography(ctx context.Context, parsed spotifyURI, token string, batch bool, delay time.Duration) (*discographyRaw, error) {
	var artistData artistResponse
	if err := c.getJSON(ctx, fmt.Sprintf(artistBaseURL, parsed.ID), token, &artistData); err != nil {
		return nil, err
	}

	includeGroups := parsed.DiscographyGroup
	if includeGroups == "" || includeGroups == "all" {
		includeGroups = "album,single,compilation"
	}

	albumsURL := fmt.Sprintf("%s?include_groups=%s&limit=50", fmt.Sprintf(artistAlbumsBaseURL, parsed.ID), includeGroups)
	var albums []albumSimplified
	batchDelay := time.Duration(0)
	if batch {
		batchDelay = delay
	}
	batches, err := fetchPaging(ctx, c, albumsURL, token, batchDelay, &albums)
	if err != nil {
		return nil, err
	}

	return &discographyRaw{
		Artist:       artistData,
		Albums:       albums,
		Token:        token,
		Discography:  parsed.DiscographyGroup,
		BatchEnabled: batch,
		BatchCount:   batches,
	}, nil
}

func (c *SpotifyMetadataClient) fetchArtist(ctx context.Context, artistID, token string) (*artistResponse, error) {
	var artistData artistResponse
	if err := c.getJSON(ctx, fmt.Sprintf(artistBaseURL, artistID), token, &artistData); err != nil {
		return nil, err
	}
	return &artistData, nil
}

func (c *SpotifyMetadataClient) formatPlaylistData(raw *playlistRaw) PlaylistResponsePayload {
	var info PlaylistInfoMetadata
	info.Tracks.Total = raw.Data.Tracks.Total
	info.Followers.Total = raw.Data.Followers.Total
	info.Owner.DisplayName = raw.Data.Owner.DisplayName
	info.Owner.Name = raw.Data.Name
	info.Owner.Images = firstImageURL(raw.Data.Images)
	if raw.BatchEnabled {
		info.Batch = strconv.Itoa(maxInt(1, raw.BatchCount))
	}

	tracks := make([]AlbumTrackMetadata, 0, len(raw.Data.Tracks.Items))
	for _, item := range raw.Data.Tracks.Items {
		if item.Track == nil {
			continue
		}
		var artistID, artistURL string
		if len(item.Track.Artists) > 0 {
			artistID = item.Track.Artists[0].ID
			artistURL = fmt.Sprintf("https://open.spotify.com/artist/%s", item.Track.Artists[0].ID)
		}
		artistsData := make([]ArtistSimple, 0, len(item.Track.Artists))
		for _, a := range item.Track.Artists {
			artistsData = append(artistsData, ArtistSimple{
				ID:          a.ID,
				Name:        a.Name,
				ExternalURL: fmt.Sprintf("https://open.spotify.com/artist/%s", a.ID),
			})
		}
		tracks = append(tracks, AlbumTrackMetadata{
			Artists:     joinArtists(item.Track.Artists),
			Name:        item.Track.Name,
			AlbumName:   item.Track.Album.Name,
			DurationMS:  item.Track.DurationMS,
			Images:      firstNonEmpty(firstImageURL(item.Track.Album.Images), info.Owner.Images),
			ReleaseDate: item.Track.Album.ReleaseDate,
			TrackNumber: item.Track.TrackNumber,
			ExternalURL: item.Track.ExternalURL.Spotify,
			ISRC:        item.Track.ExternalID.ISRC,
			SpotifyID:   item.Track.ID,
			AlbumID:     item.Track.Album.ID,
			AlbumURL:    item.Track.Album.ExternalURL.Spotify,
			ArtistID:    artistID,
			ArtistURL:   artistURL,
			ArtistsData: artistsData,
		})
	}

	return PlaylistResponsePayload{
		PlaylistInfo: info,
		TrackList:    tracks,
	}
}

func (c *SpotifyMetadataClient) formatAlbumData(ctx context.Context, raw *albumRaw) (*AlbumResponsePayload, error) {
	albumImage := firstImageURL(raw.Data.Images)
	var artistID, artistURL string
	if len(raw.Data.Artists) > 0 {
		artistID = raw.Data.Artists[0].ID
		artistURL = fmt.Sprintf("https://open.spotify.com/artist/%s", raw.Data.Artists[0].ID)
	}
	info := AlbumInfoMetadata{
		TotalTracks: raw.Data.TotalTracks,
		Name:        raw.Data.Name,
		ReleaseDate: raw.Data.ReleaseDate,
		Artists:     joinArtists(raw.Data.Artists),
		Images:      albumImage,
		ArtistID:    artistID,
		ArtistURL:   artistURL,
	}
	if raw.BatchEnabled {
		info.Batch = strconv.Itoa(maxInt(1, raw.BatchCount))
	}

	tracks := make([]AlbumTrackMetadata, 0, len(raw.Data.Tracks.Items))
	cache := make(map[string]string)
	for _, item := range raw.Data.Tracks.Items {
		isrc := c.fetchTrackISRC(ctx, item.ID, raw.Token, cache)
		tracks = append(tracks, AlbumTrackMetadata{
			Artists:     joinArtists(item.Artists),
			Name:        item.Name,
			AlbumName:   raw.Data.Name,
			DurationMS:  item.DurationMS,
			Images:      albumImage,
			ReleaseDate: raw.Data.ReleaseDate,
			TrackNumber: item.TrackNumber,
			ExternalURL: item.ExternalURL.Spotify,
			ISRC:        isrc,
			SpotifyID:   item.ID,
		})
	}

	return &AlbumResponsePayload{
		AlbumInfo: info,
		TrackList: tracks,
	}, nil
}

func (c *SpotifyMetadataClient) formatArtistDiscographyData(ctx context.Context, raw *discographyRaw) (*ArtistDiscographyPayload, error) {
	artistImage := firstImageURL(raw.Artist.Images)
	discType := raw.Discography
	if discType == "" {
		discType = "all"
	}

	info := ArtistInfoMetadata{
		Name:            raw.Artist.Name,
		Followers:       raw.Artist.Followers.Total,
		Genres:          raw.Artist.Genres,
		Images:          artistImage,
		ExternalURL:     raw.Artist.ExternalURL.Spotify,
		DiscographyType: discType,
		TotalAlbums:     len(raw.Albums),
	}
	if raw.BatchEnabled {
		info.Batch = strconv.Itoa(maxInt(1, raw.BatchCount))
	}

	albumList := make([]DiscographyAlbumMetadata, 0, len(raw.Albums))
	allTracks := make([]AlbumTrackMetadata, 0)
	isrcCache := make(map[string]string)

	for _, alb := range raw.Albums {
		albumImage := firstImageURL(alb.Images)
		albumList = append(albumList, DiscographyAlbumMetadata{
			ID:          alb.ID,
			Name:        alb.Name,
			AlbumType:   alb.AlbumType,
			ReleaseDate: alb.ReleaseDate,
			TotalTracks: alb.TotalTracks,
			Artists:     joinArtists(alb.Artists),
			Images:      albumImage,
			ExternalURL: alb.ExternalURL.Spotify,
		})

		tracks, err := c.collectAlbumTracks(ctx, alb.ID, raw.Token)
		if err != nil {
			fmt.Printf("Error getting tracks for album %s: %v\n", alb.Name, err)
			continue
		}

		for _, tr := range tracks {
			isrc := c.fetchTrackISRC(ctx, tr.ID, raw.Token, isrcCache)
			var artistID, artistURL string
			if len(tr.Artists) > 0 {
				artistID = tr.Artists[0].ID
				artistURL = fmt.Sprintf("https://open.spotify.com/artist/%s", tr.Artists[0].ID)
			}
			artistsData := make([]ArtistSimple, 0, len(tr.Artists))
			for _, a := range tr.Artists {
				artistsData = append(artistsData, ArtistSimple{
					ID:          a.ID,
					Name:        a.Name,
					ExternalURL: fmt.Sprintf("https://open.spotify.com/artist/%s", a.ID),
				})
			}
			allTracks = append(allTracks, AlbumTrackMetadata{
				Artists:     joinArtists(tr.Artists),
				Name:        tr.Name,
				AlbumName:   alb.Name,
				AlbumType:   alb.AlbumType,
				DurationMS:  tr.DurationMS,
				Images:      albumImage,
				ReleaseDate: alb.ReleaseDate,
				TrackNumber: tr.TrackNumber,
				ExternalURL: tr.ExternalURL.Spotify,
				ISRC:        isrc,
				SpotifyID:   tr.ID,
				AlbumID:     alb.ID,
				AlbumURL:    alb.ExternalURL.Spotify,
				ArtistID:    artistID,
				ArtistURL:   artistURL,
				ArtistsData: artistsData,
			})
		}
	}

	return &ArtistDiscographyPayload{
		ArtistInfo: info,
		AlbumList:  albumList,
		TrackList:  allTracks,
	}, nil
}

func formatArtistData(raw *artistResponse) ArtistResponsePayload {
	if raw == nil {
		return ArtistResponsePayload{}
	}
	payload := ArtistResponsePayload{}
	payload.Artist.Name = raw.Name
	payload.Artist.Followers = raw.Followers.Total
	payload.Artist.Genres = raw.Genres
	payload.Artist.Images = firstImageURL(raw.Images)
	payload.Artist.ExternalURL = raw.ExternalURL.Spotify
	payload.Artist.Popularity = raw.Popularity
	return payload
}

func formatTrackData(raw *trackFull) TrackResponse {
	if raw == nil {
		return TrackResponse{}
	}
	return TrackResponse{
		Track: TrackMetadata{
			Artists:     joinArtists(raw.Artists),
			Name:        raw.Name,
			AlbumName:   raw.Album.Name,
			DurationMS:  raw.DurationMS,
			Images:      firstImageURL(raw.Album.Images),
			ReleaseDate: raw.Album.ReleaseDate,
			TrackNumber: raw.TrackNumber,
			ExternalURL: raw.ExternalURL.Spotify,
			ISRC:        raw.ExternalID.ISRC,
			SpotifyID:   raw.ID,
		},
	}
}

func (c *SpotifyMetadataClient) collectAlbumTracks(ctx context.Context, albumID, token string) ([]trackSimplified, error) {
	url := fmt.Sprintf("%s/tracks?limit=50", fmt.Sprintf(albumBaseURL, albumID))
	var tracks []trackSimplified
	_, err := fetchPaging(ctx, c, url, token, 0, &tracks)
	if err != nil {
		return nil, err
	}
	return tracks, nil
}

func (c *SpotifyMetadataClient) fetchTrackISRC(ctx context.Context, trackID, token string, cache map[string]string) string {
	if trackID == "" || token == "" {
		return ""
	}
	if isrc, ok := cache[trackID]; ok {
		return isrc
	}

	var data struct {
		ExternalID externalID `json:"external_ids"`
	}
	if err := c.getJSON(ctx, fmt.Sprintf(trackBaseURL, trackID), token, &data); err != nil {
		return ""
	}
	cache[trackID] = data.ExternalID.ISRC
	return cache[trackID]
}

func fetchPaging[T any](ctx context.Context, client *SpotifyMetadataClient, nextURL, token string, delay time.Duration, dest *[]T) (int, error) {
	batches := 0
	for nextURL != "" {
		select {
		case <-ctx.Done():
			return batches, ctx.Err()
		default:
		}

		var page struct {
			Items []T    `json:"items"`
			Next  string `json:"next"`
		}
		if err := client.getJSON(ctx, nextURL, token, &page); err != nil {
			return batches, err
		}

		*dest = append(*dest, page.Items...)
		nextURL = stripLocaleParam(page.Next)
		batches++

		if nextURL != "" && delay > 0 {
			if err := sleepWithContext(ctx, delay); err != nil {
				return batches, err
			}
		}
	}
	return batches, nil
}

func (c *SpotifyMetadataClient) getJSON(ctx context.Context, endpoint, token string, dst interface{}) error {
	for {
		req, err := http.NewRequestWithContext(ctx, http.MethodGet, endpoint, nil)
		if err != nil {
			return err
		}
		headers := c.baseHeaders()
		for key, values := range headers {
			for _, v := range values {
				req.Header.Add(key, v)
			}
		}
		if token != "" {
			req.Header.Set("Authorization", "Bearer "+token)
		}

		resp, err := c.httpClient.Do(req)
		if err != nil {
			return err
		}
		body, err := io.ReadAll(resp.Body)
		resp.Body.Close()
		if err != nil {
			return err
		}

		if resp.StatusCode == http.StatusTooManyRequests {
			if err := sleepWithContext(ctx, parseRetryAfter(resp.Header.Get("Retry-After"))); err != nil {
				return err
			}
			continue
		}

		if resp.StatusCode != http.StatusOK {
			return fmt.Errorf("spotify API returned status %d for %s", resp.StatusCode, endpoint)
		}

		return json.Unmarshal(body, dst)
	}
}

func (c *SpotifyMetadataClient) baseHeaders() http.Header {
	h := http.Header{}
	h.Set("User-Agent", c.userAgent)
	h.Set("Accept", "application/json")
	h.Set("Accept-Language", "en-US,en;q=0.9")
	h.Set("sec-ch-ua-platform", "\"Windows\"")
	h.Set("sec-fetch-dest", "empty")
	h.Set("sec-fetch-mode", "cors")
	h.Set("sec-fetch-site", "same-origin")
	h.Set("Referer", "https://open.spotify.com/")
	h.Set("Origin", "https://open.spotify.com")
	return h
}

func (c *SpotifyMetadataClient) randomUserAgent() string {
	c.rngMu.Lock()
	defer c.rngMu.Unlock()

	macMajor := c.randRange(11, 15)
	macMinor := c.randRange(4, 9)
	webkitMajor := c.randRange(530, 537)
	webkitMinor := c.randRange(30, 37)
	chromeMajor := c.randRange(80, 105)
	chromeBuild := c.randRange(3000, 4500)
	chromePatch := c.randRange(60, 125)
	safariMajor := c.randRange(530, 537)
	safariMinor := c.randRange(30, 36)

	return fmt.Sprintf(
		"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_%d_%d) AppleWebKit/%d.%d (KHTML, like Gecko) Chrome/%d.0.%d.%d Safari/%d.%d",
		macMajor,
		macMinor,
		webkitMajor,
		webkitMinor,
		chromeMajor,
		chromeBuild,
		chromePatch,
		safariMajor,
		safariMinor,
	)
}

func (c *SpotifyMetadataClient) randRange(min, max int) int {
	if max <= min {
		return min
	}
	return c.rng.Intn(max-min) + min
}

func (c *SpotifyMetadataClient) getAccessToken(ctx context.Context) (string, error) {
	code, serverTime, version, err := c.generateTOTP(ctx)
	if err != nil {
		return "", err
	}

	timestampMS := time.Now().UnixMilli()
	params := url.Values{}
	params.Set("reason", "init")
	params.Set("productType", "web-player")
	params.Set("totp", code)
	params.Set("totpServerTime", strconv.FormatInt(serverTime, 10))
	params.Set("totpVer", strconv.Itoa(version))
	params.Set("sTime", strconv.FormatInt(serverTime, 10))
	params.Set("cTime", strconv.FormatInt(timestampMS, 10))
	params.Set("buildVer", "web-player_2025-07-02_1720000000000_12345678")
	params.Set("buildDate", "2025-07-02")

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, spotifyTokenURL, nil)
	if err != nil {
		return "", err
	}
	req.URL.RawQuery = params.Encode()
	req.Header = c.baseHeaders()

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return "", err
	}
	body, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return "", err
	}

	if resp.StatusCode != http.StatusOK {
		return "", fmt.Errorf("failed to get access token. Status code: %d", resp.StatusCode)
	}

	var token accessTokenResponse
	if err := json.Unmarshal(body, &token); err != nil {
		return "", err
	}
	if token.AccessToken == "" {
		return "", errors.New("failed to get access token: empty token received")
	}
	return token.AccessToken, nil
}

func (c *SpotifyMetadataClient) generateTOTP(ctx context.Context) (string, int64, int, error) {
	secrets, _, err := c.fetchSecretBytes(ctx)
	if err != nil {
		return "", 0, 0, err
	}
	if len(secrets) == 0 {
		return "", 0, 0, errors.New("no secrets available")
	}

	latest := secrets[0]
	for _, entry := range secrets[1:] {
		if entry.Version > latest.Version {
			latest = entry
		}
	}

	builder := strings.Builder{}
	for idx, val := range latest.Secret {
		processed := val ^ ((idx % 33) + 9)
		builder.WriteString(strconv.Itoa(processed))
	}

	utfBytes := []byte(builder.String())
	hexStr := hex.EncodeToString(utfBytes)
	secretBytes, err := hex.DecodeString(hexStr)
	if err != nil {
		return "", 0, 0, err
	}
	b32Secret := base32.StdEncoding.EncodeToString(secretBytes)

	serverTime, err := c.fetchServerTime(ctx)
	if err != nil {
		return "", 0, 0, err
	}

	code, err := computeTOTP(b32Secret, serverTime)
	if err != nil {
		return "", 0, 0, err
	}

	return code, serverTime, latest.Version, nil
}

func (c *SpotifyMetadataClient) fetchSecretBytes(ctx context.Context) ([]secretEntry, bool, error) {
	// Add cache busting parameter with current timestamp
	urlWithCacheBust := fmt.Sprintf("%s?t=%d", secretBytesRemotePath, time.Now().Unix())

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, urlWithCacheBust, nil)
	if err == nil {
		// Add headers to bypass cache
		req.Header.Set("Cache-Control", "no-cache, no-store, must-revalidate")
		req.Header.Set("Pragma", "no-cache")
		req.Header.Set("Expires", "0")

		resp, err := c.httpClient.Do(req)
		if err == nil {
			body, readErr := io.ReadAll(resp.Body)
			resp.Body.Close()
			if readErr == nil && resp.StatusCode == http.StatusOK {
				var secrets []secretEntry
				if jsonErr := json.Unmarshal(body, &secrets); jsonErr == nil {
					return secrets, false, nil
				}
			}
		}
	}

	home, err := os.UserHomeDir()
	if err != nil {
		return nil, false, fmt.Errorf("GitHub fetch failed and could not resolve home directory: %w", err)
	}
	localPath := filepath.Join(home, ".spotify-secret", "secretBytes.json")
	data, err := os.ReadFile(localPath)
	if err != nil {
		return nil, false, fmt.Errorf("failed to fetch secrets from both GitHub and local: %w", err)
	}

	var secrets []secretEntry
	if err := json.Unmarshal(data, &secrets); err != nil {
		return nil, false, fmt.Errorf("failed to process local secrets: %w", err)
	}
	return secrets, true, nil
}

func (c *SpotifyMetadataClient) fetchServerTime(ctx context.Context) (int64, error) {
	req, err := http.NewRequestWithContext(ctx, http.MethodGet, "https://open.spotify.com/api/server-time", nil)
	if err != nil {
		return 0, err
	}
	req.Header = c.serverTimeHeaders()

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return 0, err
	}
	body, err := io.ReadAll(resp.Body)
	resp.Body.Close()
	if err != nil {
		return 0, err
	}

	if resp.StatusCode != http.StatusOK {
		return 0, fmt.Errorf("failed to get server time. Status code: %d", resp.StatusCode)
	}

	var payload serverTimeResponse
	if err := json.Unmarshal(body, &payload); err != nil {
		return 0, err
	}
	if payload.ServerTime == 0 {
		return 0, errors.New("failed to fetch server time from Spotify")
	}
	return payload.ServerTime, nil
}

func (c *SpotifyMetadataClient) serverTimeHeaders() http.Header {
	h := http.Header{}
	h.Set("Host", "open.spotify.com")
	h.Set("User-Agent", c.randomUserAgent())
	h.Set("Accept", "*/*")
	return h
}

func computeTOTP(b32Secret string, timestamp int64) (string, error) {
	normalized := strings.ToUpper(strings.ReplaceAll(b32Secret, " ", ""))
	key, err := base32.StdEncoding.DecodeString(normalized)
	if err != nil {
		return "", err
	}

	// Normalise milliseconds if necessary.
	if timestamp > 1_000_000_000_000 {
		timestamp /= 1000
	}

	counter := uint64(timestamp / 30)
	var buf [8]byte
	binary.BigEndian.PutUint64(buf[:], counter)

	mac := hmac.New(sha1.New, key)
	if _, err := mac.Write(buf[:]); err != nil {
		return "", err
	}
	sum := mac.Sum(nil)
	if len(sum) < 20 {
		return "", errors.New("unexpected hmac length for TOTP")
	}

	offset := sum[len(sum)-1] & 0x0f
	binaryCode := (int(sum[offset])&0x7f)<<24 |
		(int(sum[offset+1])&0xff)<<16 |
		(int(sum[offset+2])&0xff)<<8 |
		(int(sum[offset+3]) & 0xff)
	otp := binaryCode % 1_000_000
	return fmt.Sprintf("%06d", otp), nil
}

func parseSpotifyURI(input string) (spotifyURI, error) {
	trimmed := strings.TrimSpace(input)
	if trimmed == "" {
		return spotifyURI{}, errInvalidSpotifyURL
	}

	if strings.HasPrefix(trimmed, "spotify:") {
		parts := strings.Split(trimmed, ":")
		if len(parts) == 3 {
			switch parts[1] {
			case "album", "track", "playlist", "artist":
				return spotifyURI{Type: parts[1], ID: parts[2]}, nil
			}
		}
	}

	parsed, err := url.Parse(trimmed)
	if err != nil {
		return spotifyURI{}, err
	}

	if parsed.Host == "embed.spotify.com" {
		if parsed.RawQuery == "" {
			return spotifyURI{}, errInvalidSpotifyURL
		}
		qs, _ := url.ParseQuery(parsed.RawQuery)
		embedded := qs.Get("uri")
		if embedded == "" {
			return spotifyURI{}, errInvalidSpotifyURL
		}
		return parseSpotifyURI(embedded)
	}

	if parsed.Scheme == "" && parsed.Host == "" {
		id := strings.Trim(strings.TrimSpace(parsed.Path), "/")
		if id == "" {
			return spotifyURI{}, errInvalidSpotifyURL
		}
		return spotifyURI{Type: "playlist", ID: id}, nil
	}

	if parsed.Host != "open.spotify.com" && parsed.Host != "play.spotify.com" {
		return spotifyURI{}, errInvalidSpotifyURL
	}

	parts := cleanPathParts(parsed.Path)
	if len(parts) == 0 {
		return spotifyURI{}, errInvalidSpotifyURL
	}

	if parts[0] == "embed" {
		parts = parts[1:]
	}
	if len(parts) == 0 {
		return spotifyURI{}, errInvalidSpotifyURL
	}
	if strings.HasPrefix(parts[0], "intl-") {
		parts = parts[1:]
	}
	if len(parts) == 0 {
		return spotifyURI{}, errInvalidSpotifyURL
	}

	if len(parts) == 2 {
		switch parts[0] {
		case "album", "track", "playlist", "artist":
			return spotifyURI{Type: parts[0], ID: parts[1]}, nil
		}
	}

	if len(parts) == 4 && parts[2] == "playlist" {
		return spotifyURI{Type: "playlist", ID: parts[3]}, nil
	}

	if len(parts) >= 3 && parts[0] == "artist" {
		if len(parts) >= 3 && parts[2] == "discography" {
			discType := "all"
			if len(parts) >= 4 {
				candidate := parts[3]
				if candidate == "all" || candidate == "album" || candidate == "single" || candidate == "compilation" {
					discType = candidate
				}
			}
			return spotifyURI{Type: "artist_discography", ID: parts[1], DiscographyGroup: discType}, nil
		}
		return spotifyURI{Type: "artist", ID: parts[1]}, nil
	}

	return spotifyURI{}, errInvalidSpotifyURL
}

func cleanPathParts(path string) []string {
	raw := strings.Split(path, "/")
	parts := make([]string, 0, len(raw))
	for _, part := range raw {
		if part != "" {
			parts = append(parts, part)
		}
	}
	return parts
}

func stripLocaleParam(raw string) string {
	if raw == "" {
		return ""
	}
	if idx := strings.Index(raw, "&locale="); idx != -1 {
		return raw[:idx]
	}
	if idx := strings.Index(raw, "?locale="); idx != -1 {
		return raw[:idx]
	}
	return raw
}

func firstImageURL(images []image) string {
	if len(images) == 0 {
		return ""
	}
	return images[0].URL
}

func joinArtists(artists []artist) string {
	if len(artists) == 0 {
		return ""
	}
	names := make([]string, 0, len(artists))
	for _, a := range artists {
		if a.Name != "" {
			names = append(names, a.Name)
		}
	}
	return strings.Join(names, ", ")
}

func firstNonEmpty(values ...string) string {
	for _, v := range values {
		if strings.TrimSpace(v) != "" {
			return v
		}
	}
	return ""
}

func parseRetryAfter(value string) time.Duration {
	if value == "" {
		return 5 * time.Second
	}
	secs, err := strconv.Atoi(strings.TrimSpace(value))
	if err != nil {
		return 5 * time.Second
	}
	return time.Duration(secs+1) * time.Second
}

func sleepWithContext(ctx context.Context, d time.Duration) error {
	if d <= 0 {
		return nil
	}
	timer := time.NewTimer(d)
	defer timer.Stop()
	select {
	case <-ctx.Done():
		return ctx.Err()
	case <-timer.C:
		return nil
	}
}

func maxInt(a, b int) int {
	if a > b {
		return a
	}
	return b
}

```

## backend/tidal.go

```go
package backend

import (
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"time"
)

type TidalDownloader struct {
	client       *http.Client
	timeout      time.Duration
	maxRetries   int
	clientID     string
	clientSecret string
	apiURL       string
}

type TidalSearchResponse struct {
	Limit              int          `json:"limit"`
	Offset             int          `json:"offset"`
	TotalNumberOfItems int          `json:"totalNumberOfItems"`
	Items              []TidalTrack `json:"items"`
}

type TidalTrack struct {
	ID           int64  `json:"id"`
	Title        string `json:"title"`
	ISRC         string `json:"isrc"`
	AudioQuality string `json:"audioQuality"`
	TrackNumber  int    `json:"trackNumber"`
	VolumeNumber int    `json:"volumeNumber"`
	Duration     int    `json:"duration"`
	Copyright    string `json:"copyright"`
	Explicit     bool   `json:"explicit"`
	Album        struct {
		Title       string `json:"title"`
		Cover       string `json:"cover"`
		ReleaseDate string `json:"releaseDate"`
	} `json:"album"`
	Artists []struct {
		Name string `json:"name"`
	} `json:"artists"`
	Artist struct {
		Name string `json:"name"`
	} `json:"artist"`
	MediaMetadata struct {
		Tags []string `json:"tags"`
	} `json:"mediaMetadata"`
}

type TidalAPIResponse struct {
	OriginalTrackURL string `json:"OriginalTrackUrl"`
}

type TidalAPIInfo struct {
	URL    string `json:"url"`
	Status string `json:"status"`
}

func NewTidalDownloader(apiURL string) *TidalDownloader {
	clientID, _ := base64.StdEncoding.DecodeString("NkJEU1JkcEs5aHFFQlRnVQ==")
	clientSecret, _ := base64.StdEncoding.DecodeString("eGV1UG1ZN25icFo5SUliTEFjUTkzc2hrYTFWTmhlVUFxTjZJY3N6alRHOD0=")

	// If apiURL is empty, try to get first available API
	if apiURL == "" {
		downloader := &TidalDownloader{
			client: &http.Client{
				Timeout: 5 * time.Second, // Fast timeout for quick API fallback
			},
			timeout:      5 * time.Second,
			maxRetries:   3,
			clientID:     string(clientID),
			clientSecret: string(clientSecret),
			apiURL:       "",
		}

		// Try to get available APIs
		apis, err := downloader.GetAvailableAPIs()
		if err == nil && len(apis) > 0 {
			apiURL = apis[0] // Use first available API
		}
	}

	return &TidalDownloader{
		client: &http.Client{
			Timeout: 5 * time.Second, // Fast timeout for quick API fallback
		},
		timeout:      5 * time.Second,
		maxRetries:   3,
		clientID:     string(clientID),
		clientSecret: string(clientSecret),
		apiURL:       apiURL,
	}
}

func (t *TidalDownloader) GetAvailableAPIs() ([]string, error) {
	// Decode base64 API URL
	apiURL, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fma2FyeHl6L1Nwb3RpRkxBQy9yZWZzL2hlYWRzL21haW4vdGlkYWwuanNvbg==")

	// Add cache-busting parameter with current timestamp
	urlWithCacheBust := fmt.Sprintf("%s?t=%d", string(apiURL), time.Now().Unix())

	// Create request with cache bypass headers
	req, err := http.NewRequest("GET", urlWithCacheBust, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	// Add headers to bypass cache
	req.Header.Set("Cache-Control", "no-cache, no-store, must-revalidate")
	req.Header.Set("Pragma", "no-cache")
	req.Header.Set("Expires", "0")

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch API list: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("failed to fetch API list: HTTP %d", resp.StatusCode)
	}

	var apiList []string
	if err := json.NewDecoder(resp.Body).Decode(&apiList); err != nil {
		return nil, fmt.Errorf("failed to decode API list: %w", err)
	}

	var apis []string
	for _, api := range apiList {
		apis = append(apis, "https://"+api)
	}

	return apis, nil
}

func (t *TidalDownloader) GetAccessToken() (string, error) {
	data := fmt.Sprintf("client_id=%s&grant_type=client_credentials", t.clientID)

	// Decode base64 API URL
	authURL, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hdXRoLnRpZGFsLmNvbS92MS9vYXV0aDIvdG9rZW4=")
	req, err := http.NewRequest("POST", string(authURL), strings.NewReader(data))
	if err != nil {
		return "", err
	}

	req.SetBasicAuth(t.clientID, t.clientSecret)
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	resp, err := t.client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("failed to get access token: HTTP %d", resp.StatusCode)
	}

	var result struct {
		AccessToken string `json:"access_token"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", err
	}

	return result.AccessToken, nil
}

// SearchTracks searches for tracks on Tidal with configurable limit
func (t *TidalDownloader) SearchTracks(query string) (*TidalSearchResponse, error) {
	return t.SearchTracksWithLimit(query, 50) // Default to 50 results for better matching
}

// SearchTracksWithLimit searches for tracks on Tidal with a specific limit
func (t *TidalDownloader) SearchTracksWithLimit(query string, limit int) (*TidalSearchResponse, error) {
	token, err := t.GetAccessToken()
	if err != nil {
		return nil, fmt.Errorf("failed to get access token: %w", err)
	}

	// Decode base64 API URL and encode the query parameter
	searchBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hcGkudGlkYWwuY29tL3YxL3NlYXJjaC90cmFja3M/cXVlcnk9")
	searchURL := fmt.Sprintf("%s%s&limit=%d&offset=0&countryCode=US", string(searchBase), url.QueryEscape(query), limit)

	req, err := http.NewRequest("GET", searchURL, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+token)

	resp, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("search failed: HTTP %d - %s", resp.StatusCode, string(body))
	}

	var result TidalSearchResponse
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, err
	}

	return &result, nil
}

// SearchTrackByMetadata searches for a track using artist name and track name
// It tries multiple search strategies including romaji conversion for Japanese text
// Now accepts ISRC for exact matching
func (t *TidalDownloader) SearchTrackByMetadata(trackName, artistName string, expectedDuration int) (*TidalTrack, error) {
	return t.SearchTrackByMetadataWithISRC(trackName, artistName, "", expectedDuration)
}

// SearchTrackByMetadataWithISRC searches for a track with ISRC matching priority
func (t *TidalDownloader) SearchTrackByMetadataWithISRC(trackName, artistName, spotifyISRC string, expectedDuration int) (*TidalTrack, error) {
	// Build search queries - multiple strategies
	queries := []string{}

	// Strategy 1: Artist + Track name (original)
	if artistName != "" && trackName != "" {
		queries = append(queries, artistName+" "+trackName)
	}

	// Strategy 2: Track name only (sometimes works better)
	if trackName != "" {
		queries = append(queries, trackName)
	}

	// Strategy 3: Romaji versions if Japanese detected
	if ContainsJapanese(trackName) || ContainsJapanese(artistName) {
		// Convert to romaji (hiragana/katakana only, kanji stays)
		romajiTrack := JapaneseToRomaji(trackName)
		romajiArtist := JapaneseToRomaji(artistName)

		// Clean and remove ALL non-ASCII characters (including kanji)
		cleanRomajiTrack := cleanToASCII(romajiTrack)
		cleanRomajiArtist := cleanToASCII(romajiArtist)

		// Artist + Track romaji (cleaned to ASCII only)
		if cleanRomajiArtist != "" && cleanRomajiTrack != "" {
			romajiQuery := cleanRomajiArtist + " " + cleanRomajiTrack
			if !containsQuery(queries, romajiQuery) {
				queries = append(queries, romajiQuery)
				fmt.Printf("Japanese detected, adding romaji query: %s\n", romajiQuery)
			}
		}

		// Track romaji only (cleaned)
		if cleanRomajiTrack != "" && cleanRomajiTrack != trackName {
			if !containsQuery(queries, cleanRomajiTrack) {
				queries = append(queries, cleanRomajiTrack)
			}
		}

		// Also try with partial romaji (artist + cleaned track)
		if artistName != "" && cleanRomajiTrack != "" {
			partialQuery := artistName + " " + cleanRomajiTrack
			if !containsQuery(queries, partialQuery) {
				queries = append(queries, partialQuery)
			}
		}
	}

	// Strategy 4: Artist only as last resort
	if artistName != "" {
		artistOnly := cleanToASCII(JapaneseToRomaji(artistName))
		if artistOnly != "" && !containsQuery(queries, artistOnly) {
			queries = append(queries, artistOnly)
		}
	}

	// Collect all search results from all queries
	var allTracks []TidalTrack
	searchedQueries := make(map[string]bool)

	for _, query := range queries {
		cleanQuery := strings.TrimSpace(query)
		if cleanQuery == "" || searchedQueries[cleanQuery] {
			continue
		}
		searchedQueries[cleanQuery] = true

		fmt.Printf("Searching Tidal for: %s\n", cleanQuery)

		result, err := t.SearchTracksWithLimit(cleanQuery, 100) // Get more results
		if err != nil {
			fmt.Printf("Search error for '%s': %v\n", cleanQuery, err)
			continue
		}

		if len(result.Items) > 0 {
			fmt.Printf("Found %d results for '%s'\n", len(result.Items), cleanQuery)
			allTracks = append(allTracks, result.Items...)
		}
	}

	if len(allTracks) == 0 {
		return nil, fmt.Errorf("no tracks found for any search query")
	}

	// Priority 1: Match by ISRC (exact match)
	if spotifyISRC != "" {
		fmt.Printf("Looking for ISRC match: %s\n", spotifyISRC)
		for i := range allTracks {
			track := &allTracks[i]
			if track.ISRC == spotifyISRC {
				fmt.Printf("✓ ISRC match found: %s - %s (ISRC: %s, Quality: %s)\n",
					track.Artist.Name, track.Title, track.ISRC, track.AudioQuality)
				return track, nil
			}
		}
		fmt.Printf("No exact ISRC match found, trying other matching methods...\n")
	}

	// If ISRC was provided but no match found, return error - don't download wrong track
	if spotifyISRC != "" {
		fmt.Printf("✗ No ISRC match found for: %s\n", spotifyISRC)
		fmt.Printf("  Available ISRCs from search results:\n")
		// Show first 5 results for debugging
		for i, track := range allTracks {
			if i >= 5 {
				fmt.Printf("  ... and %d more results\n", len(allTracks)-5)
				break
			}
			fmt.Printf("  - %s - %s (ISRC: %s)\n", track.Artist.Name, track.Title, track.ISRC)
		}
		return nil, fmt.Errorf("ISRC mismatch: no track found with ISRC %s on Tidal", spotifyISRC)
	}

	// Only proceed without ISRC matching if no ISRC was provided
	// Priority 2: Match by duration (within tolerance) + prefer best quality
	var bestMatch *TidalTrack
	if expectedDuration > 0 {
		tolerance := 3 // 3 seconds tolerance
		var durationMatches []*TidalTrack

		for i := range allTracks {
			track := &allTracks[i]
			durationDiff := track.Duration - expectedDuration
			if durationDiff < 0 {
				durationDiff = -durationDiff
			}
			if durationDiff <= tolerance {
				durationMatches = append(durationMatches, track)
			}
		}

		if len(durationMatches) > 0 {
			// Find best quality among duration matches
			bestMatch = durationMatches[0]
			for _, track := range durationMatches {
				for _, tag := range track.MediaMetadata.Tags {
					if tag == "HIRES_LOSSLESS" {
						bestMatch = track
						break
					}
				}
			}
			fmt.Printf("Found via duration match: %s - %s (%s)\n",
				bestMatch.Artist.Name, bestMatch.Title, bestMatch.AudioQuality)
			return bestMatch, nil
		}
	}

	// Priority 3: Just take the best quality from first results (only when no ISRC provided)
	bestMatch = &allTracks[0]
	for i := range allTracks {
		track := &allTracks[i]
		for _, tag := range track.MediaMetadata.Tags {
			if tag == "HIRES_LOSSLESS" {
				bestMatch = track
				break
			}
		}
		if bestMatch != &allTracks[0] {
			break // Found HIRES_LOSSLESS
		}
	}

	fmt.Printf("Found via search (no ISRC provided): %s - %s (ISRC: %s, Quality: %s)\n",
		bestMatch.Artist.Name, bestMatch.Title, bestMatch.ISRC, bestMatch.AudioQuality)

	return bestMatch, nil
}

// containsQuery checks if a query already exists in the list
func containsQuery(queries []string, query string) bool {
	for _, q := range queries {
		if q == query {
			return true
		}
	}
	return false
}

func (t *TidalDownloader) GetTidalURLFromSpotify(spotifyTrackID string) (string, error) {
	// Decode base64 API URL
	spotifyBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9vcGVuLnNwb3RpZnkuY29tL3RyYWNrLw==")
	spotifyURL := fmt.Sprintf("%s%s", string(spotifyBase), spotifyTrackID)

	apiBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hcGkuc29uZy5saW5rL3YxLWFscGhhLjEvbGlua3M/dXJsPQ==")
	apiURL := fmt.Sprintf("%s%s", string(apiBase), url.QueryEscape(spotifyURL))

	req, err := http.NewRequest("GET", apiURL, nil)
	if err != nil {
		return "", fmt.Errorf("failed to create request: %w", err)
	}

	fmt.Println("Getting Tidal URL...")

	resp, err := t.client.Do(req)
	if err != nil {
		return "", fmt.Errorf("failed to get Tidal URL: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("API returned status %d", resp.StatusCode)
	}

	var songLinkResp struct {
		LinksByPlatform map[string]struct {
			URL string `json:"url"`
		} `json:"linksByPlatform"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&songLinkResp); err != nil {
		return "", fmt.Errorf("failed to decode response: %w", err)
	}

	tidalLink, ok := songLinkResp.LinksByPlatform["tidal"]
	if !ok || tidalLink.URL == "" {
		return "", fmt.Errorf("tidal link not found")
	}

	tidalURL := tidalLink.URL
	fmt.Printf("Found Tidal URL: %s\n", tidalURL)
	return tidalURL, nil
}

func (t *TidalDownloader) GetTrackIDFromURL(tidalURL string) (int64, error) {
	// Extract track ID from Tidal URL
	// Format: https://listen.tidal.com/track/441821360
	// or: https://tidal.com/browse/track/123456789
	parts := strings.Split(tidalURL, "/track/")
	if len(parts) < 2 {
		return 0, fmt.Errorf("invalid tidal URL format")
	}

	// Get the track ID part and remove any query parameters
	trackIDStr := strings.Split(parts[1], "?")[0]
	trackIDStr = strings.TrimSpace(trackIDStr)

	var trackID int64
	_, err := fmt.Sscanf(trackIDStr, "%d", &trackID)
	if err != nil {
		return 0, fmt.Errorf("failed to parse track ID: %w", err)
	}

	return trackID, nil
}

func (t *TidalDownloader) GetTrackInfoByID(trackID int64) (*TidalTrack, error) {
	token, err := t.GetAccessToken()
	if err != nil {
		return nil, fmt.Errorf("failed to get access token: %w", err)
	}

	// Decode base64 API URL
	trackBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9hcGkudGlkYWwuY29tL3YxL3RyYWNrcy8=")
	trackURL := fmt.Sprintf("%s%d?countryCode=US", string(trackBase), trackID)

	req, err := http.NewRequest("GET", trackURL, nil)
	if err != nil {
		return nil, err
	}

	req.Header.Set("Authorization", "Bearer "+token)

	resp, err := t.client.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		return nil, fmt.Errorf("failed to get track info: HTTP %d - %s", resp.StatusCode, string(body))
	}

	var trackInfo TidalTrack
	if err := json.NewDecoder(resp.Body).Decode(&trackInfo); err != nil {
		return nil, err
	}

	fmt.Printf("Found: %s (%s)\n", trackInfo.Title, trackInfo.AudioQuality)
	return &trackInfo, nil
}

func (t *TidalDownloader) GetDownloadURL(trackID int64, quality string) (string, error) {
	fmt.Println("Fetching URL...")

	url := fmt.Sprintf("%s/track/?id=%d&quality=%s", t.apiURL, trackID, quality)
	fmt.Printf("Tidal API URL: %s\n", url)

	resp, err := t.client.Get(url)
	if err != nil {
		fmt.Printf("✗ Tidal API request failed: %v\n", err)
		return "", fmt.Errorf("failed to get download URL: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		fmt.Printf("✗ Tidal API returned status code: %d\n", resp.StatusCode)
		return "", fmt.Errorf("API returned status code: %d", resp.StatusCode)
	}

	var apiResponses []TidalAPIResponse
	if err := json.NewDecoder(resp.Body).Decode(&apiResponses); err != nil {
		fmt.Printf("✗ Failed to decode Tidal API response: %v\n", err)
		return "", fmt.Errorf("failed to decode response: %w", err)
	}

	if len(apiResponses) == 0 {
		fmt.Println("✗ Tidal API returned empty response")
		return "", fmt.Errorf("no download URL in response")
	}

	for _, item := range apiResponses {
		if item.OriginalTrackURL != "" {
			fmt.Println("✓ Tidal download URL found")
			return item.OriginalTrackURL, nil
		}
	}

	fmt.Println("✗ No valid download URL in Tidal API response")
	return "", fmt.Errorf("download URL not found in response")
}

func (t *TidalDownloader) DownloadAlbumArt(albumID string) ([]byte, error) {
	albumID = strings.ReplaceAll(albumID, "-", "/")
	// Decode base64 API URL
	imageBase, _ := base64.StdEncoding.DecodeString("aHR0cHM6Ly9yZXNvdXJjZXMudGlkYWwuY29tL2ltYWdlcy8=")
	artURL := fmt.Sprintf("%s%s/1280x1280.jpg", string(imageBase), albumID)

	resp, err := t.client.Get(artURL)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return nil, fmt.Errorf("failed to download album art: HTTP %d", resp.StatusCode)
	}

	return io.ReadAll(resp.Body)
}

func (t *TidalDownloader) DownloadFile(url, filepath string) error {
	resp, err := t.client.Get(url)
	if err != nil {
		return fmt.Errorf("failed to download file: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("download failed with status %d", resp.StatusCode)
	}

	out, err := os.Create(filepath)
	if err != nil {
		return fmt.Errorf("failed to create file: %w", err)
	}
	defer out.Close()

	// Use progress writer to track download
	pw := NewProgressWriter(out)
	_, err = io.Copy(pw, resp.Body)
	if err != nil {
		return fmt.Errorf("failed to write file: %w", err)
	}

	// Print final size
	fmt.Printf("\rDownloaded: %.2f MB (Complete)\n", float64(pw.GetTotal())/(1024*1024))

	fmt.Println("Download complete")
	return nil
}

func (t *TidalDownloader) DownloadByURL(tidalURL, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool) (string, error) {
	if outputDir != "." {
		if err := os.MkdirAll(outputDir, 0755); err != nil {
			return "", fmt.Errorf("directory error: %w", err)
		}
	}

	fmt.Printf("Using Tidal URL: %s\n", tidalURL)

	// Extract track ID from URL
	trackID, err := t.GetTrackIDFromURL(tidalURL)
	if err != nil {
		return "", err
	}

	// Get track info by ID
	trackInfo, err := t.GetTrackInfoByID(trackID)
	if err != nil {
		return "", err
	}

	if trackInfo.ID == 0 {
		return "", fmt.Errorf("no track ID found")
	}

	// Use Spotify metadata if provided, otherwise fallback to Tidal metadata
	artistName := spotifyArtistName
	trackTitle := spotifyTrackName
	albumTitle := spotifyAlbumName

	if artistName == "" {
		var artists []string
		if len(trackInfo.Artists) > 0 {
			for _, artist := range trackInfo.Artists {
				if artist.Name != "" {
					artists = append(artists, artist.Name)
				}
			}
		} else if trackInfo.Artist.Name != "" {
			artists = append(artists, trackInfo.Artist.Name)
		}

		artistName = "Unknown Artist"
		if len(artists) > 0 {
			artistName = strings.Join(artists, ", ")
		}
	}
	artistName = sanitizeFilename(artistName)

	if trackTitle == "" {
		trackTitle = trackInfo.Title
		if trackTitle == "" {
			trackTitle = fmt.Sprintf("track_%d", trackInfo.ID)
		}
	}
	trackTitle = sanitizeFilename(trackTitle)

	if albumTitle == "" {
		albumTitle = trackInfo.Album.Title
	}

	// Check if file with same ISRC already exists
	if existingFile, exists := CheckISRCExists(outputDir, trackInfo.ISRC); exists {
		fmt.Printf("File with ISRC %s already exists: %s\n", trackInfo.ISRC, existingFile)
		return "EXISTS:" + existingFile, nil
	}

	// Build filename based on format settings
	filename := buildTidalFilename(trackTitle, artistName, trackInfo.TrackNumber, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	outputFilename := filepath.Join(outputDir, filename)

	if fileInfo, err := os.Stat(outputFilename); err == nil && fileInfo.Size() > 0 {
		fmt.Printf("File already exists: %s (%.2f MB)\n", outputFilename, float64(fileInfo.Size())/(1024*1024))
		return "EXISTS:" + outputFilename, nil
	}

	downloadURL, err := t.GetDownloadURL(trackInfo.ID, quality)
	if err != nil {
		return "", err
	}

	fmt.Printf("Downloading to: %s\n", outputFilename)
	if err := t.DownloadFile(downloadURL, outputFilename); err != nil {
		return "", err
	}

	fmt.Println("Adding metadata...")

	coverPath := ""
	if trackInfo.Album.Cover != "" {
		coverPath = outputFilename + ".cover.jpg"
		albumArt, err := t.DownloadAlbumArt(trackInfo.Album.Cover)
		if err != nil {
			fmt.Printf("Warning: Failed to download album art: %v\n", err)
		} else {
			if err := os.WriteFile(coverPath, albumArt, 0644); err != nil {
				fmt.Printf("Warning: Failed to save album art: %v\n", err)
			} else {
				defer os.Remove(coverPath)
				fmt.Println("Album art downloaded")
			}
		}
	}

	releaseYear := ""
	if len(trackInfo.Album.ReleaseDate) >= 4 {
		releaseYear = trackInfo.Album.ReleaseDate[:4]
	}

	// Use album track number if in album folder structure, otherwise use playlist position
	trackNumberToEmbed := 0
	if position > 0 {
		if useAlbumTrackNumber && trackInfo.TrackNumber > 0 {
			trackNumberToEmbed = trackInfo.TrackNumber
		} else {
			trackNumberToEmbed = position
		}
	}

	metadata := Metadata{
		Title:       trackTitle,
		Artist:      artistName,
		Album:       albumTitle,
		Date:        releaseYear,
		TrackNumber: trackNumberToEmbed,
		DiscNumber:  trackInfo.VolumeNumber,
		ISRC:        trackInfo.ISRC,
	}

	if err := EmbedMetadata(outputFilename, metadata, coverPath); err != nil {
		fmt.Printf("Tagging failed: %v\n", err)
	} else {
		fmt.Println("Metadata saved")
	}

	fmt.Println("Done")
	fmt.Println("✓ Downloaded successfully from Tidal")
	return outputFilename, nil
}

func (t *TidalDownloader) DownloadByURLWithFallback(tidalURL, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool) (string, error) {
	apis, err := t.GetAvailableAPIs()
	if err != nil {
		return "", fmt.Errorf("no APIs available for fallback: %w", err)
	}

	if outputDir != "." {
		if err := os.MkdirAll(outputDir, 0755); err != nil {
			return "", fmt.Errorf("directory error: %w", err)
		}
	}

	fmt.Printf("Using Tidal URL: %s\n", tidalURL)

	// Extract track ID from URL
	trackID, err := t.GetTrackIDFromURL(tidalURL)
	if err != nil {
		return "", err
	}

	// Get track info by ID
	trackInfo, err := t.GetTrackInfoByID(trackID)
	if err != nil {
		return "", err
	}

	if trackInfo.ID == 0 {
		return "", fmt.Errorf("no track ID found")
	}

	// Use Spotify metadata if provided, otherwise fallback to Tidal metadata
	artistName := spotifyArtistName
	trackTitle := spotifyTrackName
	albumTitle := spotifyAlbumName

	if artistName == "" {
		var artists []string
		if len(trackInfo.Artists) > 0 {
			for _, artist := range trackInfo.Artists {
				if artist.Name != "" {
					artists = append(artists, artist.Name)
				}
			}
		} else if trackInfo.Artist.Name != "" {
			artists = append(artists, trackInfo.Artist.Name)
		}
		artistName = "Unknown Artist"
		if len(artists) > 0 {
			artistName = strings.Join(artists, ", ")
		}
	}
	artistName = sanitizeFilename(artistName)

	if trackTitle == "" {
		trackTitle = trackInfo.Title
		if trackTitle == "" {
			trackTitle = fmt.Sprintf("track_%d", trackInfo.ID)
		}
	}
	trackTitle = sanitizeFilename(trackTitle)

	if albumTitle == "" {
		albumTitle = trackInfo.Album.Title
	}

	// Check if file with same ISRC already exists
	if existingFile, exists := CheckISRCExists(outputDir, trackInfo.ISRC); exists {
		fmt.Printf("File with ISRC %s already exists: %s\n", trackInfo.ISRC, existingFile)
		return "EXISTS:" + existingFile, nil
	}

	filename := buildTidalFilename(trackTitle, artistName, trackInfo.TrackNumber, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	outputFilename := filepath.Join(outputDir, filename)

	if fileInfo, err := os.Stat(outputFilename); err == nil && fileInfo.Size() > 0 {
		fmt.Printf("File already exists: %s (%.2f MB)\n", outputFilename, float64(fileInfo.Size())/(1024*1024))
		return "EXISTS:" + outputFilename, nil
	}

	// Request download URL from ALL APIs in parallel - use first success
	successAPI, downloadURL, err := getDownloadURLParallel(apis, trackInfo.ID, quality)
	if err != nil {
		return "", err
	}

	// Download the file
	fmt.Printf("Downloading to: %s\n", outputFilename)
	downloader := NewTidalDownloader(successAPI)
	if err := downloader.DownloadFile(downloadURL, outputFilename); err != nil {
		return "", err
	}

	fmt.Println("Adding metadata...")

	coverPath := ""
	if trackInfo.Album.Cover != "" {
		coverPath = outputFilename + ".cover.jpg"
		albumArt, err := downloader.DownloadAlbumArt(trackInfo.Album.Cover)
		if err != nil {
			fmt.Printf("Warning: Failed to download album art: %v\n", err)
		} else {
			if err := os.WriteFile(coverPath, albumArt, 0644); err != nil {
				fmt.Printf("Warning: Failed to save album art: %v\n", err)
			} else {
				defer os.Remove(coverPath)
				fmt.Println("Album art downloaded")
			}
		}
	}

	releaseYear := ""
	if len(trackInfo.Album.ReleaseDate) >= 4 {
		releaseYear = trackInfo.Album.ReleaseDate[:4]
	}

	trackNumberToEmbed := 0
	if position > 0 {
		if useAlbumTrackNumber && trackInfo.TrackNumber > 0 {
			trackNumberToEmbed = trackInfo.TrackNumber
		} else {
			trackNumberToEmbed = position
		}
	}

	metadata := Metadata{
		Title:       trackTitle,
		Artist:      artistName,
		Album:       albumTitle,
		Date:        releaseYear,
		TrackNumber: trackNumberToEmbed,
		DiscNumber:  trackInfo.VolumeNumber,
		ISRC:        trackInfo.ISRC,
	}

	if err := EmbedMetadata(outputFilename, metadata, coverPath); err != nil {
		fmt.Printf("Tagging failed: %v\n", err)
	} else {
		fmt.Println("Metadata saved")
	}

	fmt.Println("Done")
	fmt.Println("✓ Downloaded successfully from Tidal")
	return outputFilename, nil
}

func (t *TidalDownloader) Download(spotifyTrackID, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool) (string, error) {
	// Get Tidal URL from Spotify track ID
	tidalURL, err := t.GetTidalURLFromSpotify(spotifyTrackID)
	if err != nil {
		// Songlink failed to find Tidal URL, try search fallback
		fmt.Printf("Songlink couldn't find Tidal URL: %v\n", err)
		fmt.Println("Trying Tidal search fallback...")
		return t.DownloadBySearch(spotifyTrackName, spotifyArtistName, spotifyAlbumName, "", 0, outputDir, quality, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	}

	return t.DownloadByURLWithFallback(tidalURL, outputDir, quality, filenameFormat, includeTrackNumber, position, spotifyTrackName, spotifyArtistName, spotifyAlbumName, useAlbumTrackNumber)
}

// DownloadWithISRC downloads a track with ISRC matching for search fallback
func (t *TidalDownloader) DownloadWithISRC(spotifyTrackID, spotifyISRC, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool, expectedDuration int) (string, error) {
	// Get Tidal URL from Spotify track ID
	tidalURL, err := t.GetTidalURLFromSpotify(spotifyTrackID)
	if err != nil {
		// Songlink failed to find Tidal URL, try search fallback with ISRC
		fmt.Printf("Songlink couldn't find Tidal URL: %v\n", err)
		fmt.Println("Trying Tidal search fallback with ISRC matching...")
		return t.DownloadBySearchWithISRC(spotifyTrackName, spotifyArtistName, spotifyAlbumName, spotifyISRC, expectedDuration, outputDir, quality, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	}

	return t.DownloadByURLWithFallback(tidalURL, outputDir, quality, filenameFormat, includeTrackNumber, position, spotifyTrackName, spotifyArtistName, spotifyAlbumName, useAlbumTrackNumber)
}

// DownloadBySearch downloads a track by searching Tidal directly using metadata
// This is used as a fallback when Songlink API doesn't find a Tidal URL
func (t *TidalDownloader) DownloadBySearch(trackName, artistName, albumName, spotifyISRC string, expectedDuration int, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, useAlbumTrackNumber bool) (string, error) {
	return t.DownloadBySearchWithISRC(trackName, artistName, albumName, spotifyISRC, expectedDuration, outputDir, quality, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
}

// DownloadBySearchWithISRC downloads a track by searching Tidal with ISRC matching
func (t *TidalDownloader) DownloadBySearchWithISRC(trackName, artistName, albumName, spotifyISRC string, expectedDuration int, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, useAlbumTrackNumber bool) (string, error) {
	if outputDir != "." {
		if err := os.MkdirAll(outputDir, 0755); err != nil {
			return "", fmt.Errorf("directory error: %w", err)
		}
	}

	// Search for the track with ISRC matching
	trackInfo, err := t.SearchTrackByMetadataWithISRC(trackName, artistName, spotifyISRC, expectedDuration)
	if err != nil {
		return "", fmt.Errorf("search fallback failed: %w", err)
	}

	if trackInfo.ID == 0 {
		return "", fmt.Errorf("no track ID found from search")
	}

	// Use provided metadata, fallback to Tidal metadata
	finalArtistName := artistName
	finalTrackTitle := trackName
	finalAlbumTitle := albumName

	if finalArtistName == "" {
		var artists []string
		if len(trackInfo.Artists) > 0 {
			for _, artist := range trackInfo.Artists {
				if artist.Name != "" {
					artists = append(artists, artist.Name)
				}
			}
		} else if trackInfo.Artist.Name != "" {
			artists = append(artists, trackInfo.Artist.Name)
		}
		if len(artists) > 0 {
			finalArtistName = strings.Join(artists, ", ")
		} else {
			finalArtistName = "Unknown Artist"
		}
	}
	finalArtistName = sanitizeFilename(finalArtistName)

	if finalTrackTitle == "" {
		finalTrackTitle = trackInfo.Title
		if finalTrackTitle == "" {
			finalTrackTitle = fmt.Sprintf("track_%d", trackInfo.ID)
		}
	}
	finalTrackTitle = sanitizeFilename(finalTrackTitle)

	if finalAlbumTitle == "" {
		finalAlbumTitle = trackInfo.Album.Title
	}

	// Check if file with same ISRC already exists
	if existingFile, exists := CheckISRCExists(outputDir, trackInfo.ISRC); exists {
		fmt.Printf("File with ISRC %s already exists: %s\n", trackInfo.ISRC, existingFile)
		return "EXISTS:" + existingFile, nil
	}

	// Build filename
	filename := buildTidalFilename(finalTrackTitle, finalArtistName, trackInfo.TrackNumber, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	outputFilename := filepath.Join(outputDir, filename)

	if fileInfo, err := os.Stat(outputFilename); err == nil && fileInfo.Size() > 0 {
		fmt.Printf("File already exists: %s (%.2f MB)\n", outputFilename, float64(fileInfo.Size())/(1024*1024))
		return "EXISTS:" + outputFilename, nil
	}

	// Get download URL
	downloadURL, err := t.GetDownloadURL(trackInfo.ID, quality)
	if err != nil {
		return "", err
	}

	fmt.Printf("Downloading to: %s\n", outputFilename)
	if err := t.DownloadFile(downloadURL, outputFilename); err != nil {
		return "", err
	}

	fmt.Println("Adding metadata...")

	coverPath := ""
	if trackInfo.Album.Cover != "" {
		coverPath = outputFilename + ".cover.jpg"
		albumArt, err := t.DownloadAlbumArt(trackInfo.Album.Cover)
		if err != nil {
			fmt.Printf("Warning: Failed to download album art: %v\n", err)
		} else {
			if err := os.WriteFile(coverPath, albumArt, 0644); err != nil {
				fmt.Printf("Warning: Failed to save album art: %v\n", err)
			} else {
				defer os.Remove(coverPath)
				fmt.Println("Album art downloaded")
			}
		}
	}

	releaseYear := ""
	if len(trackInfo.Album.ReleaseDate) >= 4 {
		releaseYear = trackInfo.Album.ReleaseDate[:4]
	}

	trackNumberToEmbed := 0
	if position > 0 {
		if useAlbumTrackNumber && trackInfo.TrackNumber > 0 {
			trackNumberToEmbed = trackInfo.TrackNumber
		} else {
			trackNumberToEmbed = position
		}
	}

	metadata := Metadata{
		Title:       finalTrackTitle,
		Artist:      finalArtistName,
		Album:       finalAlbumTitle,
		Date:        releaseYear,
		TrackNumber: trackNumberToEmbed,
		DiscNumber:  trackInfo.VolumeNumber,
		ISRC:        trackInfo.ISRC,
	}

	if err := EmbedMetadata(outputFilename, metadata, coverPath); err != nil {
		fmt.Printf("Tagging failed: %v\n", err)
	} else {
		fmt.Println("Metadata saved")
	}

	fmt.Println("Done")
	fmt.Println("✓ Downloaded successfully from Tidal (via search)")
	return outputFilename, nil
}

// apiResult holds the result from a parallel API request
type apiResult struct {
	apiURL      string
	downloadURL string
	err         error
}

// getDownloadURLParallel requests download URL from all APIs in parallel
// Returns the first successful result
func getDownloadURLParallel(apis []string, trackID int64, quality string) (string, string, error) {
	if len(apis) == 0 {
		return "", "", fmt.Errorf("no APIs available")
	}

	resultChan := make(chan apiResult, len(apis))

	// Start all requests in parallel with longer timeout client
	fmt.Printf("Requesting download URL from %d APIs in parallel...\n", len(apis))
	for _, apiURL := range apis {
		go func(api string) {
			// Create client with longer timeout for parallel requests
			client := &http.Client{
				Timeout: 15 * time.Second, // Longer timeout for parallel
			}

			url := fmt.Sprintf("%s/track/?id=%d&quality=%s", api, trackID, quality)
			resp, err := client.Get(url)
			if err != nil {
				resultChan <- apiResult{apiURL: api, err: err}
				return
			}
			defer resp.Body.Close()

			if resp.StatusCode != 200 {
				resultChan <- apiResult{apiURL: api, err: fmt.Errorf("HTTP %d", resp.StatusCode)}
				return
			}

			var apiResponses []TidalAPIResponse
			if err := json.NewDecoder(resp.Body).Decode(&apiResponses); err != nil {
				resultChan <- apiResult{apiURL: api, err: err}
				return
			}

			for _, item := range apiResponses {
				if item.OriginalTrackURL != "" {
					resultChan <- apiResult{apiURL: api, downloadURL: item.OriginalTrackURL, err: nil}
					return
				}
			}

			resultChan <- apiResult{apiURL: api, err: fmt.Errorf("no download URL in response")}
		}(apiURL)
	}

	// Collect results - return first success
	var lastError error
	var errors []string

	for i := 0; i < len(apis); i++ {
		result := <-resultChan
		if result.err == nil && result.downloadURL != "" {
			// First success - use this one
			fmt.Printf("✓ Got download URL from: %s\n", result.apiURL)
			return result.apiURL, result.downloadURL, nil
		} else {
			errMsg := result.err.Error()
			if len(errMsg) > 50 {
				errMsg = errMsg[:50] + "..."
			}
			errors = append(errors, fmt.Sprintf("%s: %s", result.apiURL, errMsg))
			lastError = result.err
		}
	}

	// Print all errors for debugging
	fmt.Println("All APIs failed:")
	for _, e := range errors {
		fmt.Printf("  ✗ %s\n", e)
	}

	return "", "", fmt.Errorf("all %d APIs failed. Last error: %v", len(apis), lastError)
}

// DownloadBySearchWithFallback tries multiple APIs when downloading via search
// Search is done ONCE, then requests all APIs in PARALLEL for download URL
func (t *TidalDownloader) DownloadBySearchWithFallback(trackName, artistName, albumName, spotifyISRC string, expectedDuration int, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, useAlbumTrackNumber bool) (string, error) {
	apis, err := t.GetAvailableAPIs()
	if err != nil {
		return "", fmt.Errorf("no APIs available for fallback: %w", err)
	}

	if outputDir != "." {
		if err := os.MkdirAll(outputDir, 0755); err != nil {
			return "", fmt.Errorf("directory error: %w", err)
		}
	}

	// Search ONCE to find the track
	fmt.Println("Searching for track...")
	trackInfo, err := t.SearchTrackByMetadataWithISRC(trackName, artistName, spotifyISRC, expectedDuration)
	if err != nil {
		return "", fmt.Errorf("search failed: %w", err)
	}

	if trackInfo.ID == 0 {
		return "", fmt.Errorf("no track ID found from search")
	}

	fmt.Printf("Track found: %s - %s (ID: %d)\n", trackInfo.Artist.Name, trackInfo.Title, trackInfo.ID)

	// Prepare metadata
	finalArtistName := artistName
	finalTrackTitle := trackName
	finalAlbumTitle := albumName

	if finalArtistName == "" {
		var artists []string
		if len(trackInfo.Artists) > 0 {
			for _, artist := range trackInfo.Artists {
				if artist.Name != "" {
					artists = append(artists, artist.Name)
				}
			}
		} else if trackInfo.Artist.Name != "" {
			artists = append(artists, trackInfo.Artist.Name)
		}
		if len(artists) > 0 {
			finalArtistName = strings.Join(artists, ", ")
		} else {
			finalArtistName = "Unknown Artist"
		}
	}
	finalArtistName = sanitizeFilename(finalArtistName)

	if finalTrackTitle == "" {
		finalTrackTitle = trackInfo.Title
		if finalTrackTitle == "" {
			finalTrackTitle = fmt.Sprintf("track_%d", trackInfo.ID)
		}
	}
	finalTrackTitle = sanitizeFilename(finalTrackTitle)

	if finalAlbumTitle == "" {
		finalAlbumTitle = trackInfo.Album.Title
	}

	// Check if file already exists
	if existingFile, exists := CheckISRCExists(outputDir, trackInfo.ISRC); exists {
		fmt.Printf("File with ISRC %s already exists: %s\n", trackInfo.ISRC, existingFile)
		return "EXISTS:" + existingFile, nil
	}

	filename := buildTidalFilename(finalTrackTitle, finalArtistName, trackInfo.TrackNumber, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	outputFilename := filepath.Join(outputDir, filename)

	if fileInfo, err := os.Stat(outputFilename); err == nil && fileInfo.Size() > 0 {
		fmt.Printf("File already exists: %s (%.2f MB)\n", outputFilename, float64(fileInfo.Size())/(1024*1024))
		return "EXISTS:" + outputFilename, nil
	}

	// Request download URL from ALL APIs in parallel - use first success
	successAPI, downloadURL, err := getDownloadURLParallel(apis, trackInfo.ID, quality)
	if err != nil {
		return "", err
	}

	// Download the file using the successful API
	fmt.Printf("Downloading to: %s\n", outputFilename)
	downloader := NewTidalDownloader(successAPI)
	if err := downloader.DownloadFile(downloadURL, outputFilename); err != nil {
		return "", fmt.Errorf("download failed: %w", err)
	}

	// Success! Add metadata
	fmt.Println("Adding metadata...")

	coverPath := ""
	if trackInfo.Album.Cover != "" {
		coverPath = outputFilename + ".cover.jpg"
		albumArt, err := downloader.DownloadAlbumArt(trackInfo.Album.Cover)
		if err != nil {
			fmt.Printf("Warning: Failed to download album art: %v\n", err)
		} else {
			if err := os.WriteFile(coverPath, albumArt, 0644); err != nil {
				fmt.Printf("Warning: Failed to save album art: %v\n", err)
			} else {
				defer os.Remove(coverPath)
				fmt.Println("Album art downloaded")
			}
		}
	}

	releaseYear := ""
	if len(trackInfo.Album.ReleaseDate) >= 4 {
		releaseYear = trackInfo.Album.ReleaseDate[:4]
	}

	trackNumberToEmbed := 0
	if position > 0 {
		if useAlbumTrackNumber && trackInfo.TrackNumber > 0 {
			trackNumberToEmbed = trackInfo.TrackNumber
		} else {
			trackNumberToEmbed = position
		}
	}

	metadata := Metadata{
		Title:       finalTrackTitle,
		Artist:      finalArtistName,
		Album:       finalAlbumTitle,
		Date:        releaseYear,
		TrackNumber: trackNumberToEmbed,
		DiscNumber:  trackInfo.VolumeNumber,
		ISRC:        trackInfo.ISRC,
	}

	if err := EmbedMetadata(outputFilename, metadata, coverPath); err != nil {
		fmt.Printf("Tagging failed: %v\n", err)
	} else {
		fmt.Println("Metadata saved")
	}

	fmt.Println("Done")
	fmt.Println("✓ Downloaded successfully from Tidal (via search)")
	return outputFilename, nil
}

func (t *TidalDownloader) DownloadWithFallback(spotifyTrackID, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool) (string, error) {
	// Get Tidal URL once
	tidalURL, err := t.GetTidalURLFromSpotify(spotifyTrackID)
	if err != nil {
		// Songlink failed to find Tidal URL, try search fallback with all APIs
		fmt.Printf("Songlink couldn't find Tidal URL: %v\n", err)
		fmt.Println("Trying Tidal search fallback with all APIs...")
		return t.DownloadBySearchWithFallback(spotifyTrackName, spotifyArtistName, spotifyAlbumName, "", 0, outputDir, quality, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	}

	// Use parallel API requests via DownloadByURLWithFallback
	return t.DownloadByURLWithFallback(tidalURL, outputDir, quality, filenameFormat, includeTrackNumber, position, spotifyTrackName, spotifyArtistName, spotifyAlbumName, useAlbumTrackNumber)
}

// DownloadWithFallbackAndISRC downloads with ISRC matching for search fallback
// Uses parallel API requests for faster download
func (t *TidalDownloader) DownloadWithFallbackAndISRC(spotifyTrackID, spotifyISRC, outputDir, quality, filenameFormat string, includeTrackNumber bool, position int, spotifyTrackName, spotifyArtistName, spotifyAlbumName string, useAlbumTrackNumber bool, expectedDuration int) (string, error) {
	// Get Tidal URL once
	tidalURL, err := t.GetTidalURLFromSpotify(spotifyTrackID)
	if err != nil {
		// Songlink failed to find Tidal URL, try search fallback with ISRC matching
		fmt.Printf("Songlink couldn't find Tidal URL: %v\n", err)
		fmt.Println("Trying Tidal search fallback with ISRC matching...")
		return t.DownloadBySearchWithFallback(spotifyTrackName, spotifyArtistName, spotifyAlbumName, spotifyISRC, expectedDuration, outputDir, quality, filenameFormat, includeTrackNumber, position, useAlbumTrackNumber)
	}

	// Use parallel API requests via DownloadByURLWithFallback
	return t.DownloadByURLWithFallback(tidalURL, outputDir, quality, filenameFormat, includeTrackNumber, position, spotifyTrackName, spotifyArtistName, spotifyAlbumName, useAlbumTrackNumber)
}

func buildTidalFilename(title, artist string, trackNumber int, format string, includeTrackNumber bool, position int, useAlbumTrackNumber bool) string {
	var filename string

	// Build base filename based on format
	switch format {
	case "artist-title":
		filename = fmt.Sprintf("%s - %s", artist, title)
	case "title":
		filename = title
	default: // "title-artist"
		filename = fmt.Sprintf("%s - %s", title, artist)
	}

	// Add track number prefix if enabled
	if includeTrackNumber && position > 0 {
		// Use album track number if in album folder structure, otherwise use playlist position
		numberToUse := position
		if useAlbumTrackNumber && trackNumber > 0 {
			numberToUse = trackNumber
		}
		filename = fmt.Sprintf("%02d. %s", numberToUse, filename)
	}

	return filename + ".flac"
}

```

